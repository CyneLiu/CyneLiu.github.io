<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[4.基于RESTCONF的流表管理]]></title>
    <url>%2F2018%2F09%2F14%2F4-%E5%9F%BA%E4%BA%8ERESTCONF%E7%9A%84%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[3.Open vSwitch流表管理]]></title>
    <url>%2F2018%2F09%2F14%2F3-Open-vSwitch%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[实验原理OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议去连接Open vSwitch，创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。 在OpenFlow的白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或者多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。 当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或者空格分开。一些常用的字段列举如下：ovs-ofctl关于流表管理的常用命令：对于add−flow，add−flows和mod−flows这三个命令，还需要指定要执行的动作：actions=[target][,target…]，一个流规则中可能有多个动作，按照指定的先后顺序执行。常见的操作有： 实验拓扑 创建实验步骤1 登录交换机，执行以下命令，查看镜像中原有的网桥，如下图所示。 ovs-vsctl show 步骤5 执行以下命令，删除当前网桥，并进行确认，如下图所示。 ovs-vsctl del-br br-sw ovs-vsctl show 流表管理步骤1 执行以下命令，添加网桥，并查看虚拟交换机的基本信息，如下图所示。 ovs-vsctl add-br br0 ovs-ofctl show br0 由上图可知，可以查看到交换机dpid、流表数量、性能参数、动作参数、MAC地址等信息。 步骤2 执行以下命令，查看虚拟交换机上各端口的状态，如下图所示。 ovs-ofctl dump-flows br0 由上图可知，输出的结果中包含了各端口上收到的数据包数，字节数，丢包数，错误数据包数等。 步骤3 执行以下命令，添加一条流表项，设置流表项生命周期为1000s，优先级为17，入端口为3，动作是output:2。 ovs-ofctl add-flow br0 idle_timeout=1000,priority=17,in_port=3,actions=output:2 说明：这条流表项的作用是将端口3接收到的数据包从端口2输出。 步骤4 执行以下命令，查看交换机上所有流表信息，如下图所示。 ovs-ofctl dump-flows br0 步骤5 执行以下命令，删除入端口为3的的流表项，删除后，再次查看流表信息，如下图所示。 ovs-ofctl del-flows br0 in_port=3 ovs-ofctl dump-flows br0]]></content>
      <categories>
        <category>SDN,网络</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒懂MBR和GPT分区表]]></title>
    <url>%2F2018%2F09%2F13%2F%E7%A7%92%E6%87%82MBR%E5%92%8CGPT%E5%88%86%E5%8C%BA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[分区表全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的Apple分区图。MBR的全称是Master Boot Record（主引导记录），MBR早在1983年IBM PC DOS 2.0中就已经提出。之所以叫“主引导记录”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。主引导扇区是硬盘的第一扇区。它由三个部分组成，主引导记录MBR、硬盘分区表DPT和硬盘有效标志。在总共512字节的主引导扇区里MBR占446个字节，偏移地址（0000H–0088H），它负责从活动分区中装载，并运行系统引导程序；第二部分是Partition table区（DPT分区表），占64个字节；第三部分是Magic number，占2个字节。 MBR分区表系统所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。 分区表偏移地址为01BEH–01FDH，每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4，分别对应MBR的四个主分区。Magic number也就是结束标志字，偏移地址01FE–01FF的2个字节，固定为55AA，如果该标志错误系统就不能启动。 MBR最大支持2.2TB磁盘，它无法处理大于2.2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区。 GPT分区表系统GPT的全称是Globally Unique Identifier Partition Table，意即GUID分区表，它的推出是和UEFI BIOS相辅相成的，鉴于MBR的磁盘容量和分区数量已经不能满足硬件发展的需求，GPT首要的任务就是突破了2.2T分区的限制，最大支持18EB的分区。 而在分区数量上，GPT会为每一个分区分配一个全局唯一的标识符，理论上GPT支持无限个磁盘分区，不过在Windows系统上由于系统的限制，最多只能支持128个磁盘分区，基本可以满足所有用户的存储需求。在每一个分区上，这个标识符是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符。 而在安全性方面，GPT分区表也进行了全方位改进。在早期的MBR磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT还为这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏，GPT会发觉这些破坏，并从磁盘上的其他地方进行恢复。 小结：所以对于新平台用户（Intel 6系以后/AMD 900系列以后和A系列）来说，都强烈推荐使用GPT分区表格式，目前包括Windows Vista、7、8、8.1、10已经都支持读取和使用GPT分区表。而对于使用Windows 8、8.1、10的用户，换用GPT后开机启动速度也可以进一步得到显著提升。 BIOS+MBR这种方式是目前最常见的装机方式，所有的系统都会支持，兼容较老硬件，目前新电脑大多出厂时就使用UEFI方式启动。 UEFI+GPTGPT与UEFI是相辅相成的，如果分区表系统是GPT，那么必须使用UEFI，传统的BIOS方式无法启动，这也就是为什么现在很多人在给新机器重装系统时无法启动的原因。 UEFI+GPT还有一个优点就是开机速度更快，原因是开机时跳过外设检测，并且可以实现启动时原生分辨率，搭载固态硬盘开机时间很短，十秒左右。 UEFI可用鼠标操作图形界面，不再是枯燥的蓝底白字的英文。由Intel提出，用于取代BIOS。UEFI的优越特性：可操作性、安全性、兼容性、可扩展性。 主板为了兼容MBR分区表，一般会提供Legacy BIOS和UEFI BIOS启动模式选项，可以把UEFI设置成Legacy模式（传统模式）、打开CSM兼容模块，让其支持传统MBR启动，此时效果同BIOS+MBR。如果要使用UEFI模式安装Windows，就必须开启UEFI启动模式。 系统支持性目前64bit Windows Vista、7、8、8.1、10都已经支持GPT分区表，而Windows 8、8.1、10都已经原生支持UEFI，安装这些系统的时候：只要硬盘设置为GPT分区表，主板设置为UEFI启动后，就可以直接开始安装操作系统了。 而对于Windows Vista、7系统，就需要手动添加UEFI支持：我们可以找一份Windows 8或者10安装镜像，从安装文件中提取Bootmgfw.efi文件，重命名为BOOTX64.EFI，拷贝到win7安装文件的\EFI\Boot\下，如果没有BOOT文件夹新建一个即可。 修改为传统方式启动如果实在是搞不明白或者像之前的我一样不太懂的话，可以使用分区助手将GPT改为MBR，如图：选中磁盘，在左侧菜单中选择“转换到MBR磁盘”：转换成功：转换完成进行分区后，不要忘了把装系统的分区转换成活动分区：最后还是建议大家花几分钟时间了解一下UEFI的方式，这必定是未来的一个趋势，并不推荐采用上图将GPT修改为MBR的方式重装系统。]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>装机</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.OVSDB的网桥和端口管理]]></title>
    <url>%2F2018%2F09%2F13%2F2-OVSDB%E7%9A%84%E7%BD%91%E6%A1%A5%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[实验原理在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFlow和OVSDB两种南向协议方式与Open vSwitch交换机进行交互，其中通过OpenFlow来引导数据包流的转发，通过OVSDB可以进行端口和隧道的增加、更新以及删除，这些隧道和端口提供流转发的管道。因此，OVSDB在Open vSwitch作为一个重要的事实标准，OpenDaylight系统如何高效地支持OVSDB也变得非常重要。OpenDaylight的OVSDB子项目实现了OVSDB管理协议，该协议允许控制器进行虚拟交换机的南向配置。OVSDB协议包含一个OVSDB库和各种插件用法，该协议使用JSON/RPC调用的方式来操作内置OVSDB的物理或虚拟交换机。OVSDB子项目主要包含Northbound模块、plugin模块和OVSDB Library模块，其中北向Northbound模块可供外部APP调用，南向OVSDB Library通过OVSDB协议与外部通信，进行OVSDB的管理，具体系统架构如下图所示。Library模块主要包含message、notation、impl、jsonrpc和schema等程序包,其中jsonrpc主要提供兼容rpc1.0的解码器，能够从TCP流解码JSON消息；notation主要包含OVSDB MAP、ResultSet等定义以及Json串行化；schema提供OVSDB数据库模式的表示。 Plugin模块主要包含api、impl、internal和error等程序包，其中api程序包主要提供OVSDB的连接、增删改查等服务，impl包中的类是其接口的实现。 Northbound模块主要包含五大类,分别是DatabaseResource、NodeResource、OvsdbNorthboundV2、OvsdbNorthboundV3、RowResource、TableResource。以类OvsdbNorthboundV2为例进行说明，该类提供OVSDB北向 REST API接口，用于创建、读取、更新和删除任一OVSDB表中的记录。创建OVSDB Row时，body请求体中的JSON格式与OVSDB JSON-PRC消息相同。northbound及其功能描述如下表所示。用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。而Postman不仅可以调试简单的css、html、脚本等简单的网页基本信息，还可以发送GET、POST、PUT、DENLETE等几乎所有类型的HTTP请求。Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。 实验拓扑 创建实验步骤1 登录OpenDaylight控制器，确保服务已经启动成功，由于OpenDaylight组件过于庞大，所以启动比较慢，需等待一段时间，使用命令： netstat -an|grep 6633 查看端口是否处于监听状态：步骤2 在保证控制6633端口处于监听状态后，登录交换机，查看交换机与控制器连接情况。执行以下命令： ovs-vsctl show 上图中controller下方显示“is_connected:true”则表明连接成功。步骤3 登录控制器，查看控制器IP，如下图所示。步骤4 登录交换机，连接控制器。原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。执行如下命令： ovs-vsctl set-manager tcp:20.0.1.3:6640 连接成功后在manager下面会有“is_conneted:true”： 创建网桥步骤1 登录控制器，单击Applications Menu—&gt;Development—&gt;Postman打开Postman应用，如下图所示。步骤2 在创建网桥前，需要先获取交换机节点信息，输入URL http://[controller ip]:8282/ovsdb/nb/v3/node。 请求类型选择GET，单击Send按钮发送GET请求。访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择Basic Auth。输入用户名和密码，用户名和密码都是admin。Body中返回的就是交换机节点信息，此处获取到的节点信息在后面会用到，如下图所示。步骤3 发送POST请求创建网桥。输入URL http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141” 就是前面获取到的交换机节点信息，如下图所示。单击Headers，输入用户名和密码生成HTTP认证头部，POST请求还需要添加头部指明Body格式，如图所示，手动输入Content-Type且值为application/json，如下图所示。步骤4 单击Body，Body格式选择raw—&gt;JSON(application/json)。Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。 Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。单击Send按钮发送请求。 { &quot;row&quot;: { &quot;Bridge&quot;: { &quot;name&quot;: &quot;br0&quot;, &quot;datapath_type&quot;: &quot;OpenFlow13&quot; } } } 步骤5 登录交换机，确认网桥创建成功。执行以下命令： ovs-vsctl show 获取网桥uuid步骤1 URL保持不变，依旧是http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows ，将请求类型改为GET。输入用户名和密码生成HTTP认证头部，如下图所示。步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并返回网桥信息，下图中两个uuid分别是br0和br-sw的。单击uuid所在行左侧的数字可以展开/收起网桥的详细信息，方便查看，如下图所示。 创建端口步骤1 发送POST请求创建端口，输入URL http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。单击Basic Auth，输入用户名和密码生成HTTP认证头部，并且添加Content-Type为application/json，如下图所示。步骤2 将请求类型改为POST，输入Body内容如下所示，其中parent_uuid是网桥的uuid，这里所用的是br0的uuid，那么端口就会添加到br0网桥上。 { &quot;parent_uuid&quot;: &quot;2dd82e5e-922d-43c8-80d9-7917161acfd2&quot;, &quot;row&quot;: { &quot;Port&quot;: { &quot;name&quot;: &quot;port0&quot; } } } 单击Send按钮发送请求，STATUS显示请求发送成功，端口已经创建，如下图所示。步骤3 登录交换机，确认交换机端口是否创建成功。执行以下命令： ovs-vsctl show 获取端口uuid步骤1 发送GET请求获取端口的uuid。输入URL http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows 。在Basic Auth页面输入用户名和密码生成HTTP认证头部，如下图所示。步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并且展示出获取到的端口信息。因为获取的是所有网桥的端口所以比较多，如下图所示，标注出来的是port0的uuid。获取到的信息完全展开比较多，可以直接在页面中搜索端口名称“port0”，然后往上翻找该端口的uuid，如下图所示。 删除端口步骤1 发送DELETE请求删除端口。输入URL http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8 ”就是port0端口的uuid，如下图所示。步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。步骤3 登录交换机，确认port0端口删除成功。 ovs-vsctl show 删除网桥步骤1 发送DELETE请求删除网桥。输入URL http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2” 就是br0网桥的uuid，如下图所示。步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。步骤3 登录交换机，确认网桥br0删除成功。执行以下命令： ovs-vsctl show]]></content>
      <categories>
        <category>SDN,网络</category>
      </categories>
      <tags>
        <tag>SDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.OpenFlow建立连接交互流程]]></title>
    <url>%2F2018%2F09%2F13%2F1-OpenFlow%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[OpenFlow协议简介2006年，斯坦福大学Clean Slate计划资助的Ethane项目开始部署，致力于企业网架构的创新，OpenFlow协议的雏形就诞生于这个项目。2008年，Nick McKeown教授的一篇重要论文“OpenFlow：Enabling Innovation in Campus Networks”使得OpenFlow正式进入人们的视野，继而成为了标准化组织ONF（Open Network Foundation，开放网络基金会）主推的南向接口协议。经过多年的发展，OpenFlow现已成为SDN的主流南向接口协议之一。目前，OpenFlow协议还在不断地演进中，本实验采用OpenFlow v1.3协议，并对控制器与OpenFlow交换机之间的交互过程进行深入分析。OpenFlow主要有3种类型的消息，分别是Controller-to-Switch、Asynchronous和Symmetric，其中每个类型又包含多个子类型。Controller-to-Switch消息由控制器发起，用于管理、查看交换机的状态。Asynchronous消息由交换机发起，向控制器汇报交换机的事件和改变。Symmetric消息由控制器或交换机任一方发起，无需请求直接发起消息。详细信息如下表所示： OpenFlow连接建立交互流程在OpenFlow1.3协议的情况下，控制器与OpenFlow交换机的消息完整交互流程如下：1、 控制器与OpenFlow交换机通过TCP“三次握手”，建立有效的连接。其中，控制器一端的端口号为6633。2、 控制器与OpenFlow交换机之间相互发送Hello消息，用于协商双方的OpenFlow版本号。在双方支持的最高版本号不一致的情况下，协商的结果将以较低的OpenFlow版本为准。如果双方协商不一致，还会产生Error消息。3、 控制器向OpenFlow交换机发送Features Request消息，请求OpenFlow交换机上传自己的详细参数。OpenFlow交换机收到请求后，向控制器发送Features Reply消息，详细汇报自身参数，包括支持的buffer数目、流表数以及Actions等。4、 控制器通过Set Config消息下发配置参数，然后通过Get config Request消息请求OpenFlow交换机上传修改后的配置信息。OpenFlow交换机通过Get config Reply消息向控制器发送当前的配置信息。5、 控制器与OpenFlow交换机之间发送Packet_out、Packet_in消息，通过Packet_out中内置的LLDP包，进行网络拓扑的探测。6、 控制器与OpenFlow交换机之间通过发送Multipart Request、Mutipart Reply消息，控制器能获取OpenFlow交换机的状态信息，包括流的信息、端口信息等。7、 控制器与OpenFlow交换机之间通过发送Echo Request、Echo Reply消息，保证二者之间存在有效连接，避免失联。 实验拓扑 捕获数据包步骤1 登录Floodlight控制器，启动抓包工具Wireshark，捕获控制器与交换机建立连接过程中的数据包，通过分析这些数据包了解控制器与交换机基于OpenFlow协议进行交互的流程。执行以下命令： sudo wireshark 步骤2 双击eth0网卡，查看eth0网卡上数据包收发情况，如下图所示。步骤3 登录Mininet虚拟机，启动Mininet。通过“—controller”参数设置Mininet连接远程控制器，并指定控制器的IP和端口号。 sudo mn --controller=remote,ip=30.0.1.3,port=6633 --switch=ovsk,protocols=OpenFlow13 步骤4 登录Floodlight控制器，停止Wireshark，观察数据包列表，可以看出控制器与交换机的基本交互流程。 OpenFlow1.3交互流程分析步骤1 交换机连接控制器的6633端口，经过3次握手后双方建立TCP连接。查看捕获到的数据包，分析交换机与控制器建立TCP连接的流程。分析TCP连接建立过程，需要先了解TCP的状态位，主要包括SYN、FIN、ACK、PSH、RST和URG。SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。可以看出交换机与控制器经历一次连接重置后，成功完成三次握手，建立TCP连接，如下图所示。步骤2 当控制器与交换机建立TCP连接后，由其中某一方发起Hello消息，双方协调协OpenFlow议版本号。控制器和交换机都会向对方发送一条Hello消息，消息中附上自己支持的OpenFlow的最高版本。接收到对方Hello消息后，判断自己能否支持对方发送的版本，能支持则版本协商成功，不能支持则回复一条OFPT_ERROR消息。查看Hello消息详情，本实验中由于交换机和控制器都能支持OpenFlow1.3版本，所以版本协商为1.3，如下图所示。步骤3 OpenFlow版本协商完成后，控制器发送一条features_request消息获取交换机的特性信息，包括交换机的ID（DPID）、缓冲区数量、端口及端口属性等等。相应的，交换机回复features_reply消息，如下图所示。查看数据包详情，ofpt_feature_request消息只有包头，如下图所示。ofpt_feature_reply数据包详情如下，交换机的DPID是数据通道独一无二的标识符，低48位是一个MAC地址，高16位是自定义的。本实验中交换机缓冲区数量（n_buffers）为256，交换机支持的流表数量（n_tables）为254，交换机所支持的功能，如下图所示。步骤4 OpenFlow1.0协议中feature_reply消息还包含交换机端口信息，OpenFlow 1.3协议将‘stats’框架更名为‘multipart’框架，并且将端口描述移植到multipart消息中。其中OPPT_PORT_DESC类型的multipart消息就是用于获取交换机端口信息的。查看OPPT_PORT_DESC类型multipart_reply消息，消息中列出了交换机的端口以及每个端口的详细信息，包括端口名称和mac地址等，如下图所示。步骤5 OFPMP_DESC类型的multipart_reply消息包含了交换机的其他信息，包括交换机厂商名称、交换机名称以及交换机版本等。本实验中使用的是Mininet仿真软件中自带的开源交换机Open vSwitch(2.0.2)，而Open vSwitch是由Nicira Networks主导开发的，如下图所示。步骤6 在连接过程中，控制器不断的发送echo_request消息给交换机，确认交换机与控制器之间的连接状态。相应的，交换机会回复echo_reply消息，如下图所示。]]></content>
      <categories>
        <category>SDN,网络</category>
      </categories>
      <tags>
        <tag>SDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDN中的南向接口和北向接口]]></title>
    <url>%2F2018%2F09%2F11%2FSDN%E4%B8%AD%E7%9A%84%E5%8D%97%E5%90%91%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%8C%97%E5%90%91%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[SDN的意义SDN网络的最终目标是服务于多样化的业务应用创新。因此随着SDN技术的部署和推广，将会有越来越多的业务应用被研发，这类应用将能够便捷地通过SDN北向接口调用底层网络能力，按需使用网络资源。 SDN推动业务创新已经是业界不争的事实，它可以被广泛地应用在云数据中心、宽带传输网络、移动网络等种种场景中，其中为云计算业务提供网络资源服 务就是一个非常典型的案例。众所周知，在当前的云计算业务中，服务器虚拟化、存储虚拟化都已经被广泛应用，它们将底层的物理资源进行池化共享，进而按需分配给用户使用。相比之下，传统的网络资源远远没有达到类似的灵活性，而SDN的引入则能够很好地解决这一问题。 南向接口SDN通过标准的南向接口屏蔽了底层物理转发设备的差异，实现了资源的虚拟化，同时开放了灵活的北向接口供上层业务按需进行网络配置并调用网络资源。 云计算领域中知名的OpenStack就是可以工作在SDN应用层的云管理平台，通过在其网络资源管理组件中增加SDN管理插件，管理者和使用者可利 用SDN北向接口便捷地调用SDN控制器对外开放的网络能力。当有云主机组网需求(例如建立用户专有的VLAN)被发出时，相关的网络策略和配置可以在 OpenStack管理平台的界面上集中制定并进而驱动SDN控制器统一地自动下发到相关的网络设备上。 当前，最知名的南向接口莫过于ONF倡导的OpenFlow协议。作为一个开放的协议，OpenFlow突破了传统网络设备厂商对设备能力接口的壁垒，经过多年的发展，在业界的共同努力下，当前已经日臻完善，能够全面解决SDN网络中面临的各种问题。 因此，网络资源可以和其他类型的虚拟化资源一样，以抽象的资源能力的面貌统一呈现给业务应用开发者，开发者无需针对底层网络设备的差异耗费大量开销从事额外的适配工作，这有助于业务应用的快速创新。 控制层控制层是SDN的大脑，负责对底层转发设备的集中统一控制，同时向上层业务提供网络能力调用的接口，在SDN架构中具有举足轻重的作用，SDN控制 器也是SDN关注的焦点。从技术实现上看，控制器除了南向的网络控制和北向的业务支撑外，还需要关注东西的扩展，以避免SDN集中控制导致的性能和安全瓶颈问题，SDN控制器也在南向、北向、东西向上引入了相应的核心技术，有效解决与各层通信以及控制集群横向扩展的难题。 当前，业界有很多基于OpenFlow控制协议的开源的控制器实现，例如NOX、Onix、Floodlight等，它们都有各自的特色设计，能够实现链路发现、拓扑管理、策略制定、表项下发等支持SDN网络运行的基本操作。虽然不同的控制器在功能和性能上仍旧存在差异，但是从中已经可以总结出SDN控制器应当具备的技术特征，从这些开源系统的研发与实践中得到的经验和教训将有助于推动SDN控制器的规范化发展。 另外，用于网络集中化控制的控制器作为SDN网络的核心，其性能和安全性非常重要，其可能存在的负载过大、单点失效等问题一直是SDN领域中亟待解决的问题。当前，业界对此也有了很多探讨，从部署架构、技术措施等多个方面提出了很多有创见的方法。 SDN控制器对网络的控制主要是通过南向接口协议实现,包括链路发现、拓扑管理、策略制定、表项下发等，其中链路发现和拓扑管理主要是控制其利用南 向接口的上行通道对底层交换设备上报信息进行统一监控和统计;而策略制定和表项下发则是控制器利用南向接口的下行通道对网络设备进行统一控制。 北向接口SDN北向接口是通过控制器向上层业务应用开放的接口，其目标是使得业务应用能够便利地调用底层的网络资源和能力。通过北向接口，网络业务的开发者 能以软件编程的形式调用各种网络资源;同时上层的网络资源管理系统可以通过控制器的北向接口全局把控整个网网络的资源状态，并对资源进行统一调度。因为北 向接口是直接为业务应用服务的，因此其设计需要密切联系业务应用需求，具有多样化的特征。同时，北向接口的设计是否合理、便捷，以便能被业务应用广泛调用，会直接影响到SDN控制器厂商的市场前景。 与南向接口方面已有OpenFlow等国际标准不同，北向接口方面还缺少业界公认的标准，因此，北向接口的协议制定成为当前SDN领域竞争的焦点， 不同的参与者或者从用户角度出发，或者从运营角度出发，或者从产品能力角度出发提出了很多方案。据悉,目前至少有20种控制器,每种控制器会对外提供北向 接口用于上层应用开发和资源编排。虽然北向接口标准当前还很难达成共识，但是充分的开放性、便捷性、灵活性将是衡量接口优劣的重要标准，例如REST API就是上层业务应用的开发者比较喜欢的接口形式。部分传统的网络设备厂商在其现有设备上提供了编程接口供业务应用直接调用，也可被视作是北向接口之一，其目的是在不改变其现有设备架构的条件下提升配置管理灵活性，应对开放协议的竞争。 SDN交换机SDN的核心理念之一就是将控制功能从网络设备中剥离出来，通过中央控制器实现网络可编程，从而实现资源的优化利用，提升网络管控效率。 工作在基础设施层的SDN交换机虽然不在需要对逻辑控制进行过多考虑，但作为SDN网络中负责具体数据转发处理的设备，为了完成高速数据转发，还是 要遵循交换机工作原理。本质上看，传统设备中无论是交换机还是路由器，其工作原理都是在收到数据包时，将数据包中的某些特征域与设备自身存储的一些表项进 行比对，当发现匹配时则按照表项的要求进行相应处理。SDN交换机也是类似的原理，但是与传统设备存在差异的是，设备中的各个表项并非是由设备自身根据周 边的网络环境在本地自行生成的，而是由远程控制器统一下发的，因此各种复杂的控制逻辑(例如链路发现、地址学习、路由计算等等)都无需在SDN交换机中实现。 SDN交换机可以忽略控制逻辑的实现，全力关注基于表项的数据处理，而数据处理的性能也就成为评价SDN交换机优劣的最关键指标，因此，很多高性能 转发技术被提出，例如基于多张表以流水线方式进行高速处理的技术。另外，考虑到SDN和传统网络的混合工作问题，支持混合模式的SDN交换机也是当前设备 层技术研发的焦点。同时，随着虚拟化技术的出现和完善，虚拟化环境将是SDN交换机的一个重要应用场景，因此SDN交换机可能会有硬件、软件等多种形态。 例如，OVS(Open vSwitch，开放虚拟交换标准)交换机就是一款基于开源软件技术实现的能够集成在服务器虚拟化Hypervisor中的交换机，具备完善的交换机功能，在虚拟化组网中起到了非常重要的作用。 SDN交换机的出现，对传统的网络设备厂商造成了最直接的威胁，如何将新兴的网络技术与传统设备产品的优势相融合，是这些厂商正在苦苦思索的问题。 虽然SDN交换机已经对传统的网络产业链造成了巨大的冲击，但是仅凭单独的数据转发设备还不足以支撑起整个SDN的天空，未来更激烈地竞争必将会在SDN的控制层和应用层发生。]]></content>
      <categories>
        <category>SDN,网络</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda开始菜单失踪]]></title>
    <url>%2F2018%2F09%2F10%2FAnaconda%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E5%A4%B1%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[今天想打开Anaconda写python程序的时候，突然发现Anaconda在开始菜单中神秘失踪了。这时候只需要打开cmd，切换到Anaconda的安装目录的Lib文件夹下，执行如下命令： python _nsis.py mkmenus 重新生成一下开始菜单即可。]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟化运维笔记——服务器]]></title>
    <url>%2F2018%2F07%2F11%2F%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[服务器通电自启实验室有三台浪潮的服务器，默认关闭了通电自启的功能，因为不使用，也一直没去在意它，今天没事给它把通电自启动打开了，省的以后麻烦，在此记录一下，下图内容拍自浪潮服务器：1、开机时按Delete键进入BIOS2、选择Chipset-PCH3、将Restore AC Power Loss修改为Power Off这里解释一下各个选项的意思： Restore AC Power Loss:如果发生断电，恢复供电后系统如何反应Power Off:接通电源后保持关机状态Power On:接通电源后开机Last State:恢复到断电前的状态]]></content>
      <categories>
        <category>运维，笔记</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟化运维笔记——vsphere]]></title>
    <url>%2F2018%2F07%2F11%2F%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94vsphere%2F</url>
    <content type="text"><![CDATA[设置虚拟机随主机自动启动0、选择虚拟机所在主机单击选择虚拟机所在的主机，在后侧选项卡中选择“配置” 1、设置属性单击右上角的属性 2、设置虚拟机自动启动勾选“允许虚拟机与系统一起自动启动和停止”，然后在“启动顺序”中将需要设置自动启动的虚拟机上移到自动启动一栏下，如果有需要，可根据情况设置启动延迟，最后点击确定即可。]]></content>
      <categories>
        <category>运维，笔记</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinSCP——基于SSH的安全文件传输软件]]></title>
    <url>%2F2018%2F07%2F03%2FWinSCP%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ESSH%E7%9A%84%E5%AE%89%E5%85%A8%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[我的一个影视网站因为之前买的虚拟主机到期了，就想着把它放到我那台ssr主机上，结果配置vstp的时候不知道什么原因，配置完用客户端登录的时候总是提示说密码验证失败。然后看到一个博主推荐，就是WinSCP了，它的好处在于他是基于SSH协议的sftp文件传输，也就是说，只要你的linux主机可以使用ssh，就可以用它进行文件传输。 sftpsftp(Secure File Transfer Protocol)，安全文件传送协议，可以为传输文件提供一种安全的网络的加密方法。sftp与ftp有着几乎一样的语法和功能。SFTP是SSH的一部分，其实在SSH软件包中，已经包含了一个叫作SFTP的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，所以在对网络安全性要求更高时，可以使用SFTP代替FTP。 sftp于ftp的区别FTP是一种文件传输协议，一般是为了方便数据共享的，包括一个FTP服务器和多个FTP客户端，FTP客户端通过FTP协议在服务器上下载资源。而SFTP协议是基于SSH，并在FTP的基础上对数据进行加密，使得传输的数据相对来说更安全。但是这种安全是以牺牲效率为代价的，也就是说SFTP的传输效率比FTP要略低。而且在我的使用过程中，并没有感觉sftp的效率较于ftp有太大的差异，而且使用sftp最大的一个好处就是不需要安装而且安全性更高。更详细的区别可以移步这里：Sftp和ftp 区别、工作原理等（汇总ing） WinSCP官网地址：https://winscp.net/eng/docs/lang:chs除了WinSCP，Windows环境下还可以使用Core FTP，FileZilla, WinSCP，Xftp来连接SFTP进行上传，下载文件，建立，删除目录等操作。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>文件传输</tag>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟化运维笔记 —— Linux]]></title>
    <url>%2F2018%2F06%2F25%2F%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux%2F</url>
    <content type="text"><![CDATA[LinuxLinux下使用Rinetd来实现端口转发安装centos0、对于centos，由于官方的源中并没有Rinetd，所以首先需要第三方源32位系统： $ vim /etc/yum.repos.d/nux-misc.repo [nux-misc] name=Nux Misc baseurl=http://li.nux.ro/download/nux/misc/el6/i386/ enabled=0 gpgcheck=1 gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro 64位系统： $ vim /etc/yum.repos.d/nux-misc.repo: [nux-misc] name=Nux Misc baseurl=http://li.nux.ro/download/nux/misc/el6/x86_64/ enabled=0 gpgcheck=1 gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro 1、安装Rinetd $ yum --enablerepo=nux-misc install rinetd Ubuntu apt-get install rinetd 配置端口转发的配置文件在/etc/rinetd.conf配置文件的格式： [bindaddress] [bindport] [connectaddress] [connectport] 绑定的地址 绑定的端口 连接的地址 连接的端口 [Source Address] [Source Port] [Destination Address] [Destination Port] 源地址 源端口 目的地址 目的端口 例如： 0.0.0.0 8080 172.19.94.3 8080 0.0.0.0 2222 192.168.0.103 3389 1.2.3.4 80 192.168.0.10 80 allow *.*.*.* logfile /var/log/rinetd.log 说明 0.0.0.0表示本机绑定所有可用地址将所有发往本机8080端口的请求转发到172.19.94.3的8080端口将所有发往本机2222端口的请求转发到192.168.0.103的3389端口将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口allow设置允许访问的ip地址信息,...表示所有IP地址logfil设置打印的log的位置 启动程序 pkill rinetd ##关闭进程 rinetd -c /etc/rinetd.conf ##启动转发 把命令加到/etc/rc.local里面就可以开机自动运行 Ubuntu默认编辑器nano用习惯了vim编辑器，有时候想修改配置文件，可设备又没网，Ubuntu默认使用的是nano编辑器，真心不如vim好用。 ctrl+X #退出 ctrl+O #保存 Ubuntu设置静态ip通过修改“/etc/network/interfaces”进行修改，注：在设置多个DNS服务器的时候要加“s”,如： dns-nameservers 114.114.114.114 8.8.8.8 修改之后需要执行： sudo /etc/init.d/networking restart 使用这个方式修改ip地址，修改完interfaces文档中的内容后，需要修改/etc/NetworkManager/NetworkManager.conf文档中的managed参数，使之为true，并重启。否则，会提示说“有线网络设备未托管”。重启网络或系统之后就修改完成了。 安装TeamViewerteamviewer远程登录的方式不建议使用！1、到TeamViewer官网下载对应版本的安装包。2、下载完成之后切换到下载目录，执行： sudo dpkg -i teamviewer_13.0.9865_amd64.deb 版本号要根据下载的包进行更改。这时候可能会报出如下错误： 正在选中未选择的软件包 teamviewer。 (正在读取数据库 … 系统当前共安装有 253291 个文件和目录。) 正准备解包 teamviewer_13.0.6634_amd64.deb … 正在解包 teamviewer (13.0.6634) … dpkg：警告：无法删除原有的目录 /var/log/teamviewer12 ：目录非空 dpkg: 依赖关系问题使得 teamviewer 的配置工作不能继续： teamviewer 依赖于 qtdeclarative5-dialogs-plugin (&gt;= 5.2) | qml-module-qtquick-dialogs (&gt;= 5.2)；然而： 未安装软件包 qtdeclarative5-dialogs-plugin。 未安装软件包 qml-module-qtquick-dialogs。 dpkg: 处理软件包 teamviewer (–install)时出错： 依赖关系问题 - 仍未被配置 正在处理用于 desktop-file-utils (0.22-1ubuntu5.1) 的触发器 … 正在处理用于 gnome-menus (3.13.3-6ubuntu3.1) 的触发器 … 正在处理用于 bamfdaemon (0.5.3~bzr0+16.04.20160824-0ubuntu1) 的触发器 … Rebuilding /usr/share/applications/bamf-2.index… 正在处理用于 mime-support (3.59ubuntu1) 的触发器 … 正在处理用于 hicolor-icon-theme (0.15-0ubuntu1) 的触发器 … 在处理时有错误发生： teamviewer 目前我遇到的有两种解决方式：一、修复依赖关系 一种解决方法是执行如下命令修复依赖关系： sudo apt install f 执行完后再安装看看能否成功，如果还是不成功就要采用第二种方式了。二、更新源地址 ①删除安装到一半的teamviewer： sudo apt-get remove teamviewer ②在Ubuntu的源列表中找到对应系统的源，复制到/etc/apt/sources.list 里面，并把原来的链接注释掉。③更新系统软件： sudo apt-get update #更新软件列表 sudo apt-get upgrade #更新软件 ④运行安装命令： sudo dpkg -i teamviewer_13.0.9865_amd64.deb 3、在TeamViewer的使用中发现经常在系统重启后连接就出现“未知原因”的问题，原因还在摸索中，目前能解决的方法就是卸载重新安装： apt purge teamviewer sudo dpkg -i teamviewer_13.0.9865_amd64.deb 16.04出现“The system is running in low-graphics mode”在虚拟机中安装的Ubuntu16.04无法显示完全，尝试修改分辨率后会卡死，然后重启就会出现如题所示的错误。解决方法为：1、重启虚拟机，按ctrl + alt + F1 进入纯字符界面，输入账号和密码2、执行如下命令： cd /etc/X11 sudo cp xorg.conf.failsafe xorg.conf #刷新配置文件 sudo reboot 重启之后就可以正常显示了。 启用root用户执行： sudo passwd root 设置密码后即可使用su直接切换为root用户。 安装GNOME Shell桌面1、安装GNOME Shell sudo apt-get install gnome-shell 安装过程中出现如下界面，选择lightdm：2、退出当前账户，选择GNOME桌面系统3、重新登陆，安装gnome-tweak sudo apt-get install gnome-tweak-tool tweak是主题管理工具，具体使用方法参见：https://itsfoss.com/install-switch-themes-gnome-shell/ 4、使用tweak更换主题方法参考：https://itsfoss.com/gnome-shell-themes-ubuntu-1404/ 执行sudo apt-get update出错在运行sudo apt-get update时出现如下信息： Reading package lists... Done E: Problem executing scripts APT::Update::Post-Invoke-Success &apos;if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi&apos; E: Sub-process returned an error code 解决方法如下： sudo pkill -KILL appstreamcli wget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.deb sudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb 或者： apt show appstream sudo apt remove appstream Ubuntu在虚拟机中显示不全的问题关于这个问题之前也是尝试了无数的方法，今天无意间明白了原因并解决了问题。1、首先要明白的是不是随便一个分辨率都可以更改，首先执行以下命令查询当前的显示状态： xrandr 其中第一个带*的就是当前的分辨率，其下的数值是我们可以更改的分辨率，每个虚拟机可能略有不同。2、执行： xrandr -s 1440x900_59.9 即可将分辨率设置为1440x900。3、上述命令只能临时修改，永久修改需要执行： xrandr --output Virtual1 --mode 1440x900 其中“Virtual1”是显示器的名称，要根据执行xrandr返回的信息进行相应的替换。4、错误这些也是我自己遇到的一点问题。 ①有时候执行步骤3中所说的命令并不能永久更改，重启后会失效。目前一个方法就是在系统设置→显示中应用一下更改过来的分辨率，这样在重启之后就不会出现问题了。②“xrandr: Configure crtc 0 failed” 这是一个系统bug，在设置,关于这台计算机,检查更新。更新完重启后就没问题了。 Ubuntu16.04安装VNC“VNC有很多选择，VNC4server，tigervncserver等等，都不推荐，难装又难用。经过多次实验和测试，最后只采用x11vnc作为VNC服务器端。” 查看原文1、安装X11VNC sudo apt install x11vnc -y 2、配置访问密码 sudo x11vnc -storepasswd /etc/x11vnc.pass 3、创建服务 vi /lib/systemd/system/x11vnc.service 粘贴如下代码： [Unit] Description=Start x11vnc at startup. After=multi-user.target [Service] Type=simple ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared [Install] WantedBy=multi-user.target 4、配置防火墙，配置并启动服务 sudo ufw allow 5900 sudo systemctl enable x11vnc.service sudo systemctl daemon-reload 如果出现如下图所示的错误，就说明第三步中你的配置信息粘贴错误了，修改正确即可解决。5、重启系统 reboot nat123配置nat123端口映射是专业的内网端口映射软件，在内网启动映射后，可在外网轻松访问连接内网网站等应用，不需要设置路由器，不需要公网ip,不需要固定ip,不需要动态域名。 Ubuntu配置过程：（其它linux直接参考官网说明）0、注册账号没有注册过账号的先到官网注册：http://www.nat123.com/1、安装mono运行环境 apt-get install mono-complete 安装完成后执行“mono -V”可查看安装的版本信息。2、客户端安装 cd /opt mkdir nat123 cd /nat123 wget http://www.nat123.com/down/nat123linux.tar.gz tar -zxvf nat123linux.tar.gz 3、启动客户端 cd /opt/nat123 mono nat123linux.sh 输入用户名和密码登录成功后，直接结束当前进程，然后执行如下命令改为后台运行： cd /opt/nat123 mono nat123linux.sh service &amp; ps -ef|grep nat123 #查看nat123状态 4、登录网页添加端口映射或动态域名解析 RHEL系统意外重启后VNC连接失败在服务器中运行着几个RHEL实例，VNC是之前老师配置的，这几个实例在服务器断电重启之后会出现VNC连接出错的问题。解决方法如下： cd /tmp rm -rvf .X11-unix #手动删除因为VNC非正常退出未删除的文件 vncserver :3 #重启服务]]></content>
      <categories>
        <category>运维，笔记</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDN入门（一）—— 环境搭建]]></title>
    <url>%2F2018%2F06%2F24%2FSDN%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Ubuntu安装系统选择镜像建议使用16.04的版本，mininet官网有说明，是因为16.04支持新版本的openflow等协议，我这里使用的是“ubuntu-16.04-server-amd64.iso”，server版本更加稳定。 虚拟机安装设置网卡因为要使用ssh远程登录，这里我们添加一个网卡：勾选“启用网络连接”，并选择仅主机模式。 系统安装挂载镜像之后启动虚拟机进行安装，基本的安装过程不一一详细介绍，不会的地方可以百度。可以看到安装程序已经识别出了两块网卡，我们选择默认的nat网卡作为主网络接口。软件安装，我们只需要安装ssh server就可以了，记得空格选择，回车确认。 安装完成后，我们看一下系统的网卡信息，发现并没有我们添加的网卡。执行“sudo dhclient enp0s8”启用enp0s8网卡。再次查看网卡信息：可以看到已经添加进来了。我们还需要将第二块网卡的配置加入到网络配置文件中，不然重启之后第二块网卡还是看不到的： sudo vi /etc/network/interfaces 在interfaces配置文件中加入enp0s8，同样使用dhcp方式获取ip至此，我们的系统就配置完成了，用ssh工具进行连接：已经可以成功连接。 安装Ryu详细内容可参考linton的博客。 1.下载python的套件库，并更新pip（因为下载的pip并不是最新版本） sudo apt-get install python-pip python-dev build-essential sudo pip install --upgrade pip 2.安装Ryu相依性套件 sudo apt-get install python-eventlet sudo apt-get install python-routes sudo apt-get install python-webob sudo apt-get install python-paramiko 3.使用pip下载并安装Ryu sudo pip install ryu 此步骤如果出现如下错误信息说明你被挡在城内了，富强上网即可解决。4.如果需要使用Ryu with GUI则进行此步骤：下载Ryu source code（需要使用git套件） sudo apt-get install git git clone https://github.com/osrg/ryu.git 5.完成安装，执行ryu-manager验证有没有出现错误，没问题的话会出现如下信息： 安装mininet使用源码安装mininet为了减少之后不必要的麻烦，建议在安装开始前执行：sudo su切换到root用户下并在富强网络下进行安装。1.升级系统 apt-get update apt-get upgrade 2.安装git（如果你像我一样在之前安装Ryu时我们已经安装过git了，那么请直接跳过此步骤） apt install git 3.从github上获取源码 git clone git://github.com/mininet/mininet 获取之后可以使用如下命令查看mininet的版本 cd mininet cat INSTALL 4.确认无误后，安装mininet util/install.sh -a 当你看到Enjoy Mininet！时，恭喜你已经安装成功了。执行以下命令查看安装版本： mn --version mininet可视化操作1.要进行mininet可视化操作，需要安装Xmanager套件，然后在通过Xshell远程连接主机时，在属性中做如下设置：2.然后进入examples目录，执行miniedit.py即可启动可视化界面 cd mininet/mininet/examples ./miniedit.py 至此，整个环境就搭建完成了。如果是桌面版系统并且用apt-get install mininet安装的mininet,目录在/usr / share /doc/mininet/examples,但是其可视化脚本是py.gz格式的，貌似无法使用。 如果对环境的安装有疑问，欢迎与我联系，一起沟通交流。 email: 666@cyne.cf]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>网工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenStack入门（三）—— OpenStack架构]]></title>
    <url>%2F2018%2F06%2F19%2FOpenStack%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-OpenStack%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[OpenStack架构OpenStack的Conceptual Architecture(概念体系结构)： 中间菱形是虚拟机，围绕 VM 的那些长方形代表 OpenStack 不同的模块（OpenStack 叫服务，后面都用服务这个术语），下面来分别介绍。 Nova：管理 VM 的生命周期，是 OpenStack 中最核心的服务。 Neutron：为 OpenStack 提供网络连接服务，负责创建和管理L2、L3 网络，为 VM 提供虚拟网络和物理网络连接。 Glance：管理 VM 的启动镜像，Nova 创建 VM 时将使用 Glance 提供的镜像。 Cinder：为 VM 提供块存储服务。Cinder 提供的每一个 Volume 在 VM 看来就是一块虚拟硬盘，一般用作数据盘。 Swift：提供对象存储服务。VM 可以通过 RESTful API 存放对象数据。作为可选的方案，Glance 可以将镜像存放在 Swift 中；Cinder 也可以将 Volume 备份到 Swift 中。 Keystone：为 OpenStack 的各种服务提供认证和权限管理服务。简单的说，OpenStack 上的每一个操作都必须通过 Keystone 的审核。 Ceilometer：提供 OpenStac k监控和计量服务，为报警、统计或计费提供数据。 Horizon：为 OpenStack 用户提供一个 Web 的自服务 Portal。 OpenStack的Logical Architecture（逻辑体系结构）： 搭建实验环境我们分两个节点进行环境部署：1.devstack-controller：控制节点 + 网络节点 + 块存储节点 + 计算节点2.devstack-compute：计算节点配置要求：网络规划：我们规划了三个网络： 1.Management Network： 用于 OpenStack 内部管理用，比如各服务之间通信。这里使用 eth0 2.VM（Tenant）Network： OpenStack 部署的虚拟机所使用的网络。OpenStack 支持多租户（Tenant），虚机是放在 Tenant 下的，所以叫 Tenant Network。这里使用 eth1 3.External Network： 一般来说，Tenant Network 是内部私有网络，只用于 VM 之间通信，与其他非 VM 网络是隔离的。这里我们规划了一个外部网络（External Network），通过 devstak-controller 的 eth2 连接。Neutron 通过 L3 服务让 VM 能够访问到 External Network。对于公有云，External Network 一般指的是 Internet。对于企业私有云，External Network 则可以是 Intranet 中的某个网络。 部署DevStack]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
        <tag>网工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenStack入门（二）—— 云计算]]></title>
    <url>%2F2018%2F06%2F19%2FOpenStack%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E4%BA%91%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[基本概念这张图很形象的描述了云计算的基本概念：云平台是一个面向服务的架构，按照提供服务的不同分为 IaaS、PaaS 和 SaaS。IaaS（Infrastructure as a Service）提供的服务是虚拟机。 IaaS 负责管理虚机的生命周期，包括创建、修改、备份、启停、销毁等。使用者从云平台得到的是一个已经安装好镜像（操作系统+其他预装软件）的虚拟机。使用者需要关心虚机的类型（OS）和配置（CPU、内存、磁盘），并且自己负责部署上层的中间件和应用。IaaS 的使用者通常是数据中心的系统管理员。典型的 IaaS 例子有 AWS、Rackspace、阿里云等。 PaaS（Platform as a Service）提供的服务是应用的运行环境和一系列中间件服务（比如数据库、消息队列等）。 使用者只需专注应用的开发，并将自己的应用和数据部署到PaaS环境中。PaaS负责保证这些服务的可用性和性能。PaaS的使用者通常是应用的开发人员。典型的 PaaS 有 Google App Engine、IBM BlueMix 等 SaaS（Software as a Service）提供的是应用服务。 使用者只需要登录并使用应用，无需关心应用使用什么技术实现，也不需要关系应用部署在哪里。SaaS的使用者通常是应用的最终用户。典型的 SaaS 有 Google Gmail、Salesforce 等 云计算和OpenStackOpenStack is a cloud operating system that controls large pools of compute, storage, and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface. 以上是官网对 OpenStack 的定义，OpenStack 对数据中心的计算、存储和网络资源进行统一管理。由此可见，OpenStack 针对的是 IT 基础设施，是 IaaS 这个层次的云操作系统。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
        <tag>网工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenStack入门（一）—— 虚拟化]]></title>
    <url>%2F2018%2F06%2F06%2FOpenStack%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E8%99%9A%E6%8B%9F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[作为一个网络工程专业的大二学生，现在已经临近期末，也就是说马上就要大三了。最近身边的一些事，让我慢慢发现，如果以后只做一个普通的网工，只会敲敲命令行之类的，几乎没有什么前景，而且随着SDN、自动化运维的发展，普通网工的价值也显得越来越低，所以还是觉得应该学点别的东西来武装自己，比如——虚拟化。 今天在知乎上看了一些大佬的解答，感觉很受启发，网工可能真的是一个轻松的工作，但一个人的工资总是与创造的价值成正比的。虽然知道OpenStack体系结构复杂，知识涉及面庞大，但还是决定接触一下。所以从今天开始就要入门OpenStack了，也但愿我可以一路坚持下去。 虚拟化 OpenStack是云操作系统，要学习OpenStack，首先需要掌握一些虚拟化和云计算的相关知识。 物理机为宿主机Host，虚拟机为客户机Guest宿主机通过Hypervisor程序实现硬件的虚拟化根据实现方式分为1型虚拟化和2型虚拟化 1型虚拟化Hypervisor 直接安装在物理机上，多个虚拟机在 Hypervisor 上运行。 2型虚拟化物理机上首先安装常规的操作系统，Hypervisor 作为 OS 上的一个程序模块运行，并对管理虚拟机进行管理。 KVM基本概念因为在 x86 平台上最热门运用最广泛的虚拟化方案莫过于 KVM同时OpenStack对KVM支持的最好，所以实验环境选择KVM。 KVM是2型虚拟化KVM有一个内核模块交kvm.ko，只用于广利虚拟cpu和内存IO如存储和网络的虚拟化由Linux内核和Qemu实现Libvirt简单的说就是KVM的管理工具 安装KVM因为手头没有可以用的Linux系统的主机，所以这里我选择在VMWare虚拟机安装KVM。为了能让 KVM 能创建 嵌套的虚机，要把 CPU 的虚拟化功能打开：Ubuntu启动后，用一下命令确认cpu支持虚拟化： # egrep -o &apos;(vmx|svm)&apos; /proc/cpuinfo # vmx 确认 Libvirtd 服务已经启动: # service libvirt-bin status libvirt-bin start/running, process 1478 到这里KVM准备就绪。 几个小问题我在安装环境的时候遇到了以下两个小问题： 1.未发现软件包解决方法很简单，在命令行下执行： sudo apt-get update 更新apt的资源列表即可解决 2.ssh无法启动这个主要是因为我安装的Ubuntu在安装时并没有安装ssh-server，执行： sudo apt-get install openssh-server 安装ssh服务端程序即可解决。 3.Ubuntu缺少管理员权限无法打开文件 这个问题也是我用Ubuntu感觉不太方便的地方，百度了以下可以安装这个： sudo apt-get install nautilus-open-terminal 重启后，打开想要打开的目录执行： sudo nautilus 启动第一个KVM虚拟机启动虚机环境搭好，这个步骤就很简单了。要做笔记的可能就是博主推荐的用来测试效果的超轻量级的Linux系统cirros了，镜像文件只有几十兆。这是我的第一个KVM——kvm1，截个图纪念一下：另外除了用virt-manager对虚机进行各种管理操作，也可以使用命令 virsh管理虚机，比如查看宿主机上的虚机： root@ubuntu:~# virsh list Id Name State -------------------------------- 8 kvm1 running 远程管理虚机virt-manager也可以管理其它宿主机上的虚机，只需要将其添加进来就可以进行远程管理。因为 KVM（准确说是 Libvirt）默认不接受远程管理，需要按下面的内容配置被管理宿主机中的两个文件：/etc/default/libvirt-bin start_libvirtd=”yes”libvirtd_opts=”-d -l” /etc/libvirt/libvirtd.conf listen_tls = 0listen_tcp = 1unix_sock_group = “libvirtd”unix_sock_ro_perms = “0777”unix_sock_rw_perms = “0770”auth_unix_ro = “none”auth_unix_rw = “none”auth_tcp = “none” 然后重启 Libvirtd 服务就可以远程管理了。 service libvirt-bin restart KVM虚拟化原理 cpu虚拟化虚机中的每一个虚拟 vCPU 则对应 qemu-kvm 进程中的一个线程。在这个例子中，宿主机有两个物理 CPU，上面起了两个虚机 VM1 和 VM2。VM1 有两个 vCPU，VM2 有 4 个 vCPU。可以看到 VM1 和 VM2 分别有两个和 4 个线程在两个物理 CPU 上调度。这里也演示了另一个知识点，即虚机的 vCPU 总数可以超过物理 CPU 数量，这个叫 CPU overcommit（超配）。KVM 允许 overcommit，这个特性使得虚机能够充分利用宿主机的 CPU 资源，但前提是在同一时刻，不是所有的虚机都满负荷运行。当然，如果每个虚机都很忙，反而会影响整体性能，所以在使用 overcommit 的时候，需要对虚机的负载情况有所了解，需要测试。 内存虚拟化KVM 通过内存虚拟化共享物理系统内存，动态分配给虚拟机。为了在一台机器上运行多个虚拟机，KVM 需要实现 VA（虚拟内存） -&gt; PA（物理内存） -&gt; MA（机器内存）直接的地址转换。虚机 OS 控制虚拟地址到客户内存物理地址的映射 （VA -&gt; PA），但是虚机 OS 不能直接访问实际机器内存，因此 KVM 需要负责映射客户物理内存到实际机器内存 （PA -&gt; MA）。内存也是可以 overcommit 的，即所有虚机的内存之和可以超过宿主机的物理内存。但使用时也需要充分测试，否则性能会受影响。 存储虚拟化KVM 的存储虚拟化是通过存储池（Storage Pool）和卷（Volume）来管理的。Storage Pool 是宿主机上可以看到的一片存储空间，可以是多种类型，后面会详细讨论。Volume 是在 Storage Pool 中划分出的一块空间，宿主机将 Volume 分配给虚拟机，Volume 在虚拟机中看到的就是一块硬盘。 目录类型的 Storage Pool文件目录是最常用的 Storage Pool 类型。KVM 将宿主机目录 /var/lib/libvirt/images/ 作为默认的 Storage Pool。那么 Volume 是什么呢？答案就是该目录下面的文件了，一个文件就是一个 Volume。 为虚机 kvm1 添加一个新的磁盘，看看有什么变化。在 virt-manager 中打开 kvm1 的配置页面，右键添加新硬件在默认 Pool 中创建一个 8G 的卷。然后发现在 /var/lib/libvirt/images/ 下多了一个 8G 的文件 kvm1.img 使用文件做 Volume 有很多优点：存储方便、移植性好、可复制、可远程访问。前面几个优点都很好理解，这里对“可远程访问”多解释一下。远程访问的意思是镜像文件不一定都放置到宿主机本地文件系统中，也可以存储在通过网络连接的远程文件系统，比如 NFS，或者是分布式文件系统中，比如 GlusterFS。这样镜像文件就可以在多个宿主机之间共享，便于虚机在不同宿主机之间做 Live Migration；如果是分布式文件系统，多副本的特性还可以保证镜像文件的高可用。KVM 支持多种 Volume 文件格式，在添加 Volume 时可以选择： raw 是默认格式，即原始磁盘镜像格式，移植性好，性能好，但大小固定，不能节省磁盘空间。qcow2 是推荐使用的格式，cow 表示 copy on write，能够节省磁盘空间，支持 AES 加密，支持 zlib 压缩，支持多快照，功能很多。vmdk 是 VMWare 的虚拟磁盘格式，也就是说 VMWare 虚机可以直接在 KVM上 运行。 LVM类型的Storage Pool宿主机上 VG 中的 LV 也可以作为虚拟磁盘分配给虚拟机使用。不过，LV 由于没有磁盘的 MBR 引导记录，不能作为虚拟机的启动盘，只能作为数据盘使用。补充几个概念： 逻辑卷管理器—–LVM（Logicl Volume Manager） 通过使用逻辑卷管理器对硬盘存储设备进行管理，可以实现硬盘空间的动态划分和调整。 物理卷—–PV（Physical Volume） 物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘。 卷组——–VG（Volumne Group） 卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。 逻辑卷—–LV（Logical Volume） 逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。 这种配置下，宿主机上的 VG 就是一个 Storage Pool，VG 中的 LV 就是 Volume。LV 的优点是有较好的性能；不足的地方是管理和移动性方面不如镜像文件，而且不能通过网络远程使用。 其他类型的Storage PoolKVM 还支持 iSCSI，Ceph 等多种类型的 Storage Pool。 网络虚拟化下面这个图是OpenStack官网给出的计算节点（可以理解为 KVM 的宿主机）虚拟网络的逻辑图： Linux Bridge基本概念给 VM1 分配一个虚拟网卡 vnet0，通过 Linux Bridge br0 将 eth0 和 vnet0 连接起来，如下图所示:Linux Bridge 是 Linux 上用来做 TCP/IP 二层协议交换的设备，其功能大家可以简单的理解为是一个二层交换机或者 Hub。多个网络设备可以连接到同一个 Linux Bridge，当某个设备收到数据包时，Linux Bridge 会将数据转发给其他设备。在上面这个例子中，当有数据到达 eth0 时，br0 会将数据转发给 vnet0，这样 VM1 就能接收到来自外网的数据；反过来，VM1 发送数据给 vnet0，br0 也会将数据转发到 eth0，从而实现了 VM1 与外网的通信。现在我们增加一个虚机 VM2，如下图所示:VM2 的虚拟网卡 vnet1 也连接到了 br0 上。现在 VM1 和 VM2 之间可以通信，同时 VM1 和 VM2 也都可以与外网通信。 动手实践虚拟网络配置Linux Bridge br0有两点需要注意： 1.之前宿主机的 IP 是通过 dhcp 配置在 eth0 上的；创建 Linux Bridge 之后，IP 就必须放到 br0 上了2.在 br0 的配置信息中请注意最后一行 “bridge_ports eth0”，其作用就是将 eth0 挂到 br0 上 小结配置过程很简单，有一个影响不大的小问题是我的interfaces文件不太一样，不过按照博主的配置，虽然写的多了一点，但不影响效果。最后附一张成功的截图，学习的乐趣也就在于这种满足感吧，哈哈。 理解virbr0 1.virbr0 是 KVM 默认创建的一个 Bridge，其作用是为连接其上的虚机网卡提供 NAT 访问外网的功能。2.virbr0 默认分配了一个IP 192.168.122.1，并为连接其上的其他虚拟网卡提供 DHCP 服务。3.使用 NAT 的虚机 VM1 可以访问外网，但外网无法直接访问 VM1。 VLANeth0 是宿主机上的物理网卡，有一个命名为 eth0.10 的子设备与之相连。eth0.10 就是 VLAN 设备了，其 VLAN ID 就是 VLAN 10。eth0.10 挂在命名为 brvlan10 的 Linux Bridge 上，虚机 VM1 的虚拟网卡 vent0 也挂在 brvlan10 上。 这样的配置其效果就是： 宿主机用软件实现了一个交换机（当然是虚拟的），上面定义了一个 VLAN10。eth0.10，brvlan10 和 vnet0 都分别接到 VLAN10 的 Access口上。而 eth0 就是一个 Trunk 口。VM1 通过 vnet0 发出来的数据包会被打上 VLAN10 的标签。 eth0.10 的作用是：定义了 VLAN10brvlan10 的作用是：Bridge 上的其他网络设备自动加入到 VLAN10 中 配置上图的实验环境后，测试KVM1和KVM2的连通性结果如下： Linux Bridge + VLAN = 虚拟交换机现在对 KVM 的网络虚拟化做个总结。 1.物理交换机存在多个 VLAN，每个 VLAN 拥有多个端口。同一 VLAN 端口之间可以交换转发，不同 VLAN 端口之间隔离。所以交换机其包含两层功能：交换与隔离。2.Linux 的 VLAN 设备实现的是隔离功能，但没有交换功能。一个 VLAN 母设备（比如 eth0）不能拥有两个相同 ID 的 VLAN 子设备，因此也就不可能出现数据交换情况。3.Linux Bridge 专门实现交换功能。将同一 VLAN 的子设备都挂载到一个 Bridge 上，设备之间就可以交换数据了。 总结起来，Linux Bridge 加 VLAN 在功能层面完整模拟现实世界里的二层交换机。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
        <tag>网工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于阿卡信自建聊天服务器]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%9F%BA%E4%BA%8E%E9%98%BF%E5%8D%A1%E4%BF%A1%E8%87%AA%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、安装JAVA和MAVEN环境这两个安装很简单，网上一大把的教程，因为我手头可用的只有一个Windows Server，所以这里只演示Win版的安装配置过程。 ①首先在ORACLE官网下载jre，然后直接运行安装就可以。②同样，在maven官网下载maven的压缩包，具体的安装配置过程可以参考CSDN博主的教程。③安装成功后，在cmd命令行分别用一下两条命令测试是否正确安装配置： java -versionmvn -v 二、安装Akaxin服务端程序在Github下载官方提供的jar包，并移动到C盘目录下，在cmd中首先切换到本目录：cd C:\ 然后直接运行jar包：java -jar openzaly-server.jar 然后看到提示就说明启动成功了。 三、安装客户端程序连接使用最后就是下载客户端程序了，在官网下载客户端程序后，输入服务器ip地址就可以正常使用了。这里需要注意的是，首个成员需要输入邀请码：000000进入，这样就会默认成为站点的管理员并提供管理权限。 四、问题我在配置完成之后遇到一个问题就是用客户端连接服务器的时候提示：请稍后重试，解决的办法是在服务器的安全组策略中放行：2021/2021端口。 附阿卡信官网：https://www.akaxin.com/Github项目：https://github.com/akaxincom/openzaly码云：https://gitee.com/akaxin/openzalyQQ群：655249600]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>聊天服务器</tag>
        <tag>阿卡信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专治疑难杂症]]></title>
    <url>%2F2018%2F05%2F30%2F%E4%B8%93%E6%B2%BB%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
    <content type="text"><![CDATA[添加开机启动项因为电脑装了某管家，不知道哪天自己把我的开机启动项给关了，只能手动添加回去，之前用的计划任务并不好用，今天知道了一个简单办法。Windows有专门的启动目录，只要把想要开机启动的应用的快捷方式复制进去就可以了。开机启动目录： C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 当然，有可能你根本找不到这个路径，只要把以上地址复制到地址栏，回车访问即可。]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建ssr服务器]]></title>
    <url>%2F2018%2F05%2F07%2F%E8%87%AA%E5%BB%BAssr%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[VPS购买昨天晚上看见了一个便宜的VPS没怎么想就买了，毕竟3.5刀一年，虽然平时对富强上网需求不是特别大，但是想借着这个便宜主机了解一下SSR的搭建使用，所以这点钱花的还是很值的我自己觉得。当然便宜也就意味着配置不会好了，96M内存，不过做SSR足够了。 SSR安装部署在这之前就有过搭建SSR的想法，所以当时找了一个比较不错的教程，写的比较详细，毕竟搭建SSR还是比较傻瓜的，没什么难度，按照提示写参数就行，教程地址：点这里。唯一的一个遗憾就是我买的这个VPS不支持教程里说的谷歌BBR加速，而且不知道是不是因为这个原因，我做出来的这个SSR延迟还是比较高的。如图：当然，网速还是不太稳定的，下午测试的时候是1M左右，晚上就到6.9M了，不过这也都无所谓了。 SSR客户端最后附上Win和Android端的客户端 Windows：下载地址Android：下载地址]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门]]></title>
    <url>%2F2018%2F04%2F10%2FPython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux入门笔记]]></title>
    <url>%2F2018%2F04%2F10%2FLinux%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[VIM保存退出 按ESC键 跳到命令模式，然后： :w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出vi_q:_ 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑 RPM:packge manager,通过将软件源代码和安装规则打包，从而降低软件安装难度。YUM仓库:保存有大量常用的软件程序包，当用户需要的时候自动下载并按照依赖关系进行安装。 本地:file://网站:http://文件服务器:ftp:// systemctl restart+服务名称 重启systemctl stop+服务名称 停止服务systemctl start+服务名称 开启systemctl status+服务名称 查看状态systemctl enable+服务名称 加入到启动项 Linux命令常用的系统工作命令echo命令用于在终端输出字符串或变量提取后的值，格式为“echo[字符串|$变量]”。 date命令格式为“date[选项][+指定的格式]”。 %Y #年 %m #月 %d #天 %H #小时 %M #分钟 %S #秒 %j #今年中的第几天 poweroffpoweroff命令与shutdown等命令作用相同。 wget用于在终端中下载网络文件，格式为“wget[参数]下载地址”。 -P #下载到指定目录 -p #下载页面所有资源，包括图片、视频等 -b #后台下载模式 -t #最大尝试次数 -c #断点续传 ps用于查看系统中的进程状态，格式为“ps[参数]”。 -a #显示所有进程（包括其他用户的进程） -u #用户以及其它详细信息 -x #显示没有控制终端的进程 5种常见的进程状态： R(运行):进程正在运行或在运行队列中等待。 S(中断):进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。 D(不可中端):不响应系统异步信号，即便用kill命令也无法中断。 Z(僵死):进程已经终止，但描述符依然存在，依然占用系统资源。 T(停止):收到停止信号后停止运行。 top用于动态地监视进程活动与系统负载等信息，类似Windows中的任务管理器。第一行：系统时间、运行时间、登录终端数、系统负载（三个数值分别表示1、5、15分钟内的平均值）第二行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。第三行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比。第四行：物理内存总量、内存空闲量、内存使用量、作为内存缓存的内存量。第五行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量。 pidof查询某个指定服务进程的PID值。 kill &amp; killallkill：终止某个指定PID的服务进程。killall：终止某个指定名称的服务做对应的全部进程。在命令后加上一个&amp;符号，命令将进入后天执行。 系统状态检测命令uname用于查看系统内核和系统版本等信息，通常使用uname -a。 uptime用于查看系统的负载信息，显示系统时间、已运行时间、启用终端数以及平均负载等信息。 平均负载指的是最近1、5、15分钟内的压力情况；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。 free显示当前系统中内存使用量信息，常用参数为“free -h”。 who查看登入主机的用户终端信息。 last查看所有本机的登录记录。 history显示执行过的命令，默认能显示出当前用户执行过的最近1000条命令，自定义记录数量可修改/etc/profile中的HISTSIZE的值，记录保存在家目录(~)中的“.bash_history”文件中。清空当前用户的历史记录： history -c sosreport手机系统配置及架构信息并输出诊断文档。 工作目录切换命令pwd显示用户当先所处的工作目录。 cd cd - #返回上一次所处的目录 cd .. #进入上级目录 cd ~username #切换到其他用户的家目录 ls ls -l #查看文件的属性、大小等详细信息 ls -ld #查看目录属性信息 文本文件编辑命令cat cat -n #显示行号 more查看内容较多的纯文本文件，可使用空格或回车键翻页。 head查看纯文本文档的前N行，例如： head -n 6 .bash_profile #查看前6行 tail查看纯文本文档的后N行或持续刷新内容。例如： tail -n 6 .bash_profile 还有一种情况是持续刷新一个文件的内容，比如日志文件: tail -f /var/log/message tr用于替换文本文件中的字符。 cat anaconda-ks.cfg | tr [a-z] [A-Z] #将文件中的小写替换为大写。 wc统计指定文本的行数、字数、字节数。 -l #只显示行数 -w #只显示单词数 -c #只显示字节数 stat查看文件的具体存储信息和时间等信息。 cut按列提取文本字符，用-f参数设置需要看的列数，用-d参数设置间隔符号。例如： [root@localhost etc]# head -n 3 passwd #查看前三行 root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin [root@localhost etc]# cut -d: -f1 passwd #查看以“：”为间隔符的第一列内容 root bin daemon adm ...... diff用于比较多个文件的差异。 diff diff a1.txt a2.txt #找出文件内容中的具体不同 diff --brief a1.txt a2.txt #直接输出结果判断结果 diff -c a1.txt a2.txt #描述文件具体的不同 文件目录管理命令打包压缩与搜索命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的str.format]]></title>
    <url>%2F2018%2F03%2F25%2FPython%E4%B8%AD%E7%9A%84str-format%2F</url>
    <content type="text"><![CDATA[str.format 的引入在 Python 中，我们可以使用 + 来连接字符串，在简单情况下这种方式能够很好的工作。但是当我们需要进行复杂的字符串连接时，如果依然使用 + 来完成，不仅会使代码变得晦涩难懂，还会让代码变得难以维护，此时这种方式就显得力不从心了。例如，我们想打印这样一条记录： User:John has completed Action:payment at Time:13:30:00 如果使用加号实现，会是下面这种形式： print &quot;User:&quot; + user_name + &quot; has completed Action:&quot; + \ action_name + &quot; at Time:&quot; + current_time 如果以后回过头来阅读这段代码，我们很难直观看出它的输出格式，且修改起来也相对麻烦。我们可以换用 % 来实现： print &quot;User:%s has completed Action:%s at Time:%s&quot; %\ (user_name, action_name, current_time) 这回代码变得清晰简洁多了。不过，Python 为我们提供了另一种简洁优雅的实现方式，也是官方更加推荐的方式：&nbsp;&nbsp;&nbsp;&nbsp;使用 str.format() 来实现字符串的格式化： print &quot;User:{} has completed Action:{} at Time:{}&quot;.format( user_name, action_name, current_time) str.format 既能够用于简单的场景，也能够胜任复杂的字符串替换，而无需繁琐的字符串连接操作。Python 的内置类型 str 和 unicode 均支持使用 str.format() 来格式化字符串。我们接下来就详细地讨论 str.format() 的具体用法。 str.format 基本语法格式化字符串使用花括号 {} 来包围替换字段，也就是待替换的字符串。而未被花括号包围的字符会原封不动地出现在结果中。 使用位置索引以下两种写法是等价的：“Hello, {} and {}!”.format(“John”, “Mary”)“Hello, {0} and {1}!”.format(“John”, “Mary”)花括号内部可以写上目标字符串的索引，也可以省略。如果省略，则按 format 括号里的目标字符串顺序依次替换。 使用关键字索引除了通过位置来指定目标字符串，我们还可以通过关键字来指定它。例如： “Hello, {boy} and {girl}!”.format(boy=”John”, girl=”Mary”) 使用关键字索引的好处是，我们无需关心参数的位置，且字符串的最终结果能够一目了然。在以后的代码维护中，我们能够快速地修改对应的参数，而不用对照字符串挨个去寻找相应的参数。注意：如果字符串本身含有花括号，则需要将其重复两次来转义。例如，字符串本身含有 &#123; ，为了让 Python 知道这是一个普通字符，而不是用于包围替换字段的花括号，我们只需将它改写成 &#123;&#123; 即可。 str.format 高级语法str.format 非常强大，足以完成日常工作中遇到的格式化输出。熟练掌握该方法，能够为以后的字符串处理打好基础，还能节省不少时间。 访问参数的属性或元素在使用 str.format 来格式化字符串时，我们通常将目标字符串作为参数传递给 format 方法。实际上，我们还可以在格式化字符串中访问参数的某个属性或某个元素： &quot;My car is {0.color}.&quot;.format(black_car) &quot;The first student is {student[0]}.&quot;.format(student=stu_list) &quot;John is {d[john]} years old.&quot;.format(d=age_dict) 参数输出转换参数的字符串输出，默认是由其自身的 format 方法来实现的。也就是说Python 使用参数的 format 输出来取代替换字段。如果我们想调用 str() 或 repr() 来转换参数，可以通过添加转换标志来实现： call str() on argument &quot;It&apos;s a {0!s}.&quot; call repr() on argument &quot;We can get info from {name!r}.&quot; str.format 一般形式格式化字符串的一般形式如下： &quot;... {field_name!conversion:format_spec} ...&quot; 从上面的代码可以看到，格式化字符串可分为 field_name、conversion、format_spec 三部分，分别对应替换字段名称（索引）、转换标志、格式描述。其中，字段名称是必选的，而后两者是可选的。转换标志紧跟在英文感叹号后面，而格式描述紧跟在英文冒号后面。前面已经提到过，字段名称既可是位置索引，也可是关键字索引。字段名称后面可以通过点来访问属性，或通过方括号来访问元素。在这里，我们重点看一下格式描述（format_spec）这一项。格式描述中含有6个选项，分别是 fill、align、sign、width、precision、type。 它们的位置关系如下： [[fill]align][sign][#][0][width][,][.precision][type] fill 可以是任意字符，默认为空格。align 仅当指定最小宽度时有效。&lt; 左对齐（默认选项）“&gt;” 右对齐= 仅对数字有效；将填充字符放到符号与数字间，例如 +0001234^ 居中对齐sign仅对数字有效 所有数字均带有符号 仅负数带有符号（默认选项）&nbsp;即空格；正数前面带空格，负数前面带符号‘#’ 只对整数有效自动在二进制、八进制、十六进制数值前添加对应的 0b、0o、 0x。‘,’自动在每三个数字之间添加 , 分隔符。width十进制数字，定义最小宽度。如果未指定，则由内容的宽度来决定。如果没有指定对齐方式（align），那么可以在 width 前面添加一个0来实现自动填充0，等价于 fill 设为 0 并且 align 设为 =。precision用于确定浮点数的精度，或字符串的最大长度。不可用于整型数值。type确定参数类型，默认为 s ，即字符串。整数输出类型： b：以二进制格式输出c：将整数转换成对应的 unicode 字符d：以十进制输出（默认选项）o：以八进制输出x：以十六进制小写输出X：以十六进制大写输出n：与 d 相同，但使用当前环境的分隔符来分隔每3位数字十进制浮点数输出类型：e：指数标记；使用科学计数法输出，用e来表示指数部分，默认 precision 为6E：与 e 相同，但使用大写 E 来表示指数部分f：以定点形式输出数值，默认 precision 为6F：与 f 相同g：通用格式；对于给定的 precision p &gt;= 1，取数值的p位有效数字，并以定点或科学计数法输出（默认选项）G：通用格式；与 g 相同，当数值过大时使用 E 来表示指数部分n：与 g 相同，但使用当前环境的分隔符来分隔每3位数字%：百分比标记；使用百分比的形式输出数值，同时设定 f 标记]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo建站记录]]></title>
    <url>%2F2018%2F03%2F03%2Fhexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[建站过程在遇到各种各样问题之后，终于搭建完成了这个博客。 其实回过头看看也并不是很麻烦，只是遇到了许多问题，有些是因为设备环境的问题，比如在测试“ssh -T git@github.com“这条命令时，一直提示”bad address“错误，让人很费解，重装环境重新来过还是报错，只好最后换了一台电脑就没有出现这个错误。当然经验证这个并不会影响整个博客的搭建，只要密钥复制的正确这些都不碍事。 还有一个问题是因为教程的问题，在修改主配置文件的“deploy”部署时，教程写的是https地址，我也是多次尝试也没成功，最后百度到原因写ssh地址就可以解决。当然也不能一概而论，若没有错误还是推荐使用https地址。 一个个的小地方就让我走了不少的弯路。最后终于找到一个比较详细准确的教程，在此分享给大家，在这也感谢作者Line, 无意侵犯作者原作，只是想让像我这样的小白少走些弯路。作者博客中有五篇关于hexo使用的教程，个人觉得比较适合小白看。 这就是这次建站的一些小心得，水平有限有什么说的不对的地方也感谢各位不吝赐教。 后期添加：添加网易云音乐插件 在别人的博客看到了这样一个音乐插件，实现很简单，打开网易云音乐网页版，选择自己想要分享的歌单，然后点击生成外链播放器即可，插件分为两种形式：iframe插件和flash插件，可根据情况选择。 添加particles.js背景动画 particles.js是一个粒子效果的js插件，在Github里可以找到这个项目的源码，但是百度了一下配置方法大多是在html中实现，反正我是小白，不知道怎么修改。回归正题，怎么在Hexo中实现particles.js效果呢？1.首先在\themes\next\layout\_layout.swig的&lt; /body &gt;标签上面添加 {% if theme.canvas_nest %} {% endif %} 2.在\themes\next\_config.yml中添加以下字段开启此功能： # background settings # add canvas-nest effect # see detail from https://github.com/hustcc/canvas-nest.js canvas_nest: true 3.这样动态效果就添加成功了，你会发现博客默认的白色背景遮挡了大部分区域使得只有边缘能看见动态效果，这时候只要修改一下背景颜色即可。在\themes\next\source\css\_schemes\Pisces_layout.styl中，把.content-wrap中的background修改为none，注意我这里使用的是Pisces主题，如果你使用的是别的主题，在相应路径下修改即可。这样如果用手机打开体验会比较差，我们单独设置一下手机，把.content-wrap的+mobile()中的background修改为white，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。 设置文章摘要 写出来的文章如果直接在首页全篇显示就比较别扭了，为了提高浏览体验，这时候就需要设置一下文章摘要了，我这里主要介绍三种方式。 1.在文章中使用&lt; !–more–&gt; 这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。 2.在文章中的front-matter中添加description，并提供文章摘录。如图： 3.在主题配置文件中设置自动摘要 auto_excerpt: enable: true length: 150 #默认摘要为150字，可根据需要更改 needmoreshare2分享按钮今天才知道jiathis已经于2018年4月30日关闭了旗下的分享业务，所以今天改成了needmoreshare2，在nest的配置文件中预先已经加入了此功能，只需要简单的启用修改一下就可以用了。 postbottom:文章底部分享按钮float:浮动按钮iconStyle:按钮的样式 default:box: 鼠标点击特效打开网址： http://7u2ss1.com1.z0.glb.clouddn.com/love.js 复制网址中的代码，在/themes/next/source/js/src路径下，新建love.js并将刚刚复制的代码复制进去。然后编辑\themes\next\layout_layout.swig文件，在末尾加上如下代码： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 如图： 修改文章底部标签符号默认的标签符号是一个“#”，个人觉得并不是很好看，所以决定修改一下。修改模板/themes/next/layout/_macro/post.swig，搜索rel=”tag”&gt;#，将 # 换成，注意是只替换“#”。 侧边栏旋转头像首先先把头像打开，在主题配置文件中，将如下图中的avatar前的#去掉，然后将自己的头像放到themes\next\source\images路径下，并将配置文件中默认的avatar.gif修改为头像的文件名。然后就是设置头像旋转了，打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 底部全站字数统计如图：在根目录下，执行： $ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig末尾加上： &lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共{{ totalcount(site) }}字&lt;/span&gt; &lt;/div&gt; 文章字数统计刚才设置了全站的总字数统计，接下来设置一下单篇文章的字数统计，如图：首先在根目录下安装hexo-wordcount,执行： $ npm install hexo-wordcount --save 然后在主题配置文件中，将post_wordcount的选项改为true： 网站顶部加载进度条在主题配置文件中，搜索pace，改为true启用功能：有多种表示加载进度的样式，可根据自己喜好选择。 添加来必力评论系统新建这个博客的时候我用的是gitment，但是使用效果并不是很理想，今天开始使用来必力了，但愿这个能命久一点。首先到https://livere.com/insight/myCode注册并获取安装代码，在代码里找到自己的id，也就是下图中这个位置：然后在主题配置中找到livere_uid，将你的id复制上就ok了： 官方文档： 文档|HexoNexT 错误汇总在使用hexo博客的过程中，遇到了如下一些错误： &#123; &#125;引起的报错今天写了一篇博客后按流程进行部署的时候，发现在生成静态页面的时候出现了如下的错误： 查了一下说什么的都有，每个方法也都试了一遍，最后发现是因为文章中直接引用了”&#123; &#125;”的原因，解决办法是将”&#123; &#125;”通过&amp;#123 &amp;#125后面加上分号”;”进行转换，就可以正常部署了。这里也有一些常见的特殊字符,可以根据需要转换。 标题无法正常解析在浏览别人的博客的时候发现Hexo有自动解析目录的功能，是依靠markdown的标题实现的，在加了一个“#标题”这样时却发现博客无法解析到这是一个标题，查了一下原因是正规的标题写法是在”#”和标题之间加一个空格。 换行一开始刚刚接触markdown的时候一直用html的&#60;br/&#62;换行，这种换行方式貌似在换行的同时增加了行间距，无意间发现一个更好也更简单的换行方式，就是在要换行的位置敲两个空格，就可以换行。 FATAL Cannot read property ‘replace’ of null今天在修改站点配置文件进行操作时报出“FATAL Cannot read property ‘replace’ of null”的错误：上网查了一下原因是url地址不能为空，按照注释要求改为相应地址即可。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
