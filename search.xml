<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2.OVSDB的网桥和端口管理</title>
    <url>/2018/09/13/2-OVSDB%E7%9A%84%E7%BD%91%E6%A1%A5%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFlow和OVSDB两种南向协议方式与Open vSwitch交换机进行交互，其中通过OpenFlow来引导数据包流的转发，通过OVSDB可以进行端口和隧道的增加、更新以及删除，这些隧道和端口提供流转发的管道。因此，OVSDB在Open vSwitch作为一个重要的事实标准，OpenDaylight系统如何高效地支持OVSDB也变得非常重要。OpenDaylight的OVSDB子项目实现了OVSDB管理协议，该协议允许控制器进行虚拟交换机的南向配置。OVSDB协议包含一个OVSDB库和各种插件用法，该协议使用JSON/RPC调用的方式来操作内置OVSDB的物理或虚拟交换机。<br>OVSDB子项目主要包含Northbound模块、plugin模块和OVSDB Library模块，其中北向Northbound模块可供外部APP调用，南向OVSDB Library通过OVSDB协议与外部通信，进行OVSDB的管理，具体系统架构如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a10f6d7c34.png" alt="1.png"><br>Library模块主要包含message、notation、impl、jsonrpc和schema等程序包,其中jsonrpc主要提供兼容rpc1.0的解码器，能够从TCP流解码JSON消息；notation主要包含OVSDB MAP、ResultSet等定义以及Json串行化；schema提供OVSDB数据库模式的表示。</p>
<p>Plugin模块主要包含api、impl、internal和error等程序包，其中api程序包主要提供OVSDB的连接、增删改查等服务，impl包中的类是其接口的实现。  </p>
<p>Northbound模块主要包含五大类,分别是DatabaseResource、NodeResource、OvsdbNorthboundV2、OvsdbNorthboundV3、RowResource、TableResource。以类OvsdbNorthboundV2为例进行说明，该类提供OVSDB北向 REST API接口，用于创建、读取、更新和删除任一OVSDB表中的记录。创建OVSDB Row时，body请求体中的JSON格式与OVSDB JSON-PRC消息相同。northbound及其功能描述如下表所示。<br><img src="https://i.loli.net/2018/09/13/5b9a123b86027.png" alt="2.png"><br>用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。而Postman不仅可以调试简单的css、html、脚本等简单的网页基本信息，还可以发送GET、POST、PUT、DENLETE等几乎所有类型的HTTP请求。Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p>
<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9b47e2af14d.png" alt="拓扑.png"></p>
<h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录OpenDaylight控制器，确保服务已经启动成功，由于OpenDaylight组件过于庞大，所以启动比较慢，需等待一段时间，使用命令：</p>
<blockquote>
</blockquote>
<pre><code>netstat -an|grep 6633 #netstat -an:查看端口对应的应用
</code></pre><p>查看端口是否处于监听状态：<br><img src="https://i.loli.net/2018/09/14/5b9b46db45a61.png" alt="3.png"><br>步骤2 在保证控制6633端口处于监听状态后，登录交换机，查看交换机与控制器连接情况。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9b4746ca6a9.png" alt="4.png"><br>上图中controller下方显示“is_connected:true”则表明连接成功。<br>步骤3 登录控制器，查看控制器IP，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4798e189e.png" alt="5.png"><br>步骤4 登录交换机，连接控制器。原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。执行如下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640
</code></pre><p>连接成功后在manager下面会有“is_conneted:true”：<br><img src="https://i.loli.net/2018/09/14/5b9b47e2a28df.png" alt="6.png"></p>
<h1 id="创建网桥"><a href="#创建网桥" class="headerlink" title="创建网桥"></a>创建网桥</h1><p>步骤1 登录控制器，单击Applications Menu—&gt;Development—&gt;Postman打开Postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4e42b73f7.png" alt="7.png"><br>步骤2 在创建网桥前，需要先获取交换机节点信息，输入URL <strong>http://[controller ip]:8282/ovsdb/nb/v3/node</strong>。  </p>
<p>请求类型选择GET，单击Send按钮发送GET请求。访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择Basic Auth。输入用户名和密码，用户名和密码都是admin。Body中返回的就是交换机节点信息，此处获取到的节点信息在后面会用到，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4ebbb7028.png" alt="8.png"><br>步骤3 发送POST请求创建网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”</a>  </p>
<p>就是前面获取到的交换机节点信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba28a8e540.png" alt="9.png"><br>单击Headers，输入用户名和密码生成HTTP认证头部，POST请求还需要添加头部指明Body格式，如图所示，手动输入Content-Type且值为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba3126bc5f.png" alt="10.png"><br>步骤4 单击Body，Body格式选择raw—&gt;JSON(application/json)。Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。  </p>
<p>Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。单击Send按钮发送请求。</p>
<blockquote>
</blockquote>
<pre><code>{
   &quot;row&quot;: {
    &quot;Bridge&quot;: {
      &quot;name&quot;: &quot;br0&quot;,
        &quot;datapath_type&quot;: &quot;OpenFlow13&quot;
        }
    }
}
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba36f496f1.png" alt="11.png"><br>步骤5 登录交换机，确认网桥创建成功。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba3d7290b1.png" alt="12.png"></p>
<h1 id="获取网桥uuid"><a href="#获取网桥uuid" class="headerlink" title="获取网桥uuid"></a>获取网桥uuid</h1><p>步骤1 URL保持不变，依旧是<a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows</a> ，将请求类型改为GET。输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba676a461c.png" alt="13.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并返回网桥信息，下图中两个uuid分别是br0和br-sw的。单击uuid所在行左侧的数字可以展开/收起网桥的详细信息，方便查看，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6a5aefc1.png" alt="14.png"></p>
<h1 id="创建端口"><a href="#创建端口" class="headerlink" title="创建端口"></a>创建端口</h1><p>步骤1 发送POST请求创建端口，输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。</a><br>单击Basic Auth，输入用户名和密码生成HTTP认证头部，并且添加Content-Type为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6e473f28.png" alt="15.png"><br>步骤2 将请求类型改为POST，输入Body内容如下所示，其中parent_uuid是网桥的uuid，这里所用的是br0的uuid，那么端口就会添加到br0网桥上。</p>
<blockquote>
</blockquote>
<pre><code>{
   &quot;parent_uuid&quot;: &quot;2dd82e5e-922d-43c8-80d9-7917161acfd2&quot;,
    &quot;row&quot;: {
      &quot;Port&quot;: {
        &quot;name&quot;: &quot;port0&quot;  
        }
    }
}
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba72ac6722.png" alt="16.png"><br>单击Send按钮发送请求，STATUS显示请求发送成功，端口已经创建，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba762e1b34.png" alt="17.png"><br>步骤3 登录交换机，确认交换机端口是否创建成功。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba79b19c6c.png" alt="18.png"></p>
<h1 id="获取端口uuid"><a href="#获取端口uuid" class="headerlink" title="获取端口uuid"></a>获取端口uuid</h1><p>步骤1 发送GET请求获取端口的uuid。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows</a> 。在Basic Auth页面输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7d5c4665.png" alt="19.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并且展示出获取到的端口信息。因为获取的是所有网桥的端口所以比较多，如下图所示，标注出来的是port0的uuid。获取到的信息完全展开比较多，可以直接在页面中搜索端口名称“port0”，然后往上翻找该端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7feaebe3.png" alt="20.png"></p>
<h1 id="删除端口"><a href="#删除端口" class="headerlink" title="删除端口"></a>删除端口</h1><p>步骤1 发送DELETE请求删除端口。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8</a> ”就是port0端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8431f4b2.png" alt="21.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8655ebe0.png" alt="22.png"><br>步骤3 登录交换机，确认port0端口删除成功。</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba89fe7601.png" alt="23.png"></p>
<h1 id="删除网桥"><a href="#删除网桥" class="headerlink" title="删除网桥"></a>删除网桥</h1><p>步骤1 发送DELETE请求删除网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”</a> 就是br0网桥的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8ddef7ab.png" alt="24.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba9024cca5.png" alt="25.png"><br>步骤3 登录交换机，确认网桥br0删除成功。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba934ab15e.png" alt="26.png"></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Open vSwitch流表管理</title>
    <url>/2018/09/14/3-Open-vSwitch%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议去连接Open vSwitch，创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。  </p>
<p>在OpenFlow的白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或者多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。  </p>
<p>当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。<br>在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或者空格分开。一些常用的字段列举如下：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd40468.png" alt="1.png"><br>ovs-ofctl关于流表管理的常用命令：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd3a959.png" alt="2.png"><br>对于add−flow，add−flows和mod−flows这三个命令，还需要指定要执行的动作：actions=[target][,target…]，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br>常见的操作有：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd4cb85.png" alt="3.png"></p>
<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9bb4dd4d9be.png" alt="拓扑.png"></p>
<h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，执行以下命令，查看镜像中原有的网桥，如下图所示。</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbf7b25c05.png" alt="4.png"><br>步骤5 执行以下命令，删除当前网桥，并进行确认，如下图所示。</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl del-br br-sw
ovs-vsctl show
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbfb869e58.png" alt="5.png"></p>
<h1 id="流表管理"><a href="#流表管理" class="headerlink" title="流表管理"></a>流表管理</h1><p>步骤1 执行以下命令，添加网桥，并查看虚拟交换机的基本信息，如下图所示。</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl add-br br0
ovs-ofctl show br0
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbffd27c45.png" alt="6.png"><br>由上图可知，可以查看到交换机dpid、流表数量、性能参数、动作参数、MAC地址等信息。  </p>
<p>步骤2 执行以下命令，查看虚拟交换机上各端口的状态，如下图所示。</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl dump-flows br0
</code></pre><p>由上图可知，输出的结果中包含了各端口上收到的数据包数，字节数，丢包数，错误数据包数等。  </p>
<p>步骤3 执行以下命令，添加一条流表项，设置流表项生命周期为1000s，优先级为17，入端口为3，动作是output:2。</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl add-flow br0 idle_timeout=1000,priority=17,in_port=3,actions=output:2
说明：这条流表项的作用是将端口3接收到的数据包从端口2输出。
</code></pre><p>步骤4 执行以下命令，查看交换机上所有流表信息，如下图所示。</p>
<blockquote>
<pre><code>ovs-ofctl dump-flows br0
</code></pre></blockquote>
<p>步骤5 执行以下命令，删除入端口为3的的流表项，删除后，再次查看流表信息，如下图所示。</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl del-flows br0 in_port=3
ovs-ofctl dump-flows br0
</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bc08844d29.png" alt="7.png"></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>6.使用OpenDaylight界面下发流表</title>
    <url>/2018/09/16/6-%E4%BD%BF%E7%94%A8OpenDaylight%E7%95%8C%E9%9D%A2%E4%B8%8B%E5%8F%91%E6%B5%81%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>YANG UI是OpenDaylight中一款基于DLUX的应用，旨在简化、激励应用的开发与测试。YANG UI通过动态封装、调用YANG模型和相关REST APIs，生成并展示一个简单的UI界面。开发人员可以通过API请求获取交换机信息，并且以JSON格式展示。YANG UI主要面向上层应用开发，为应用开发人员提供了很多相关工具，有效的节约了开发人员的时间。  </p>
<p>OpenFlow1.0协议处理数据包的流程相对简单，因为1.0版本只支持单流表。交换机接收到数据包后解析数据包，数据包解析后就开始匹配，从table 0 开始匹配，如果匹配成功则对该数据包执行相应的动作，更新相应的计数器。如果没有找到匹配项则将数据包交给控制器。  </p>
<p>OpenFlow1.3协议支持多流表匹配，即一个交换机只会有多个流表，因此数据包处理过程相对复杂。首先解析进入设备的报文，然后从table 0开始匹配，按照优先级高低依次匹配该流表中的流表项，一个报文在一个流表中只会匹配上一条流表项。通常根据报文的类型，报文头的字段例如源MAC地址、目的MAC地址、源IP地址、目的IP地址等进行匹配，大部分匹配还支持掩码进行更精确、灵活的匹配。也可以通过报文的入端口或元数据信息来进行报文的匹配，一个流表项中可以同时存在多个匹配项，一个报文需要同时匹配流表项中所有匹配项才能匹配该流表项。报文匹配按照现有的报文字段进行，比如前一个流表通过apply actions改变了该报文的某个字段，则下一个表项按修改后的字段进行匹配。如果匹配成功，则按照指令集里的动作更新动作集，或更新报文/匹配集字段，或更新元数据和计数器。根据指令是否继续前往下一个流表，不继续则终止匹配流程执行动作集，如果指令要求继续前往下一个流表则继续匹配，下一个流表的ID需要比当前流表ID大。当报文匹配失败了，如果存在无匹配流表项（table miss）就按照该表项执行指令，一般是将报文转发给控制器、丢弃或转发给其他流表。如果没有table miss表项则默认丢弃该报文。  </p>
<p>在Open vSwitch中，流表项作为ovs-ofctl的参数，采用“字段=值”的格式。如果有多个字段，可以用逗号分开，一些常见字段如下：<br><img src="https://i.loli.net/2018/09/16/5b9e4929f0d63.png" alt="1.png"></p>
<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/16/5b9e494803043.png" alt="拓扑.png"></p>
<h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>登录交换机，检查网络连通性。当显示“is_connected：ture”时，表示交换机与控制器连接成功，可以正常进行实验。若不显示“is_connected：ture”时，表示交换机与控制器连接不成功，执行:</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl del-controller br-sw
ovs-vsctl set-controller br-sw tcp:30.0.1.3:6633 
</code></pre><p>命令手动重连，稍等一会后，重新查看连接状态。</p>
<h1 id="基于OpenFlow1-0协议下发流表"><a href="#基于OpenFlow1-0协议下发流表" class="headerlink" title="基于OpenFlow1.0协议下发流表"></a>基于OpenFlow1.0协议下发流表</h1><p>步骤1 切换到交换机，执行以下命令设置OpenFlow协议版本为1.0。  </p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow10
</code></pre><p>步骤2 选择控制器，单击浏览器图标，打开浏览器。  </p>
<p>步骤3 访问OpenDaylight Web页面，url是<a href="http://127.0.0.1:8080/index.html" target="_blank" rel="noopener">http://127.0.0.1:8080/index.html</a> ，用户名和密码是admin/admin，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a2625fb7.png" alt="2.png"><br>步骤4 单击左侧的“Nodes”查看节点信息。其中尤其需要关注Node Id，下发流表的时候会用到Node Id，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a653f1bb.png" alt="3.png"><br>步骤5 单击上图中的“Node Connectors”列的数据即“9”，可以查看具体节点连接信息，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4ac29c305.png" alt="4.png"><br>步骤6 选择左侧的“Yang UI”，单击“Expand all”展开所有目录，查看各种模块，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4af0e3b80.png" alt="5.png"><br>步骤7 展开“opendaylight-inventory rev.2013-08-19”，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b115e5c9.png" alt="6.png"><br>步骤8 补全node id、table id和flow id的值。  </p>
<p>其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.0协议只支持单流表，所以这里的table id设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b3798ac7.png" alt="7.png"><br>步骤9 单击flow list后面的“+”，展开流表相关的参数。填写第一个框id，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b59027ad.png" alt="8.png"><br>步骤10 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为“0x0800”(说明：由于使用IP地址进行匹配，所以需要设置以太网协议类型。),如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b789668c.png" alt="9.png"><br>步骤11 填写匹配参数，在“layer-3-match”后面的下拉框中选择“ipv4-match”，使用IP匹配。  </p>
<p>步骤12 展开“layer-3-match”，填写源IP地址和目的IP地址，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bc1b5579.png" alt="10.png"><br>其中源地址填写主机1的IP地址，目的地址填写主机2的IP地址。  </p>
<p>步骤13 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bec99e16.png" alt="11.png"><br>步骤14 展开“apply-actions”，单击“action list”后面的“+”，在action后面的下拉框中选择“drop-action-case”，action order和instruction order都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c0f7a101.png" alt="12.png"><br>步骤15 设置“priority”为27，“idle-timeout”为0，“hard-timeout”为0，“cookie”为100000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c2f54bc4.png" alt="13.png"><br>说明：priority设置的比已有流表项的高，而idle-timeout和hardtimeout都设置为0则代表该流表项永远不会过期，除非被删除。  </p>
<p>步骤16 向右滚动Actions栏，在路径后面有动作类型GET、PUT、POST、DELETE，下发流表则选择PUT动作，然后单击“Send”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c5b47302.png" alt="14.png"><br>步骤17 如果下发成功会出现下面的提示，如果下发不成功则会弹出相应的错误信息。<br><img src="https://i.loli.net/2018/09/16/5b9e4c9033d8d.png" alt="15.png"><br>步骤18 切换到交换机，执行如下命令查看流表，确保刚刚下发的流表已经下发到交换机。如下图所示。</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl dump-flows br-sw
</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cc42a811.png" alt="16.png"><br>步骤19 登录主机1，执行如下命令向主机2、主机3发送数据包，测试主机间的连通性。</p>
<blockquote>
</blockquote>
<pre><code># scapy
&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())
&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())
</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cfe4003b.png" alt="17.png"><br>由上图可知，主机1与主机2之间不通，主机1与主机3通，新下发的流表项生效。  </p>
<p>说明：如果主机之间通则能够收到answer，如果主机之间不通那么就无法收到answer，当主机之间不通时scapy就会一直发送数据包，如果需要停止可以使用Ctrl+c。  </p>
<p>步骤20 切换到交换机，执行以下命令删除刚刚下发的流表项，并查看流表确保成功删除。  </p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl del-flows br-sw dl_type=0x0800,nw_src=10.0.0.3,nw_dst=10.0.0.4
ovs-ofctl dump-flows br-sw
</code></pre><p>步骤21 切换到主机1执行如下命令，测试主机1和主机2是否连通。</p>
<blockquote>
</blockquote>
<pre><code>result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())
</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4d486b69c.png" alt="18.png"><br>由上图可知，主机1与主机2之间就通了。</p>
<h1 id="基于OpenFlow1-3协议下发流表"><a href="#基于OpenFlow1-3协议下发流表" class="headerlink" title="基于OpenFlow1.3协议下发流表"></a>基于OpenFlow1.3协议下发流表</h1><p>步骤1 登录交换机，设置OpenFlow协议版本为1.3。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow13
</code></pre><p>步骤2 与OpenFlow1.0下发流表的过程解基本一致。展开opendaylight-inventory rev.2013-08-19，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”。  </p>
<p>步骤3 补全Actions栏中的路径，其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.3协议支持多级流表，所以这里的table id设置为2。  </p>
<p>步骤4 单击flow list后面的“+”，流表相关的参数就会展开。设置id为1，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e592464e82.png" alt="19.png"><br>步骤5 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e594c3f115.png" alt="20.png"><br>步骤6 在“layer-3-match”后面的下拉框中选择“ipv4-match”。  </p>
<p>步骤7 展开“layer-3-match”，填写源IP地址和目的IP地址。以主机1的IP为源IP，以主机3的IP为目的IP，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5979b8763.png" alt="21.png"><br>步骤8 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e599fdaa67.png" alt="22.png"><br>步骤9 展开“apply-actions”，单击“action list”后面的“+”，在“action”后面的下拉框中选择“drop-action-case”，“action order”和“instruction order”都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59c4a3dca.png" alt="23.png"><br>步骤10 设置“priority”为25，“idle-timeout”为0，“hard-timeout”为0，“cookie”为10000000，“table_id”为2，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59eb63de3.png" alt="24.png"><br>步骤11 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。PUT成功就会弹出“Request sent successfully”，否则弹出错误信息。  </p>
<p>步骤12 切换到主机1，执行如下命令，向主机3发送数据包，测试主机1和主机3的连通性。</p>
<blockquote>
</blockquote>
<pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())
</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5a28ba934.png" alt="25.png"><br>由上图可知，主机1与主机3之间是连通的，新下发的流表没有发挥作用。原因是数据包在table 0中能够匹配到相应流表就不会被转发到table2，想要table2的流表项发挥作用就需要向table0增加一条流表，将源IP为10.0.0.3，目的IP为10.0.0.2的数据包转发到table2中处理。  </p>
<p>步骤13 选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{i}”。node id参见之前查询到的Node Id、table id设为0、flow id设为1。  </p>
<p>步骤14 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800。  </p>
<p>步骤15 匹配参数保持不变，以主机1的IP为源IP，以主机3的IP为目的IP。  </p>
<p>步骤16 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“go-to-table-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5a73537cd.png" alt="26.png"><br>步骤17 展开“go-to-table”，table_id填写为2，即将符合匹配条件的数据包根据table2中的流表项处理。instruction order依旧设为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5aa888c72.png" alt="27.png"><br>步骤18 设“priority”置为23，“idle-timeout”为0，“hard-timeout”为0，“cookie”为1000000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5ad13fe66.png" alt="28.png"><br>步骤19 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。  </p>
<p>步骤20 切换到交换机，执行以下命令查看新下发的流表项。</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl -O OpenFlow13 dump-flows b
</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b076d691.png" alt="29.png"><br>步骤21 切换到主机1，执行如下命令发送数据包，测试主机之间的连通性。</p>
<blockquote>
</blockquote>
<pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())
&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())
</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b4ae09ab.png" alt="30.png"><br>由上图可知，主机1与主机3之间不通，而主机1与主机2之间通，流表发挥作用。</p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>5.OpenFlow实现示例之中继器HUB</title>
    <url>/2018/09/15/5-OpenFlow%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%AD%E7%BB%A7%E5%99%A8HUB/</url>
    <content><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow的流表项主要由3部分组成，分别是用于数据分组匹配的分组头域（Head Field），用于保存与条目相关统计信息的计数器（Counter），还有匹配表项后需要对数据分组执行的动作表（Action）。分组头域是数据分组匹配流表项时参照的依据，作用上类似于传统交换机进行二层交换时匹配数据分组的MAC地址，路由器进行三层路由时匹配的IP地址。流表项中的计数器用来统计相关“流”的一些信息，例如查找次数、收发分组数、生存时间等。另外，OpenFlow针对每张表、每个流表项、每个端口、每个队列也都会维护它们相应的计数器。动作表指定了OpenFlow交换机处理相应“流”的行为。相比于传统网络设备对数据分组只能进行较为单一的转发操作，流表项根据指定动作字段来指导OF交换机如何处理“流”。动作表可以包含0个或多个动作，交换机会按照这些动作的先后顺序依次执行，如果其中不包含转发（Forward）动作的话，数据分组就会被丢弃掉，如果包含转发动作，数据分组会得到相应的转发处理，但是OpenFlow v1.0无法保证不同的数据分组的转发顺序。动作可以分为两种类型：必选动作（Required Action）和可选动作（Optional Action）。必选动作是默认支持的，而交换机需要通知控制器它支持的可选动作。另外，当流表项中存在OpenFlow交换机不支持的动作时将向控制器返回错误消息。在SDN网络中，控制器下发流表主要有两种模式，分别是reactive模式和proactive模式。  </p>
<p>传统交换机参照MAC地址转发，路由器参照IP地址转发，通过定制ASIC芯片可以实现高速工作。而OpenFlow将网络协议栈扁平化，协议栈各层次对于转发设备而言不再具有明确的界限，各个网络字段都可作为流表中的匹配域，通过通配符掩码实现任意字段的组合。相比于传统网络，这种做法无疑大大提高了网络灵活性，但付出的代价是硬件设备为了适应这种通配的匹配方式，一般来说需要采用TCAM（Ternary Content Addressable Memory）来设计流表，但是TCAM的成本要高出很多，这就极大地限制了流表的规模，也就限制了SDN的规模。如果按照很多客户的要求，动辄要几十KB甚至上百KB的流表要求，至少需要20Mbit的TCAM，远远超过目前市场上容量最大的交换芯片的TCAM大小。为了克服TCAM表较小的问题，SDN先驱们提出采用reactive的方式来编写TCAM。<br><img src="https://i.loli.net/2018/09/15/5b9d05573ed46.png" alt="1.png"><br>在reactive模式下，OpenFlow交换机接收到未知数据包时，会向控制器发送一条packet_in消息询问控制器如何处理该数据包。控制器接收到packet_in消息后，计算路径并发送一条flow_mod消息指示交换机如何处理该数据包。并且，当老化定时器超时后就可以删除与该数据包相关的流表项。如此一来，OpenFlow交换机无需维护全部流表，只有当未知数据包到达交换机时才会触发reactive模式，可以有效的节省TCAM的空间。但是reactive模式缺点就是交换机无法即时地处理未知数据包，需要依赖控制器的决策，虽然在一定程度上解决了TCAM较小带来的问题，但是也让SDN控制器成为系统扩展的瓶颈，随着网络规模的不断扩大，SDN控制器无法处理大规模的网络流量，SDN控制器的性能就会限制网络规模的扩展。  </p>
<p>OpenFlow交换机和OpenFlow控制器之间的通道建立后，由OpenFlow控制器向OpenFlow交换机预先发送流表项方式称之为proactive模式。proactive模式的设置不是必须在控制器与交换机建立连接后立刻下发流表，可以在连接建立后的任意时间下发流表。proactive模式的主要特点是“主动”，控制器主动下发流表给交换机，随后交换机可以直接根据流表进行转发。proactive模式下控制器的压力会大大减轻，不过TCAM造成的局限性也尤为明显。</p>
<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9d0af0ac5d1.png" alt="拓扑.png"></p>
<h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，检查网络连通性。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p>
<p>步骤2 登录主机，查看主机IP。  </p>
<p>登录交换机，查看交换机mac地址。  </p>
<blockquote>
</blockquote>
<pre><code>ifconfig |more
</code></pre><p>根据实验拓扑图、交换机和主机的mac地址，可以判断出交换机eth1连接host1，eth2连接host2，eth3连接host3。</p>
<h1 id="proactive模式"><a href="#proactive模式" class="headerlink" title="proactive模式"></a>proactive模式</h1><p>步骤1 Open Daylight控制器与交换机建立连接后，会自动下发初始流表。登录交换机使用下列命令查看初始流表。</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl dump-flows br-sw
</code></pre><p>如果没有的话重启一下交换机。<br><img src="https://i.loli.net/2018/09/15/5b9d129607bf4.png" alt="2.png"><br>步骤2 登录控制器，在下方的“Application Finder”中搜索“postman”，并打开自带的Postman工具，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d151e53f54.png" alt="3.png"><br>步骤3 获取交换机的id信息。打开Basic Auth页签，Username字段填写admin，Password字段填写admin完成认证。  </p>
<p>提交方式为GET，URL地址栏中输入<a href="http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。</a>  </p>
<p>步骤4 单击Send按钮，获取交换机id信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d156896885.png" alt="4.png"><br>步骤5 下发一条流表。</p>
<blockquote>
<p>选择提交方式“PUT”。  </p>
</blockquote>
<blockquote>
<p>URL地址栏输入如下形式的地址：http://{controller-ip}:8080/restconf/config/opendaylight-inventory:nodes/node/{node-id}/table/{table-id}/flow/{flow-id}。  </p>
</blockquote>
<blockquote>
<p>其中，{controller-ip}为控制器的ip地址，node-id为上面获取到的交换机id信息，table-id这里为0，flow-id根据下发不同流表变化，可自定义。本实验URL地址栏输入如下地址：<a href="http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。</a>  </p>
</blockquote>
<blockquote>
<p>填写Headers信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d16d59439b.png" alt="5.png"><br>单击Body，Bady格式选择raw—&gt;XML(application/xml)。Body内容如下所示：  </p>
</blockquote>
<blockquote>
<p>匹配条件为ANY，actions为ALL，即将交换机收到的所有数据包转发到除入端口外的所有端口，从而实现中继器HUB的功能。</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;
    &lt;priority&gt;35&lt;/priority&gt;
    &lt;flow-name&gt;SDN&lt;/flow-name&gt;
    &lt;idle-timeout&gt;0&lt;/idle-timeout&gt;
    &lt;hard-timeout&gt;0&lt;/hard-timeout&gt;
    &lt;match&gt;ANY&lt;/match&gt;
    &lt;id&gt;14&lt;/id&gt;
    &lt;table_id&gt;0&lt;/table_id&gt;
    &lt;instructions&gt;
        &lt;instruction&gt;
            &lt;order&gt;0&lt;/order&gt;
            &lt;apply-actions&gt;
                &lt;action&gt;
                       &lt;output-action&gt;
                          &lt;output-node-connector&gt;ALL&lt;/output-node-connector&gt;
                       &lt;/output-action&gt;
                       &lt;order&gt;0&lt;/order&gt;
                &lt;/action&gt;
            &lt;/apply-actions&gt;
        &lt;/instruction&gt;
    &lt;/instructions&gt;
&lt;/flow&gt;
</code></pre><p>步骤6 单击Send按钮发送请求，STATUS显示请求发送成功，流表下发成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d18177ec0e.png" alt="6.png"><br>步骤7 登录交换机查看下发的流表，执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl dump-flows br-sw
</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d184ac4929.png" alt="7.png"><br>步骤8 登录主机host1，对主机host2进行ping操作，host2的IP为10.0.0.10，执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ping 10.0.0.10
</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18930750e.png" alt="8.png"><br>步骤9 登录交换机用tcpdump捕获广播到host2和host3数据包。host2对应的端口是eth2，host3对应的端口是eth3，分别捕获这两个端口上的数据包。  </p>
<p>（备注：选择不在host3、host2上抓包的原因是：由于当h1 ping h2时，数据包从交换机所有端口output出去后，openstack中的Linux-bridge会根据转发表过滤掉所有目的地址与端口不一致的数据包，因此host3上无法捕获host1与host2之间的数据包。）</p>
<blockquote>
</blockquote>
<pre><code>tcpdump -i eth2
</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18d0ab61c.png" alt="9.png"></p>
<blockquote>
</blockquote>
<pre><code>tcpdump -i eth3
</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d19734c90f.png" alt="10.png"></p>
<h1 id="reactive模式"><a href="#reactive模式" class="headerlink" title="reactive模式"></a>reactive模式</h1><p>reactive模式需要依赖SDN控制器的反应，实现较为复杂，在此仅进行方案介绍，不做实验操作，有兴趣的同学可自行拓展学习。  </p>
<p>步骤1 reactive模式的触发机制就是交换机将接收到数据包转发给控制器，交换机转发数据包给控制器的情况有两种：一个是交换机接收到未知数据包；另一个就是流表action要求交换机将数据包转发给控制器。因此设置reactive模式的第一步是下发一条流表，priority设置为最高65535，匹配条件为ANY，actions是将数据包output到controller。<br><img src="https://i.loli.net/2018/09/15/5b9d1a21ac061.png" alt="11.png"><br>流表项设置好后，当host1发送数据包时，交换机接收到数据包后会发送packet_in消息给控制器。  </p>
<p>步骤2 控制器接收到packet_in消息后对消息中的内容进行判断，计算分析后发送packet_out消息给交换机，告知交换机如何处理该数据包。本实验中控制器会要求交换机将数据包转发到除入端口外的所有端口，从而实验中继器的功能。<br><img src="https://i.loli.net/2018/09/15/5b9d1a4af035d.png" alt="12.png"></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Web服务器的安装与配置</title>
    <url>/2018/10/30/Apache-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装Apache2"><a href="#安装Apache2" class="headerlink" title="安装Apache2"></a>安装Apache2</h1><p>执行：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install apache2
</code></pre><p>Apache默认会在“/var”下建立一个名为“www”的目录，即Web目录，所有能通过浏览器访问的Web文件都放到这个目录。</p>
<h1 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h1><p>安装PHP：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install libapache2-mod-php5 php5
</code></pre><p>安装扩展包：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install php5-gd php5-mysql
</code></pre><p>重新启动Apache，加载PHP模块:</p>
<blockquote>
</blockquote>
<pre><code>sudo /etc/init.d/apache2 restart
</code></pre><h1 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h1><p>执行：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install mysql-server
</code></pre><p>根据提示信息设置密码。</p>
<h1 id="安装配置phpMyAdmin"><a href="#安装配置phpMyAdmin" class="headerlink" title="安装配置phpMyAdmin"></a>安装配置phpMyAdmin</h1><p>安装Mysql数据库管理软件：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install phpmyadmin
</code></pre><p>选择Web server：apache2或lighttpd：<br><img src="http://112.80.35.35:40010/site_media/media/course/45822350-0767-4686-b15a-74a093b03768/network/%E5%9B%BE%E7%89%87_nvEIrXy.png" alt="01.png"><br>之后还需要根据提示输入Mysql的root账户连接密码并设置phpMyAdmin的登录密码。  </p>
<p>将phpMyAdmin与Apache2建立连接。例如：www目录在“/var/www”下，phpMyAdmin在“/usr/share/phpmyadmin”目录下，则用如下命令建立连接：</p>
<blockquote>
</blockquote>
<pre><code>sudo ln -s /usr/share/phpmyadmin /var/www/html
</code></pre><p>在浏览器地址栏中输入<a href="http://localhost/phpmyadmin即可访问phpMyAdmin的登录页面。" target="_blank" rel="noopener">http://localhost/phpmyadmin即可访问phpMyAdmin的登录页面。</a></p>
]]></content>
      <categories>
        <category>服务器应用</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装VNC服务端程序</title>
    <url>/2018/12/21/CentOS7%E5%AE%89%E8%A3%85VNC%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="检查是否已安装VNC"><a href="#检查是否已安装VNC" class="headerlink" title="检查是否已安装VNC"></a>检查是否已安装VNC</h1><blockquote>
</blockquote>
<pre><code>rpm -q tigervnc tigervnc-server
</code></pre><h1 id="安装X-Window"><a href="#安装X-Window" class="headerlink" title="安装X-Window"></a>安装X-Window</h1><blockquote>
</blockquote>
<pre><code>yum check-update
yum groupinstall &quot;X Window System&quot; #这里可能会有警告提示，忽略即可
yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts
unlink /etc/systemd/system/default.target
ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target
reboot #重启机器
</code></pre><h1 id="安装VNC服务端"><a href="#安装VNC服务端" class="headerlink" title="安装VNC服务端"></a>安装VNC服务端</h1><blockquote>
</blockquote>
<pre><code>yum install tigervnc-server -y
</code></pre><h1 id="从VNC备份库中复制service文件到系统service服务管理目录下"><a href="#从VNC备份库中复制service文件到系统service服务管理目录下" class="headerlink" title="从VNC备份库中复制service文件到系统service服务管理目录下"></a>从VNC备份库中复制service文件到系统service服务管理目录下</h1><blockquote>
</blockquote>
<pre><code>cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service  #复制并重命名为vncserver@:1.service
</code></pre><h1 id="修改vncserver-1-service文件"><a href="#修改vncserver-1-service文件" class="headerlink" title="修改vncserver@:1.service文件"></a>修改vncserver@:1.service文件</h1><p>使用如下信息覆盖原信息：</p>
<blockquote>
</blockquote>
<pre><code>[Unit]
Description=Remote desktop service (VNC)
After=syslog.target network.target
[Service]
Type=forking
User=root
ExecStartPre=-/usr/bin/vncserver -kill %i
ExecStart=/sbin/runuser -l root -c &quot;/usr/bin/vncserver %i&quot; 
PIDFile=/root/.vnc/%H%i.pid
ExecStop=-/usr/bin/vncserver -kill %i
[Install]
WantedBy=multi-user.target
</code></pre><h1 id="修改文件使配置生效"><a href="#修改文件使配置生效" class="headerlink" title="修改文件使配置生效"></a>修改文件使配置生效</h1><blockquote>
</blockquote>
<pre><code>systemctl daemon-reload
</code></pre><h1 id="为vncserver-1-service设置密码"><a href="#为vncserver-1-service设置密码" class="headerlink" title="为vncserver@:1.service设置密码"></a>为vncserver@:1.service设置密码</h1><blockquote>
</blockquote>
<pre><code>vncpasswd
</code></pre><h1 id="启动VNC"><a href="#启动VNC" class="headerlink" title="启动VNC"></a>启动VNC</h1><blockquote>
</blockquote>
<pre><code>systemctl enable vncserver@:1.service #设置开机启动
systemctl start vncserver@:1.service #启动vnc会话服务
systemctl status vncserver@:1.service #查看nvc会话服务状态
systemctl stop vncserver@:1.service #关闭nvc会话服务
netstat -lnt | grep 590*  
</code></pre><p>5901端口已经处于监听状态：<br><img src="https://i.loli.net/2018/12/21/5c1cd3d638c69.png" alt="01.png"></p>
<h1 id="开启防火墙端口"><a href="#开启防火墙端口" class="headerlink" title="开启防火墙端口"></a>开启防火墙端口</h1><p>在安装后防火墙默认关掉了相应的端口，需要手动开启一下。<br>查看zone名称：</p>
<blockquote>
</blockquote>
<pre><code>firewall-cmd --get-active-zones
</code></pre><p>允许相关端口：</p>
<blockquote>
</blockquote>
<pre><code>firewall-cmd --zone=public --add-port=5901/tcp --permanent #5901即为要开启的端口
</code></pre><p>最后重启防火墙：</p>
<blockquote>
</blockquote>
<pre><code>firewall-cmd --reload
</code></pre><p>确认端口号是否开启：</p>
<blockquote>
</blockquote>
<pre><code>firewall-cmd --query-port=5901/tcp
</code></pre><h1 id="下载客户端进行连接"><a href="#下载客户端进行连接" class="headerlink" title="下载客户端进行连接"></a>下载客户端进行连接</h1><p>使用“ip::port”的方式进行连接，下图表明已经可以成功连接：<br><img src="https://i.loli.net/2018/12/21/5c1cd858e4d38.png" alt="2.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>VNC</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda开始菜单失踪</title>
    <url>/2018/09/10/Anaconda%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E5%A4%B1%E8%B8%AA/</url>
    <content><![CDATA[<p>今天想打开Anaconda写python程序的时候，突然发现Anaconda在开始菜单中神秘失踪了。<br>这时候只需要打开cmd，切换到Anaconda的安装目录的Lib文件夹下，执行如下命令：</p>
<blockquote>
</blockquote>
<pre><code>python _nsis.py mkmenus
</code></pre><p>重新生成一下开始菜单即可。<br><img src="https://i.loli.net/2018/09/10/5b9670b820c45.png" alt="snipaste_20180909_124542.png"></p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>4.基于RESTCONF的流表管理</title>
    <url>/2018/09/14/4-%E5%9F%BA%E4%BA%8ERESTCONF%E7%9A%84%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>所谓流表，其实可被视作是SDN对网络设备的数据转发功能的一种抽象。在传统网络设备中，交换机和路由器的数据转发需要依赖设备中保存的二层MAC地址转发表或者三层的IP地址路由表，SDN交换机中使用的流表也是如此，不过在它的表项中整合了网络中各个层次的网络配置信息，从而在进行数据转发时可以使用更丰富的规则。  </p>
<p>在使用RESTCONF下发流表时，需要学习的是请求消息的BODY的结构。实例如下：</p>
<blockquote>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;
    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;
     &lt;table_id&gt;0&lt;/table_id&gt;
    &lt;id&gt;100&lt;/id&gt;
     &lt;strict&gt;false&lt;/strict&gt;
   &lt;priority&gt;1&lt;/priority&gt;
     &lt;instructions&gt;
         &lt;instruction&gt;
             &lt;order&gt;0&lt;/order&gt;
             &lt;apply-actions&gt;
                 &lt;action&gt;
                     &lt;order&gt;0&lt;/order&gt;
                     &lt;output-action&gt;
&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;
                    &lt;/output-action&gt;
                &lt;/action&gt;
            &lt;/apply-actions&gt;
        &lt;/instruction&gt;
    &lt;/instructions&gt;
    &lt;match&gt;
    &lt;/match&gt;
&lt;/flow&gt;
</code></pre><p>BODY中定义了流表名称（flowname）、flow所在的table（table_id）、flow的id（id）、是否严格匹配（strict）、优先级和匹配字段（match fields）、优先级（priority）、指令（instructions）、超时（timeouts）、cookie等值。</p>
<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc7011f.png" alt="拓扑.png"></p>
<h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机查看网络连通性。由于OpenDaylight组件过于庞大，所以启动比较慢，容易导致控制器与交换机连接不成功的现象，间接导致主机无法获取IP。所以使用OpenDaylight控制器时，需要先检查网络连通性，查看交换机与控制器连接情况。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl show
</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p>
<p>步骤6 登录交换机，执行如下命令连接控制器。</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640
</code></pre><p>原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。</p>
<h1 id="删除ODL自动下发的流表"><a href="#删除ODL自动下发的流表" class="headerlink" title="删除ODL自动下发的流表"></a>删除ODL自动下发的流表</h1><p>在实验过程中需要验证两个不能通信的主机，通过REST北向接口下发流表，使得两个主机能够通信，所以需要删除原先的默认通信流表。  </p>
<p>步骤1 登录交换机，执行如下命令删除流表，如下图所示。</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl del-flows -O OpenFlow13 br-sw
</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc315a1.png" alt="1.png"><br>步骤2 执行ovs-ofctl dump-flows -O OpenFlow13 br-sw查看是否删除成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf7eee833f.png" alt="2.png"><br>步骤3 登录其中的一个主机，查看主机间网络网络连通情况，此时主机间无法进行通信，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf80fce130.png" alt="3.png"></p>
<h1 id="下发通信流表"><a href="#下发通信流表" class="headerlink" title="下发通信流表"></a>下发通信流表</h1><p>步骤1 登录控制器，打开浏览器，输入URL：<strong>http://[controller_ip]:8181/index.html</strong>，输入有户名：admin，密码：admin，单击登录。登录后，单击Nodes菜单，获取交换机node id，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf86025757.png" alt="4.png"><br>步骤2 单击Applications Menu/Development/Postman打开postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa287541e.png" alt="5.png"><br>步骤3 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/100。  </p>
<p>[controller-ip]为当前控制器的数据层的ip，[node-id]即步骤1中获得的node id请求类型选择PUT。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。选择BODY的类型raw -&gt;XML（application/xml），如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa5754286.png" alt="6.png"><br>步骤4 输入Body内容如下：</p>
<blockquote>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;
    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;
    &lt;table_id&gt;0&lt;/table_id&gt;
    &lt;id&gt;100&lt;/id&gt;
    &lt;installHw&gt;false&lt;/installHw&gt;
    &lt;strict&gt;false&lt;/strict&gt;
  &lt;priority&gt;1&lt;/priority&gt;
    &lt;instructions&gt;
       &lt;instruction&gt;
           &lt;order&gt;0&lt;/order&gt;
           &lt;apply-actions&gt;
               &lt;action&gt;
                   &lt;order&gt;0&lt;/order&gt;
                   &lt;output-action&gt;
&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;
                   &lt;/output-action&gt;
                &lt;/action&gt;
            &lt;/apply-actions&gt;
            &lt;/instruction&gt;
    &lt;/instructions&gt;
    &lt;match&gt;
    &lt;/match&gt;
&lt;/flow&gt;
注意：严格区分大小写
</code></pre><p>步骤5 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb40e9192.png" alt="7.png"><br>步骤6 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/。[controller-ip] 为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id请求类型选择GET。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb65ceea0.png" alt="8.png"><br>步骤7 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb85a72bb.png" alt="9.png"><br>可以看到，此流表为之前通过REST北向接口下发的流表。  </p>
<p>步骤8 登录其中的一个主机，查看主机间网络网络情况，此时主机间能够进行通信。</p>
<h1 id="使用Postman删除流表"><a href="#使用Postman删除流表" class="headerlink" title="使用Postman删除流表"></a>使用Postman删除流表</h1><p>步骤1 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/[flow-id]。  </p>
<p>[controller-ip]为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id，[flow-id]为之前下发流表的id，可以到【四、下发通信流表】的BODY中查看。请求类型选择DELETE.访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。点击Send，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf41812.png" alt="10.png"><br>步骤2登录交换机，切换至root用户。执行命令ovs-ofctl dump-flows -O OpenFlow13 br-sw，可验证流表已删除，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf2cb35.png" alt="11.png"></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7最小化安装后找不到ifconfig命令</title>
    <url>/2019/01/11/CentOS7%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0ifconfig%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>“ifconfig”命令用于配置GNU/Linux系统的网络接口。它显示网络接口卡的详细信息，包括IP地址，MAC地址，以及网络接口卡状态之类。但是，该命令已经过时了，而且在最小化版本的RHEL 7以及它的克隆版本CentOS 7，Oracle Linux 7和Scientific Linux 7中也找不到该命令。</p>
<h1 id="使用ip-addr和ip-link查看网卡信息"><a href="#使用ip-addr和ip-link查看网卡信息" class="headerlink" title="使用ip addr和ip link查看网卡信息"></a>使用ip addr和ip link查看网卡信息</h1><blockquote>
</blockquote>
<pre><code>ip addr # 查看网卡细节
ip link
ip -s link # 查看网络接口统计数据
</code></pre><h1 id="依然使用ifconfig"><a href="#依然使用ifconfig" class="headerlink" title="依然使用ifconfig"></a>依然使用ifconfig</h1><p>如果说我们还是想使用ifconfig命令，我们就需要安装相应的包来使用。首先查看哪些包提供ifconfig命令：</p>
<blockquote>
</blockquote>
<pre><code>yum provides ifconfig
</code></pre><p>或者：</p>
<blockquote>
</blockquote>
<pre><code>yum whatprovides ifconfig
</code></pre><p>根据输出信息安装相应的包即可使用ifconfig命令。  </p>
<p>参考自：<a href="https://linux.cn/article-3631-1.html" target="_blank" rel="noopener">Linux中国</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>ifconfig</tag>
      </tags>
  </entry>
  <entry>
    <title>Cisco设备密码重置</title>
    <url>/2018/10/11/Cisco%E8%AE%BE%E5%A4%87%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p>1 重启路由器，按ctrl+break/pause或ctrl+c/b,进入remmon模式  </p>
<blockquote>
<p>笔记本电脑可能没有pause键，可以运行：osk使用屏幕键盘进行操作  </p>
</blockquote>
<p>2 confreg 0x2142　修改寄存器的值  </p>
<p>3 reset　重启  </p>
<p>4 copy start run　把nvram内的文件转到内存中  </p>
<p>5 config-register 0x2102  </p>
<p>6 修改密码  </p>
<p>7 copy run start  </p>
<p>8 reload  </p>
<blockquote>
</blockquote>
<p><strong>0x2142:</strong>路由器启动不读取NVRAM，出厂配置启动<br><strong>0x2102:</strong>路由器启动读取NVRAM，正常配置启动<br><strong>0x2101:</strong>路由器启动不读取新指定的IOS，以出厂IOS启动，通常为base版本，支持功能有限</p>
<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>1 重启，按面板上的mode键3-5秒  </p>
<p>2 进入switch：模式  </p>
<p>3 输入：flash_init 初始化flash文件系统  </p>
<p>4 dir flash:查看flash内文件，其中包含配置文件为config.text  </p>
<p>5 rename flash:config.text flash:config.old 把原来的文件重命名，随意起名字  </p>
<p>6 boot重启  </p>
<p>7 rename flash:config.old flash:config.text   </p>
<p>8 copy flash:config.text system:running-config  </p>
<p>9 修改密码  </p>
<p>10 copy run start 保存配置  </p>
<p>11 reload/reset/boot 重启  </p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>密码必须要进行修改，不能不设置，如果不需要密码可在修改密码之后进入配置模式删除密码</p>
]]></content>
      <categories>
        <category>Cisco</category>
      </categories>
      <tags>
        <tag>网工</tag>
        <tag>Cisco</tag>
      </tags>
  </entry>
  <entry>
    <title>Dell服务器iDRAC虚拟控制台无法连接问题解决方法</title>
    <url>/2020/05/12/Dell%E6%9C%8D%E5%8A%A1%E5%99%A8iDRAC%E8%99%9A%E6%8B%9F%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天配置10台Dell R720服务器的iDRAC服务之后，远程连接的时候发现出现部分服务器虚拟控制台连接不上的问题，尝试了网上了一些解决方法之后，最后通过升级iDRAC固件的方式解决了问题，在此记录一下，供参考。</p>
<h1 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h1><p>虚拟控制台连接是报错：查看器已终止。原因：网络连接中断<br><img src="https://i.loli.net/2020/05/12/WGVHlADTrBjzspy.png" alt="01.png"></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>因为10台服务器有的可以正常连接，所以对比了一下配置，发现可以访问的服务器iDRAC固件版本是”2.52.52.52”，而出现以上报错的固件版本是”1.57.57 (Build 04)”，所以尝试升级固件版本，升级的具体操作如下。</p>
<h2 id="下载固件文件"><a href="#下载固件文件" class="headerlink" title="下载固件文件"></a>下载固件文件</h2><p>我下载的固件是带Lifecycle Controller的IDRAC 2.52.52.52，iDRAC固件升级文件名称前缀通常为：iDRAC-with-Lifecycle-Controller_Firmware  </p>
<p>如果没有特殊需要可以直接下载我更新的这个版本：<br><a href="https://dl.dell.com/FOLDER04830661M/1/iDRAC-with-Lifecycle-Controller_Firmware_1YCHC_WN64_2.52.52.52_A00.EXE" target="_blank" rel="noopener">iDRAC-with-Lifecycle-Controller_Firmware_1YCHC_WN64_2.52.52.52_A00.EXE</a></p>
<h2 id="上传固件"><a href="#上传固件" class="headerlink" title="上传固件"></a>上传固件</h2><p>下载后登录iDRAC的web界面，在左侧菜单栏点击iDRAC设置-更新和回滚，更新文件选择本地下载的升级文件，并点击“上载”按钮上传。<br><img src="https://i.loli.net/2020/05/12/mb5GiXqFOA3Bcp2.png" alt="02.png"></p>
<h2 id="安装固件"><a href="#安装固件" class="headerlink" title="安装固件"></a>安装固件</h2><p>上传完成后勾选上传的固件后点击“安装”安装固件<br><img src="https://i.loli.net/2020/05/12/Y6l9qxR2UItuTnw.png" alt="03.png"><br>点击作业队列可查看安装进度<br><img src="https://i.loli.net/2020/05/12/FawbZBtRcWA7Xhe.png" alt="04.png"><br>更新完成后状态会显示为compelete状态，再次打开虚拟控制台，连接成功。<br><img src="https://i.loli.net/2020/05/12/GVkBRn5L3bgZqie.png" alt="05.png"></p>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://www.dell.com/support/article/zh-cn/sln307185/%E4%BD%BF%E7%94%A8idrac-web%E7%95%8C%E9%9D%A2%E6%9B%B4%E6%96%B0idrac%E5%9B%BA%E4%BB%B6?lang=zh" target="_blank" rel="noopener">https://www.dell.com/support/article/zh-cn/sln307185/%E4%BD%BF%E7%94%A8idrac-web%E7%95%8C%E9%9D%A2%E6%9B%B4%E6%96%B0idrac%E5%9B%BA%E4%BB%B6?lang=zh</a><br><a href="https://cyneliu.gitee.io/2019/06/21/IBM%E6%9C%8D%E5%8A%A1%E5%99%A8IMM%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">https://cyneliu.gitee.io/2019/06/21/IBM%E6%9C%8D%E5%8A%A1%E5%99%A8IMM%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</a></p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>iDRAC</tag>
        <tag>Dell</tag>
      </tags>
  </entry>
  <entry>
    <title>Citrix XenServer 初探</title>
    <url>/2019/05/19/Citrix-XenServer-%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="XenServer安装"><a href="#XenServer安装" class="headerlink" title="XenServer安装"></a>XenServer安装</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装平台：服务器或虚拟机<br>下载XenServer镜像：</p>
<blockquote>
</blockquote>
<p>一开始下载时是准备在官网直接下载的，但是也许是因为中美贸易战的原因，在注册账号后开始登录时出现如下提示：<br><img src="https://i.loli.net/2019/05/19/5ce0f45a95d4553874.png" alt="00.png"><br>无奈只能Google看看有没有好人分享过镜像，最后还是找到了：</p>
<blockquote>
<blockquote>
<p>百度网盘：<a href="http://pan.baidu.com/s/1pLrQv39" target="_blank" rel="noopener">密码：yxxl</a><br>原帖地址：<a href="http://www.xen800.com/thread-1527-1-1.html" target="_blank" rel="noopener">http://www.xen800.com/thread-1527-1-1.html</a></p>
</blockquote>
</blockquote>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>下载XenServer的iso镜像之后，将镜像文件刻录到U盘或者光盘中，然后插入服务器选择从相应介质引导启动即可，具体安装步骤可参考下面这份安装教程：</p>
<blockquote>
</blockquote>
<p><a href="https://pan.baidu.com/s/1SHIYPuj7gJphCihfjqadRg" target="_blank" rel="noopener">Citrix虚拟化之旅三（XenServer 新手安装教程）.pdf</a><br>提取码：cue2 </p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="显示器输入不支持"><a href="#显示器输入不支持" class="headerlink" title="显示器输入不支持"></a>显示器输入不支持</h3><p>因为显示器比较烂，在刚开始安装的时候显示输入不支持，参考安装教程，应该是在这一步：<br><img src="https://i.loli.net/2019/05/19/5ce0fcb5be53318989.png" alt="01.png"><br>所以直接盲敲回车就可以了，当然需要等待一段时间才能看到内容。</p>
<h3 id="安装后无法引导启动"><a href="#安装后无法引导启动" class="headerlink" title="安装后无法引导启动"></a>安装后无法引导启动</h3><ul>
<li>开机后进入BIOS，找到”Boot Manager”，选择”add Boot Option”，选择”legacy only”;  </li>
<li>然后在“Change Boot Order”中，把“legacy only”选项调整为第一位,然后选择”commit changes “保存;  </li>
<li>System Settings-&gt;Devices and I/O Ports-&gt;Console Redirection Settings-&gt;Remote Console 设置为Enable。</li>
</ul>
<p>详细可参考：<a href="https://blog.51cto.com/chenmingxin/878374" target="_blank" rel="noopener">https://blog.51cto.com/chenmingxin/878374</a></p>
<h1 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h1><h2 id="安装XenCenter"><a href="#安装XenCenter" class="headerlink" title="安装XenCenter"></a>安装XenCenter</h2><p>打开浏览器访问XenServer的ip地址，下载XenCenter安装程序：<br><img src="https://i.loli.net/2019/05/19/5ce1006ca1a0469993.png" alt="02.png"><br>也可以去网上下载其它版本，我这里是安装了7.0中文版。<br>然后添加服务器，输入服务器ip、用户名及密码完成添加：<br><img src="https://i.loli.net/2019/05/19/5ce1016d3388953979.png" alt="04.png"></p>
<h2 id="创建SR"><a href="#创建SR" class="headerlink" title="创建SR"></a>创建SR</h2><p>在创建虚拟机时我们肯定会用到操作系统的安装镜像，不同于ESXI可以直接挂载本地镜像，我们需要先创建ISO库来存放我们将要用到的安装镜像。<br>在创建ISO库之前，先创建一个共享文件夹，文件夹中存放着我们的镜像文件：<br><img src="https://i.loli.net/2019/05/19/5ce103566dcff61384.png" alt="07.png"><br>右键添加的服务器，选择“新建SR”：<br><img src="https://i.loli.net/2019/05/19/5ce1022a50b6383082.png" alt="05.png"><br>存储类型选择Windows文件共享：<br><img src="https://i.loli.net/2019/05/19/5ce1035651bb373212.png" alt="06.png"><br>输入共享地址以及用户名密码完成挂载：<br><img src="https://i.loli.net/2019/05/19/5ce103fee462934335.png" alt="08.png"><br>现在我们就可以在“ISO库”中看到我们的镜像文件了：<br><img src="https://i.loli.net/2019/05/19/5ce104a286b9769937.png" alt="09.png"></p>
<h2 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h2><p>以上操作完成之后我们就可以点击菜单栏的“新建VM”，按照提示创建我们的虚拟机了，具体步骤可参考上面提到的安装教程。</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Citrix</tag>
        <tag>XenServer</tag>
      </tags>
  </entry>
  <entry>
    <title>GPT分区安装操作系统后无法引导启动</title>
    <url>/2019/12/30/GPT%E5%88%86%E5%8C%BA%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%97%A0%E6%B3%95%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>记得之前写过一篇<a href="https://cyneliu.gitee.io/2018/09/13/%E7%A7%92%E6%87%82MBR%E5%92%8CGPT%E5%88%86%E5%8C%BA%E8%A1%A8/" target="_blank" rel="noopener">《秒懂MBR和GPT分区表》</a>，当时是因为帮别人重装系统，因为是GPT分区，所以装完系统一直引导不起来，后来查了一下是GPT的原因，当时因为着急直接把GPT转成MBR了。  </p>
<p>然后最近又被这个GPT给绊倒了，前几天帮朋友重装系统，也是GPT分区，先是把分区信息都给删干净了，然后傻乎乎的就开始重装系统了，不出意外，系统又引导不起来，提示“System not found”，捣鼓了半天终于发现了问题。  </p>
<h1 id="EFI分区"><a href="#EFI分区" class="headerlink" title="EFI分区"></a>EFI分区</h1><p>EFI系统分区（EFI system partition，简称ESP），是一个FAT16或FAT32格式的物理分区，但是其分区标识是EF (十六进制) 而非常规的0E或0C，因此，该分区在Windows操作系统下一般是不可见的。ESP分区在UEFI BIOS引导系统时使用，用来存储BIOS/EFI NAND芯片存储不下的那部分EFI扩展功能。支持EFI模式的电脑需要从ESP启动系统，EFI固件可从ESP加载EFI启动程序或应用，ESP是系统引导分区。</p>
<h1 id="MSR分区"><a href="#MSR分区" class="headerlink" title="MSR分区"></a>MSR分区</h1><p>MSR分区（Microsoft Reserved Partition，缩写MSR）即Microsoft 保留 (MSR) 分区。是每个 在GUID 分区表 (GPT) 上的 Windows操作系统（windows7以上）都要求的分区。系统组件可以将 MSR 分区的部分分配到新的分区以供它们使用。<br>MSR 分区的大小会因 GPT 磁盘的大小不同而发生变化。对于小于 16 GB 的磁盘，MSR 分区为 32 MB。对于大于 16 GB 的磁盘，MSR 分区为 128 MB。MSR 分区在“磁盘管理”中不可见，在Diskpart、Diskgenius等磁盘工具里可见，但是用户无法在 MSR 分区上存储或删除数据。</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>我使用的PE是<a href="http://www.wepe.com.cn/" target="_blank" rel="noopener">WEPE</a>  </p>
<p>首先我们需要确认一下当前系统磁盘是GPT磁盘，如下图所示，如果之前装过操作系统的话我们打开分区助手应该是可以看到ESP和MSR这两个隐藏分区的，或者只有一个ESP分区，如果是新硬盘的话使用快速分区也可以自动生成这两个分区。<br><img src="https://i.loli.net/2019/12/31/Mw3tbGRjBvdr5yx.png" alt="00.png"></p>
<p>为了重现我之前遇到的问题，我们把系统分区和这两个隐藏分区都删掉，然后重建系统分区，然后按照BIOS+MBR的方式安装操作系统（这就是安装完系统无法引导的原因），其实Windows安装器在安装时也会有错误提示，EFI PART的灯是红色的，说明我们选择的引导驱动器并非EFI引导分区。</p>
<blockquote>
<p>UEFI+GPT方式安装操作系统时，不能像之前BIOS方式那样将引导分区设置为系统分区，而是需要设置为ESP分区。  </p>
</blockquote>
<p><img src="https://i.loli.net/2019/12/31/KHTAOxuNlICfm7v.png" alt="01.png"></p>
<p>所以我们需要手动去创建ESP和MSR分区，打开DiskGenius,选择未分配空间，创建新分区，文件系统类型选择“EFI system partition”,大小100M就可以了。<br><img src="https://i.loli.net/2019/12/31/1oxUQH8umG3yeV5.png" alt="02.png"><br>然后新建MSR分区，文件系统类型选择“Microsoft Reserved Partition”，大小128M。<br><img src="https://i.loli.net/2019/12/31/9XY7IAWwzbSF2Oe.png" alt="03.png"><br>然后在根据自己需要进行其它分区的配置，我这里因为使用的是虚拟机，硬盘比较少，只做演示。<br><img src="https://i.loli.net/2019/12/31/zC3OpMylkdYUmqi.png" alt="04.png"><br>分区完成后保存更改。再次打开Windows安装器，引导驱动器选择ESP分区，这时安装器就显示正常了。<br><img src="https://i.loli.net/2019/12/31/USf9ymFMxwpgqu5.png" alt="05.png"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://bbs.wuyou.net/forum.php?mod=viewthread&amp;tid=374959&amp;page=1" target="_blank" rel="noopener">MSR分区到底有什么功能</a></p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>GPT</tag>
        <tag>重装系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的命令行网盘</title>
    <url>/2018/10/09/Linux%E4%B8%8B%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BD%91%E7%9B%98/</url>
    <content><![CDATA[<p>之前浏览别人博客的时候发现了一个非常好用的文件上传分享工具，而且是在Linux下的，今天试着用了一下，用起来方便快捷，感觉很不错。  </p>
<p>这款工具的名字叫做<strong>transfer.sh</strong>，transfer.sh的使用也非常简单，可以使用curl的upload-file来上传文件。我这里测试用的是我的一台用作ssr的centos：  </p>
<p><img src="https://i.loli.net/2018/10/09/5bbc835018e45.png" alt="01.png"></p>
<p>上图中我是要把当前目录下的“bbr.sh”文件上传分享出去，并且重命名为“bbr2.sh”。那么我们只需要执行如下命令即可：</p>
<blockquote>
</blockquote>
<pre><code>curl --upload-file ./bbr.sh https://transfer.sh/bbr2.sh
</code></pre><p>上传完毕后就会返回一个分享链接，也就是“<a href="https://transfer.sh/9edgU/bbr2.sh”，把这个链接发给别人就可以下载了。" target="_blank" rel="noopener">https://transfer.sh/9edgU/bbr2.sh”，把这个链接发给别人就可以下载了。</a>  </p>
<p><img src="https://i.loli.net/2018/10/09/5bbc8491c4b3b.png" alt="02.png"></p>
<p>除此之外，transfer.sh还提供其它多种方式，比如一次性上传多个文件等，感兴趣的可以访问官网。  </p>
<p><strong><em>官网：</em></strong><br><a href="https://transfer.sh/" target="_blank" rel="noopener">https://transfer.sh/</a><br><strong><em>Github:</em></strong><br><a href="https://github.com/dutchcoders/transfer.sh/" target="_blank" rel="noopener">https://github.com/dutchcoders/transfer.sh/</a></p>
]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ESXI安装OpenWrt/LEDE实现软路由功能</title>
    <url>/2018/12/23/ESXI%E5%AE%89%E8%A3%85OpenWrt-LEDE%E5%AE%9E%E7%8E%B0%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>最近部署一套环境需要从国外的服务器下载文件，因为众所周知的原因，速度慢到几kb不说，还经常传输失败，但一台一台的设置科学上网又比较麻烦，所以就有了设置一个可以使用酸酸乳的软路由作为网关的想法。  </p>
<p>实验室硬件不支持肯定首先想到的就是软路由了，常用的比较有名的当属RouterOS了，再就是<a href="http://www.hi-spider.com/zh" target="_blank" rel="noopener">海蜘蛛</a>和<a href="http://www.ikuai8.com/" target="_blank" rel="noopener">爱快</a>等等了，但是貌似都不能用酸酸乳，最后找到的就是OpenWrt/LEDE这个方案了，下面简单整理一下过程。  </p>
<h1 id="下载-vmdk文件"><a href="#下载-vmdk文件" class="headerlink" title="下载*.vmdk文件"></a>下载*.vmdk文件</h1><p>感谢koolshare论坛的大佬给出的硬盘文件，原帖地址：<a href="http://koolshare.cn/thread-67584-1-8.html" target="_blank" rel="noopener">http://koolshare.cn/thread-67584-1-8.html</a>  </p>
<p>下载地址：<a href="https://pan.baidu.com/s/1kVHJ3gj#list/path=%2F" target="_blank" rel="noopener">百度网盘</a>（4kqa）</p>
<h1 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h1><p>打开vSphere客户端，新建虚拟机，因为之后需要换硬盘文件，所以这里配置什么的就无所谓了，直接选择典型就可以了。客户机操作系统我这里选择的是“其他Linux(64位)”：<br><img src="https://i.loli.net/2018/12/23/5c1f721de8dfe.png" alt="01.png"><br>然后网卡根据需要设置成两个或两个以上，我这里没有特殊需要，两个网卡一个WAN口一个LAN口就可以了：<br><img src="https://i.loli.net/2018/12/23/5c1f721df2c97.png" alt="02.png"><br>之后默认即可，完成虚拟机创建。</p>
<h1 id="修改硬盘文件"><a href="#修改硬盘文件" class="headerlink" title="修改硬盘文件"></a>修改硬盘文件</h1><p>在服务器存储中找到刚刚创建的虚拟机的虚拟磁盘文件（.vmdk）并删除：<br><img src="https://i.loli.net/2018/12/23/5c1f732863c64.png" alt="03.png"><br>在当前目录上传之前下载的两个.vmdk文件，上传之后会被合并为一个文件：<br><img src="https://i.loli.net/2018/12/23/5c1f741fb2876.png" alt="04.png"><br>编辑虚拟机设置，添加现有虚拟磁盘，在存储中找到刚刚上传的文件完成添加并删除原来的硬盘：<br><img src="https://i.loli.net/2018/12/23/5c1f7516ded5b.png" alt="05.png"><br>打开电源即可开始安装。</p>
<h1 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h1><p>安装完成后按回车进入：<br><img src="https://i.loli.net/2018/12/23/5c1f76226f85a.png" alt="06.png"><br>网络的配置文件在“/etc/config/network”下，可以根据需要进行修改：<br><img src="https://i.loli.net/2018/12/23/5c1f76f5e44c4.png" alt="07.png"><br>这里我没有做任何更改，因为上接网络中有DHCP服务器，所以自动获取了一个WAN口ip，如果没有DHCP需要手工设置ip地址，LAN口ip使用默认的192.168.1.1。</p>
<h1 id="登录WEB页面"><a href="#登录WEB页面" class="headerlink" title="登录WEB页面"></a>登录WEB页面</h1><p>我们需要使用LAN口的ip地址进入WEB页面，所以我把一台Windows设备的ip地址设置为192.168.1.2/24，网关192.168.1.1。  </p>
<p>打开浏览器访问192.168.1.1，用户名：admin，密码：koolshare。<br><img src="https://i.loli.net/2018/12/23/5c1f78cab38bd.png" alt="08.png"></p>
<p>开启SS服务并将需要和谐上网的虚拟机修改网关为LAN口地址，大功告成！</p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>ESXI</tag>
        <tag>OpenWrt</tag>
        <tag>软路由</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>IBM服务器IMM基本配置及使用</title>
    <url>/2019/06/21/IBM%E6%9C%8D%E5%8A%A1%E5%99%A8IMM%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="IMM简介"><a href="#IMM简介" class="headerlink" title="IMM简介"></a>IMM简介</h1><p>IMM，即Integrated Management Module，是IBM服务器上即集成管理模块，改模块独立于服务器系统，可以使用一个单独的IP地址，使用Web和虚拟端口方式直接启动、停止和管理远程服务器，通俗的讲就是可以远程实现服务器的开关机、BIOS设置以及安装操作系统等很多操作。</p>
<h1 id="开启IMM服务"><a href="#开启IMM服务" class="headerlink" title="开启IMM服务"></a>开启IMM服务</h1><p>在IBM服务器的背面会有一个独立于网口的一个专用的管理端口，如下图所示：<br><img src="https://i.loli.net/2019/06/21/5d0cc01f089dd92838.png" alt="0.png"><br>我们使用IMM服务首先需要将网线接入管理口，然后下一步将服务器开机进入BIOS，依次进入<strong>System Settings</strong>→<strong>Integrated Management Module</strong>→<strong>Network Configuration</strong>。<br><img src="https://i.loli.net/2019/06/21/5d0cc0ed9625a94680.png" alt="00.png"><br>进入网络配置页面后设置IMM的访问地址，然后保存退出BIOS即可。<br><img src="https://i.loli.net/2019/06/21/5d0cc0ed3573571780.png" alt="000.png"><br>此时打开浏览器访问我们设置的IP地址就可以看到IMM的登录页面了，输入默认用户名/密码：USERID/PASSW0RD即可（注意是数字0）。如果密码错误可能是之前设置过，再次进入BIOS然后<strong>Reset IMM</strong>重新设置IP地址即可。<br><img src="https://i.loli.net/2019/06/21/5d0cc24dea73e97097.png" alt="06.png"><br>Web管理页面提供很多功能，这里就不一一介绍了，下面简单介绍一下如何使用IMM远程安装操作系统。进入如下页面，并启动远程控制台，两种方式可以根据特殊需要自行选择：<br><img src="https://i.loli.net/2019/06/21/5d0cc55abaffb64451.png" alt="08.png"><br>点击链接之后会提示下载两个<strong>.jnlp</strong>文件，将这两个文件下载下来并双击运行（前提是电脑正确安装了JRE运行环境），这两个jnlp文件一个是远程控制台另一个则是一个虚拟媒体服务：<br><img src="https://i.loli.net/2019/06/21/5d0cc55aad04c62696.png" alt="01.png"><br>点击<strong>Add Image</strong>添加镜像文件，然后勾选<strong>Map</strong>并将我们添加的镜像文件挂载到服务器。<br><img src="https://i.loli.net/2019/06/21/5d0cc6c8a312b64464.png" alt="02.png"><br>重启之后便进入了系统安装引导界面：<br><img src="https://i.loli.net/2019/06/21/5d0cc733890a729814.png" alt="03.png"></p>
<h1 id="遇到的一些小问题"><a href="#遇到的一些小问题" class="headerlink" title="遇到的一些小问题"></a>遇到的一些小问题</h1><h2 id="浏览器提示：此网站无法提供安全连接"><a href="#浏览器提示：此网站无法提供安全连接" class="headerlink" title="浏览器提示：此网站无法提供安全连接"></a>浏览器提示：此网站无法提供安全连接</h2><p>我在第一次访问时使用的是Chrome浏览器，但却弹出“此网站无法提供安全连接”的提示信息而且不能跳过并继续访问，解决办法是使用其它浏览器（我使用的是Edge浏览器）登入，然后将HTTPS禁用掉：<br><img src="https://i.loli.net/2019/06/21/5d0cc4504a1a784446.png" alt="07.png"></p>
<h2 id="jnlp运行报错"><a href="#jnlp运行报错" class="headerlink" title="jnlp运行报错"></a>jnlp运行报错</h2><p>不想看废话直接换Java 7！  </p>
<p>我的电脑安装的是Java 8，在第一次运行jnlp时，出现如下错误：<br><img src="https://i.loli.net/2019/06/21/5d0cc81a2a94399797.png" alt="04.png"><br>详细信息：<br><img src="https://i.loli.net/2019/06/21/5d0cc8ad10ff989581.png" alt="05.png"><br>经过一番搜索与尝试发现是JRE版本的问题，于是降级到Java 6，发现控制台可以正常启动了，但是另一个jnlp也就是虚拟媒体服务却依然运行报错：“The Virtual Media Program will close. Reason: The Virtual Media native library cannot be loaded”，然后又换到了Java 7解决问题。</p>
<h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>为了能够正常访问Web页面并使用远程控制服务，需要对80以及3900两个端口进行映射。<br><img src="https://i.loli.net/2019/06/21/5d0cca3bc635047654.jpg" alt="09.jpg"></p>
<h1 id="类似服务"><a href="#类似服务" class="headerlink" title="类似服务"></a>类似服务</h1><p>基本上每种品牌的服务器都有类似的远程管理功能，比如DELL服务器的iDRAC(Integrated Dell Remote Access Controller)等等，使用起来基本上都是类似的。<br><img src="https://s2.ax1x.com/2019/06/23/ZFEZjS.png" alt="11.png"></p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>Java多版本下载地址：<a href="https://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>IBM</tag>
        <tag>IMM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的几个查找命令</title>
    <url>/2019/04/04/Linux%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>可以查找任何类型的文件。<br>语法格式：</p>
<blockquote>
</blockquote>
<pre><code>find path -option [-print] [-exec -ok command] {} \;
</code></pre><p>path:搜索的目录及其子目录，缺省为当前目录<br>-name:按文件名称查找<br>-user:按文件的属主查找<br>-group:按文件的属组查找<br>-perm:按文件权限查找<br>-prune:不在当前指定目录查找(除了此目录外进行查找)</p>
<h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p>locate命令与“find -name”的作用类似，但原理完全不同。<br>它比find快得多，因为它不搜索具体目录，而是在一个数据库(/var/lib/locatedb)中搜索指定的文件。此数据库含有本地文件的所有信息，这个数据库是linux系统自动创建的，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，默认情况下为每天更新一次，所以用locate命令你搜索不到最新更新的文件，除非你在用locate命令查找文件之前手动的用updatedb命令更新数据库。<br>也就是说在没有手动更新的前提下，如果删除掉之前存在文件，locate依然可以搜索到它。</p>
<h1 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h1><p>只能查找二进制文件(-b)，源代码文件(-s)和说明文件(-m)。<br>如果省略参数则返回所有的信息。</p>
<h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>在PATH变量指定的路径中搜索指定的系统命令的位置。</p>
<blockquote>
</blockquote>
<pre><code>which find
/bin/find
</code></pre><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>type命令主要用于区分一个命令到底是shell自带的还是外部独立的二进制文件提供的。如果是shell自带的则会提示此命令为shell buildin,否则会列出命令的位置。</p>
<blockquote>
</blockquote>
<pre><code>type cd
cd is a shell builtin

type ssh
ssh is /usr/bin/ssh
</code></pre><p>原文链接：<a href="https://www.cnblogs.com/ginvip/p/6357352.html" target="_blank" rel="noopener">https://www.cnblogs.com/ginvip/p/6357352.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>IBM System x3650 M2硬盘亮黄灯</title>
    <url>/2019/05/10/IBM-System-x3650-M2%E7%A1%AC%E7%9B%98%E4%BA%AE%E9%BB%84%E7%81%AF/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>服务器之前做了RAID1并且装了ESXI，在开机状态下拔掉一块硬盘后，硬盘黄灯亮起并发出连续的滴滴警报声，硬件故障检测板DASD亮起，百度尝试了很多方式，比如拔掉电源后重启等均无效。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>因为服务器并没有跑虚拟机和存数据，所以最后直接重做了RAID，过程如下：  </p>
<h2 id="进入WebBIOS"><a href="#进入WebBIOS" class="headerlink" title="进入WebBIOS"></a>进入WebBIOS</h2><p>服务器重启按F1进入BIOS，找到<strong>Sytem Settings → Adapters and UEFI Drivers → Please press ENTER to compile the list of drivers</strong>，然后选择“LSI EFI SAS Driver”下面那一行，然后回车，根据提示输入 1 并再次回车进入WebBIOS。</p>
<h2 id="更改硬盘状态"><a href="#更改硬盘状态" class="headerlink" title="更改硬盘状态"></a>更改硬盘状态</h2><p>进入BIOS之后，点击<strong>Physical View</strong>,可以看到亮黄灯的那块硬盘出啊先“Unconfigured Bad”的提示信息：<br><img src="https://i.loli.net/2019/05/10/5cd56a133ea99.jpg" alt="02.jpg"><br>点击进入那块出错的硬盘，勾选”Make Unconf Good”，然后点击”Go”,不再做其它设置<br><img src="https://i.loli.net/2019/05/10/5cd569dc9c984.jpg" alt="01.jpg"><br>这样在之后配置RAID的时候就可以发现这块硬盘并做相应的添加等操作了。</p>
<h2 id="配置RAID"><a href="#配置RAID" class="headerlink" title="配置RAID"></a>配置RAID</h2><p>进入WebBIOS后选择Configuration Wizard配置向导：<br><img src="https://i.loli.net/2019/05/10/5cd5498c4f727.png" alt="01.png"><br>选择New Configuration，代表清除原有阵列信息并重新配置：<br><img src="https://i.loli.net/2019/05/10/5cd54a72d2279.png" alt="02.png"><br>选择Yes确定：<br><img src="https://i.loli.net/2019/05/10/5cd54ac271c11.png" alt="03.png"><br>然后选择手动配置：Manual Configuration<br><img src="https://i.loli.net/2019/05/10/5cd54b7a74da1.png" alt="04.png"><br>选择要配置在RAID中的硬盘，按Add to Array从左边的Drivers中选到右边的Driver Groups中。<br><img src="https://i.loli.net/2019/05/10/5cd54dce6fec6.png" alt="05.png"><br>选好硬盘后，选择Accept DG后点击Next<br><img src="https://i.loli.net/2019/05/10/5cd54dfd61eb8.png" alt="06.png"><br>在左侧的ArrayWithFreeSpace中选中刚刚做好的Disk Groups按Add to SPAN添加到右侧的span中，然后选择Next<br><img src="https://i.loli.net/2019/05/10/5cd54ef819426.png" alt="07.png"><br>最后会进入Virtual Disk配置界面，RAID级别选择RAID1，需要注意的是Select size的设置，在右侧会有提示，根据提示填入相应的大小即可，点选Accept接受配置，最后选择Next。  </p>
<p>最后还会重新出现一次之前的配置界面，直接无视就可以，Accept和Next即可。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>IBM</tag>
      </tags>
  </entry>
  <entry>
    <title>1.OpenFlow建立连接交互流程</title>
    <url>/2018/09/13/1-OpenFlow%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="OpenFlow协议简介"><a href="#OpenFlow协议简介" class="headerlink" title="OpenFlow协议简介"></a>OpenFlow协议简介</h1><p>2006年，斯坦福大学Clean Slate计划资助的Ethane项目开始部署，致力于企业网架构的创新，OpenFlow协议的雏形就诞生于这个项目。2008年，Nick McKeown教授的一篇重要论文“OpenFlow：Enabling Innovation in Campus Networks”使得OpenFlow正式进入人们的视野，继而成为了标准化组织ONF（Open Network Foundation，开放网络基金会）主推的南向接口协议。经过多年的发展，OpenFlow现已成为SDN的主流南向接口协议之一。目前，OpenFlow协议还在不断地演进中，本实验采用OpenFlow v1.3协议，并对控制器与OpenFlow交换机之间的交互过程进行深入分析。<br>OpenFlow主要有3种类型的消息，分别是Controller-to-Switch、Asynchronous和Symmetric，其中每个类型又包含多个子类型。Controller-to-Switch消息由控制器发起，用于管理、查看交换机的状态。Asynchronous消息由交换机发起，向控制器汇报交换机的事件和改变。Symmetric消息由控制器或交换机任一方发起，无需请求直接发起消息。详细信息如下表所示：<br><img src="https://i.loli.net/2018/09/13/5b99fc6a1c7b0.png" alt="1.png"></p>
<h1 id="OpenFlow连接建立交互流程"><a href="#OpenFlow连接建立交互流程" class="headerlink" title="OpenFlow连接建立交互流程"></a>OpenFlow连接建立交互流程</h1><p><img src="https://i.loli.net/2018/09/13/5b99fd98251f8.png" alt="2.png"><br>在OpenFlow1.3协议的情况下，控制器与OpenFlow交换机的消息完整交互流程如下：<br>1、 控制器与OpenFlow交换机通过TCP“三次握手”，建立有效的连接。其中，控制器一端的端口号为6633。<br>2、 控制器与OpenFlow交换机之间相互发送Hello消息，用于协商双方的OpenFlow版本号。在双方支持的最高版本号不一致的情况下，协商的结果将以较低的OpenFlow版本为准。如果双方协商不一致，还会产生Error消息。<br>3、 控制器向OpenFlow交换机发送Features Request消息，请求OpenFlow交换机上传自己的详细参数。OpenFlow交换机收到请求后，向控制器发送Features Reply消息，详细汇报自身参数，包括支持的buffer数目、流表数以及Actions等。<br>4、 控制器通过Set Config消息下发配置参数，然后通过Get config Request消息请求OpenFlow交换机上传修改后的配置信息。OpenFlow交换机通过Get config Reply消息向控制器发送当前的配置信息。<br>5、 控制器与OpenFlow交换机之间发送Packet_out、Packet_in消息，通过Packet_out中内置的LLDP包，进行网络拓扑的探测。<br>6、 控制器与OpenFlow交换机之间通过发送Multipart Request、Mutipart Reply消息，控制器能获取OpenFlow交换机的状态信息，包括流的信息、端口信息等。<br>7、 控制器与OpenFlow交换机之间通过发送Echo Request、Echo Reply消息，保证二者之间存在有效连接，避免失联。  </p>
<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/13/5b9a0b09e2b9b.png" alt="3.png"></p>
<h1 id="捕获数据包"><a href="#捕获数据包" class="headerlink" title="捕获数据包"></a>捕获数据包</h1><p>步骤1 登录Floodlight控制器，启动抓包工具Wireshark，捕获控制器与交换机建立连接过程中的数据包，通过分析这些数据包了解控制器与交换机基于OpenFlow协议进行交互的流程。执行以下命令：</p>
<blockquote>
</blockquote>
<pre><code>sudo wireshark
</code></pre><p>步骤2 双击eth0网卡，查看eth0网卡上数据包收发情况，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ba6a9fb7.png" alt="4.png"><br>步骤3 登录Mininet虚拟机，启动Mininet。通过“—controller”参数设置Mininet连接远程控制器，并指定控制器的IP和端口号。</p>
<blockquote>
</blockquote>
<pre><code>sudo mn --controller=remote,ip=30.0.1.3,port=6633 --switch=ovsk,protocols=OpenFlow13
</code></pre><p><img src="https://i.loli.net/2018/09/13/5b9a0bf62d0be.png" alt="5.png"><br>步骤4 登录Floodlight控制器，停止Wireshark，观察数据包列表，可以看出控制器与交换机的基本交互流程。<br><img src="https://i.loli.net/2018/09/13/5b9a0c1ddbc4e.png" alt="6.png"></p>
<h1 id="OpenFlow1-3交互流程分析"><a href="#OpenFlow1-3交互流程分析" class="headerlink" title="OpenFlow1.3交互流程分析"></a>OpenFlow1.3交互流程分析</h1><p>步骤1 交换机连接控制器的6633端口，经过3次握手后双方建立TCP连接。查看捕获到的数据包，分析交换机与控制器建立TCP连接的流程。分析TCP连接建立过程，需要先了解TCP的状态位，主要包括SYN、FIN、ACK、PSH、RST和URG。SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。可以看出交换机与控制器经历一次连接重置后，成功完成三次握手，建立TCP连接，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c63cdbf7.png" alt="7.png"><br>步骤2 当控制器与交换机建立TCP连接后，由其中某一方发起Hello消息，双方协调协OpenFlow议版本号。控制器和交换机都会向对方发送一条Hello消息，消息中附上自己支持的OpenFlow的最高版本。接收到对方Hello消息后，判断自己能否支持对方发送的版本，能支持则版本协商成功，不能支持则回复一条OFPT_ERROR消息。查看Hello消息详情，本实验中由于交换机和控制器都能支持OpenFlow1.3版本，所以版本协商为1.3，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c8900db0.png" alt="8.png"><br>步骤3 OpenFlow版本协商完成后，控制器发送一条features_request消息获取交换机的特性信息，包括交换机的ID（DPID）、缓冲区数量、端口及端口属性等等。相应的，交换机回复features_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0cb6bf243.png" alt="9.png"><br>查看数据包详情，ofpt_feature_request消息只有包头，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ce6d0540.png" alt="10.png"><br>ofpt_feature_reply数据包详情如下，交换机的DPID是数据通道独一无二的标识符，低48位是一个MAC地址，高16位是自定义的。本实验中交换机缓冲区数量（n_buffers）为256，交换机支持的流表数量（n_tables）为254，交换机所支持的功能，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d1008f0a.png" alt="11.png"><br>步骤4 OpenFlow1.0协议中feature_reply消息还包含交换机端口信息，OpenFlow 1.3协议将‘stats’框架更名为‘multipart’框架，并且将端口描述移植到multipart消息中。其中OPPT_PORT_DESC类型的multipart消息就是用于获取交换机端口信息的。<br><img src="https://i.loli.net/2018/09/13/5b9a0d34705f8.png" alt="12.png"><br>查看OPPT_PORT_DESC类型multipart_reply消息，消息中列出了交换机的端口以及每个端口的详细信息，包括端口名称和mac地址等，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d5f30b72.png" alt="13.png"><br>步骤5 OFPMP_DESC类型的multipart_reply消息包含了交换机的其他信息，包括交换机厂商名称、交换机名称以及交换机版本等。本实验中使用的是Mininet仿真软件中自带的开源交换机Open vSwitch(2.0.2)，而Open vSwitch是由Nicira Networks主导开发的，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d8d31133.png" alt="14.png"><br>步骤6 在连接过程中，控制器不断的发送echo_request消息给交换机，确认交换机与控制器之间的连接状态。相应的，交换机会回复echo_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0db731025.png" alt="15.png"></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理</title>
    <url>/2019/01/26/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>最近我用国内阿里云的服务器搭建了几个站点，但是由于没有备案所以只能采用域名+端口的方式访问，这样访问起来很别扭，于是就想到了使用Nginx反向代理。</p>
<h1 id="环境简介"><a href="#环境简介" class="headerlink" title="环境简介"></a>环境简介</h1><p><img src="https://i.loli.net/2019/01/26/5c4c0e2cc5892.png" alt="00.png"><br>做了一个简陋的拓扑图说明一下，图中的两台服务器都是处于公网的vps，都具有公网的ip地址，其中WEB服务器就是我在阿里云的未备案的vps，另一台是一台位于境外的vps，这里用来做Nginx反向代理。</p>
<h1 id="在代理服务器安装nginx"><a href="#在代理服务器安装nginx" class="headerlink" title="在代理服务器安装nginx"></a>在代理服务器安装nginx</h1><p>安装所需环境，详细的安装步骤可以参考<a href="https://www.cnblogs.com/kaid/p/7640723.html" target="_blank" rel="noopener">这里</a>：</p>
<blockquote>
</blockquote>
<pre><code>yum install gcc zlib zlib-devel openssl openssl-devel -y
</code></pre><p>下载nginx安装包：</p>
<blockquote>
</blockquote>
<pre><code>wget -c https://nginx.org/download/nginx-1.10.1.tar.gz
</code></pre><p>解压：</p>
<blockquote>
</blockquote>
<pre><code>tar -zxvf nginx-1.10.1.tar.gz
cd nginx-1.10.1
</code></pre><p>使用默认配置：</p>
<blockquote>
</blockquote>
<pre><code>./configure
</code></pre><p>编译安装：</p>
<blockquote>
</blockquote>
<pre><code>make
make install
</code></pre><p>查找安装路径：</p>
<blockquote>
</blockquote>
<pre><code>whereis nginx
</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1167725ea.png" alt="01.png"></p>
<p>根据回显的信息进入安装路径，在nginx目录下有以下文件，我们主要用到的是sbin(执行程序)和conf(配置文件)两个文件夹：<br><img src="https://i.loli.net/2019/01/26/5c4c1276be783.png" alt="02.png"><br>nginx常用命令：</p>
<blockquote>
</blockquote>
<pre><code>./nginx #启动nginx
./nginx -s stop #此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程
./nginx -s quit #此方式停止步骤是待nginx进程处理任务完毕进行停止
./nginx -s reload #重载配置文件
./nginx -v #查看版本信息
</code></pre><p>执行在sbin目录下执行./nginx启动Nginx，访问此vps的ip地址出现如下页面说明安装成功：<br><img src="https://i.loli.net/2019/01/26/5c4c1514634dd.png" alt="03.png"><br>设置开机启动：</p>
<blockquote>
</blockquote>
<pre><code>vi /etc/rc.local
</code></pre><p>增加一行：/usr/local/nginx/sbin/nginx<br>设置执行权限：</p>
<blockquote>
</blockquote>
<pre><code>chmod 755 rc.local
</code></pre><h1 id="配置代理服务器"><a href="#配置代理服务器" class="headerlink" title="配置代理服务器"></a>配置代理服务器</h1><p>这里有两种配置方法，一种是反向代理单个域名，通过这一个域名访问WEB服务器的单一服务；另一种则是代理多个域名，访问相应的域名时将请求代理到响应ip的响应端口。</p>
<h2 id="代理单个域名"><a href="#代理单个域名" class="headerlink" title="代理单个域名"></a>代理单个域名</h2><p>编辑默认配置文件：</p>
<blockquote>
</blockquote>
<pre><code>vim /usr/local/nginx/conf/nginx.conf
</code></pre><p>将以下内容添加到如下图所示的部分：</p>
<blockquote>
</blockquote>
<pre><code>proxy_pass http://172.18.78.14:6080;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection &quot;Upgrade&quot;;
</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1914b6b3b.png" alt="04.png"></p>
<p>重载配置：</p>
<blockquote>
</blockquote>
<pre><code>./nginx -s reload
</code></pre><p>最后将域名解析到代理服务器的ip地址即可。</p>
<h2 id="代理多个域名"><a href="#代理多个域名" class="headerlink" title="代理多个域名"></a>代理多个域名</h2><p>因为代理多个域名配置较多，我们新建一个配置文件方便查看：</p>
<blockquote>
</blockquote>
<pre><code>vim /usr/local/nginx/conf/reverse-proxy.conf
</code></pre><p>粘贴如下内容：</p>
<blockquote>
</blockquote>
<pre><code>server {
    listen 80;
    server_name a.test.com;
    location /{
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://127.0.0.1:8081;
        #proxy_pass http://tomcat;
    }
    access_log logs/tomcat1_access.log;
}
server {
    listen 80;
    server_name b.test.com;
    location /{
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://127.0.0.1:8082;
        #proxy_pass http://tomcat;
    }
    access_log logs/tomcat2_access.log;
}
</code></pre><p>需要注意的是，我在一开始的配置时同时代理了主域名即子域名，即test.com和a.test.com，这样配置的结果就是主域名无法进行代理，这种情况下如果还想使用主域名，可以使用www域名，即同时代理<a href="http://www.test.com和a.test.com等。" target="_blank" rel="noopener">www.test.com和a.test.com等。</a>  </p>
<p>修改nginx.conf,导入刚才写的配置,在http{}中加入如下内容：</p>
<blockquote>
</blockquote>
<pre><code>include reverse-proxy.conf;
</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1d8b15629.png" alt="05.png"></p>
<p>最后重载配置即可：</p>
<blockquote>
</blockquote>
<pre><code>./nginx -s reload
</code></pre>]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mininet的安装配置</title>
    <url>/2018/06/24/Mininet%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h1><h2 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a>系统选择</h2><p>镜像建议使用16.04的版本，mininet官网有说明，是因为16.04支持新版本的openflow等协议，我这里使用的是“ubuntu-16.04-server-amd64.iso”，server版本更加稳定。</p>
<h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><h3 id="设置网卡"><a href="#设置网卡" class="headerlink" title="设置网卡"></a>设置网卡</h3><p>因为要使用ssh远程登录，这里我们添加一个网卡：<br><img src="https://i.loli.net/2018/06/24/5b2ef5cbec5f1.png" alt="01.png"><br>勾选“启用网络连接”，并选择仅主机模式。</p>
<h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>挂载镜像之后启动虚拟机进行安装，基本的安装过程不一一详细介绍，不会的地方可以百度。<br><img src="https://i.loli.net/2018/06/24/5b2ef77a37059.png" alt="02.png"><br>可以看到安装程序已经识别出了两块网卡，我们选择默认的nat网卡作为主网络接口。<br><img src="https://i.loli.net/2018/06/24/5b2ef9a7a101d.png" alt="03.png"><br>软件安装，我们只需要安装ssh server就可以了，记得空格选择，回车确认。  </p>
<p>安装完成后，我们看一下系统的网卡信息，发现并没有我们添加的网卡。<br><img src="https://i.loli.net/2018/06/24/5b2efcabda76f.png" alt="04.png"><br>执行“sudo dhclient enp0s8”启用enp0s8网卡。<br>再次查看网卡信息：<br><img src="https://i.loli.net/2018/06/24/5b2efed26c4cc.png" alt="05.png"><br>可以看到已经添加进来了。我们还需要将第二块网卡的配置加入到网络配置文件中，不然重启之后第二块网卡还是看不到的：  </p>
<blockquote>
</blockquote>
<pre><code>sudo vi /etc/network/interfaces
</code></pre><p>在interfaces配置文件中加入enp0s8，同样使用dhcp方式获取ip<br><img src="https://i.loli.net/2018/06/24/5b2efffbe249f.png" alt="06.png"><br>至此，我们的系统就配置完成了，用ssh工具进行连接：<br><img src="https://i.loli.net/2018/06/24/5b2f00ad250a3.png" alt="07.png"><br>已经可以成功连接。</p>
<h1 id="安装Ryu"><a href="#安装Ryu" class="headerlink" title="安装Ryu"></a>安装Ryu</h1><p>详细内容可参考<a href="http://linton.tw/2014/02/15/note-install-ryu-36-sdn-framework/" target="_blank" rel="noopener">linton的博客</a>。</p>
<p>1.下载python的套件库，并更新pip（因为下载的pip并不是最新版本）</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install python-pip python-dev build-essential
sudo pip install --upgrade pip
</code></pre><p>2.安装Ryu相依性套件</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install python-eventlet
sudo apt-get install python-routes
sudo apt-get install python-webob
sudo apt-get install python-paramiko
</code></pre><p>3.使用pip下载并安装Ryu</p>
<blockquote>
</blockquote>
<pre><code>sudo pip install ryu
</code></pre><p>此步骤如果出现如下错误信息说明你被挡在城内了，富强上网即可解决。<br><img src="https://i.loli.net/2018/06/24/5b2f22b8832fc.png" alt="需要富强上网.png"><br>4.如果需要使用Ryu with GUI则进行此步骤：下载Ryu source code（需要使用git套件）</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install git
git clone https://github.com/osrg/ryu.git
</code></pre><p>5.完成安装，执行ryu-manager验证有没有出现错误，没问题的话会出现如下信息：<br><img src="https://i.loli.net/2018/06/24/5b2f1ff8a73bd.png" alt="chenggong.png"></p>
<h1 id="安装mininet"><a href="#安装mininet" class="headerlink" title="安装mininet"></a>安装mininet</h1><h2 id="使用源码安装mininet"><a href="#使用源码安装mininet" class="headerlink" title="使用源码安装mininet"></a>使用源码安装mininet</h2><p>为了减少之后不必要的麻烦，建议在安装开始前执行：sudo su切换到root用户下并在富强网络下进行安装。<br>1.升级系统</p>
<blockquote>
</blockquote>
<pre><code>apt-get update
apt-get upgrade
</code></pre><p>2.安装git（如果你像我一样在之前安装Ryu时我们已经安装过git了，那么请直接跳过此步骤）</p>
<blockquote>
</blockquote>
<pre><code>apt install git
</code></pre><p>3.从github上获取源码</p>
<blockquote>
</blockquote>
<pre><code>git clone git://github.com/mininet/mininet
</code></pre><p>获取之后可以使用如下命令查看mininet的版本</p>
<blockquote>
</blockquote>
<pre><code>cd mininet
cat INSTALL
</code></pre><p><img src="https://i.loli.net/2018/06/24/5b2f4c772e56f.png" alt="cat.png"><br>4.确认无误后，安装mininet</p>
<blockquote>
</blockquote>
<pre><code>util/install.sh -a
</code></pre><p>当你看到Enjoy Mininet！时，恭喜你已经安装成功了。<br><img src="https://i.loli.net/2018/06/24/5b2f4cb8a6bfc.png" alt="enjoy.png"><br>执行以下命令查看安装版本：</p>
<blockquote>
</blockquote>
<pre><code>mn --version
</code></pre><h2 id="mininet可视化操作"><a href="#mininet可视化操作" class="headerlink" title="mininet可视化操作"></a>mininet可视化操作</h2><p>1.要进行mininet可视化操作，需要安装Xmanager套件，然后在通过Xshell远程连接主机时，在属性中做如下设置：<br><img src="https://i.loli.net/2018/06/24/5b2f4a82c2097.png" alt="suidao.png"><br>2.然后进入examples目录，执行miniedit.py即可启动可视化界面</p>
<blockquote>
</blockquote>
<pre><code>cd mininet/mininet/examples
./miniedit.py
</code></pre><p><img src="https://i.loli.net/2018/06/24/5b2f4cf66b46e.png" alt="可视化.png"><br>至此，整个环境就搭建完成了。<br>如果是桌面版系统并且用apt-get install mininet安装的mininet,目录在/usr/share/doc/mininet/examples,但是其可视化脚本是py.gz格式的，需要解压缩使用。</p>
<blockquote>
</blockquote>
<pre><code>cd /usr/share/doc/mininet/examples
gunzip miniedit.py.gz
apt install python-tk
python miniedit.py
</code></pre>]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
        <tag>Mininet</tag>
      </tags>
  </entry>
  <entry>
    <title>Nova的16种操作</title>
    <url>/2019/04/03/Nova%E7%9A%8416%E7%A7%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160607-1465256704490062241.png" alt="00.png"></p>
<h1 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h1><h2 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h2><p>通过更改flavor调整分配给instance的资源。</p>
<h2 id="Lock-UnLock"><a href="#Lock-UnLock" class="headerlink" title="Lock/UnLock"></a>Lock/UnLock</h2><p>防止对instance的误操作。</p>
<h2 id="Pause-Suspend-Resume"><a href="#Pause-Suspend-Resume" class="headerlink" title="Pause/Suspend/Resume"></a>Pause/Suspend/Resume</h2><p>暂停当前的instance，并在以后恢复。<br>Pause 和 Suspend 的区别在于 Pause 将 instance 的运行状态保存在计算节点的内存中，而 Suspend 保存在磁盘上。</p>
<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>备份 instance 到 Glance。产生的 image 可用于故障恢复，或者以此为模板部署新的 instance。</p>
<h1 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h1><h2 id="计划内"><a href="#计划内" class="headerlink" title="计划内"></a>计划内</h2><h3 id="Migrate"><a href="#Migrate" class="headerlink" title="Migrate"></a>Migrate</h3><p>将 instance 迁移到其他计算节点。<br>迁移之前，instance 会被 Shut Off，支持共享存储和非共享存储。</p>
<h3 id="Live-Migrate"><a href="#Live-Migrate" class="headerlink" title="Live Migrate"></a>Live Migrate</h3><p>与 Migrate 不同，Live Migrate 能不停机在线地迁移 instance，保证了业务的连续性。也支持共享存储和非共享存储（Block Migration）</p>
<h3 id="Shelve-Unshelve"><a href="#Shelve-Unshelve" class="headerlink" title="Shelve/Unshelve"></a>Shelve/Unshelve</h3><p>Shelve 将 instance 保存到 Glance 上，之后可通过 Unshelve 重新部署。<br>Shelve 操作成功后，instance 会从原来的计算节点上删除。<br>Unshelve 会重新选择节点部署，可能不是原节点。</p>
<h2 id="计划外"><a href="#计划外" class="headerlink" title="计划外"></a>计划外</h2><h3 id="Rescue-Unrescue"><a href="#Rescue-Unrescue" class="headerlink" title="Rescue/Unrescue"></a>Rescue/Unrescue</h3><p>用指定的启动盘启动，进入 Rescue 模式，修复受损的系统盘。成功修复后，通过 Unrescue 正常启动 instance。</p>
<h3 id="Rebuild"><a href="#Rebuild" class="headerlink" title="Rebuild"></a>Rebuild</h3><p>如果 Rescue 无法修复，则只能通过 Rebuild 从已有的备份恢复。 Instance 的备份是通过 snapshot 创建的，所以需要有备份策略定期备份。</p>
<h3 id="Evacuate"><a href="#Evacuate" class="headerlink" title="Evacuate"></a>Evacuate</h3><p>利用共享存储上 Instance 的镜像文件在其他计算节点上重建 Instance。<br>所以提前规划共享存储是关键。</p>
]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
        <tag>Nova</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的简单安装</title>
    <url>/2018/10/30/Nginx%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>过几天参加比赛要用到nginx的安装部署，写一个简单的安装方式，方便赛前温习。</p>
<h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><p>更新apt源：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get update
</code></pre><p>安装nginx：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install nginx
</code></pre><p>使用这种方法，apt-get会自动安装好nginx和依赖组件。  </p>
<p>执行如下命令查看nginx进程是否启动：</p>
<blockquote>
</blockquote>
<pre><code>ps -ef | grep nginx
</code></pre><p>打开浏览器，在地址栏输入localhost，就会出现如下的欢迎页面，表示nginx安装成功。<br><img src="http://112.80.35.35:40010/site_media/media/course/096bc012-db2f-4c2b-a983-bbf7056af08e/network/%E5%9B%BE%E7%89%87_MVR9Prv.png" alt="01.png"></p>
<h1 id="Nginx安装路径"><a href="#Nginx安装路径" class="headerlink" title="Nginx安装路径"></a>Nginx安装路径</h1><blockquote>
</blockquote>
<pre><code>whereis nginx
</code></pre><h1 id="搭建简单静态服务器"><a href="#搭建简单静态服务器" class="headerlink" title="搭建简单静态服务器"></a>搭建简单静态服务器</h1><p>在nginx安装目录下找到nginx.conf文件，打开并编辑，在http节点下增加如下内容：<br><img src="http://112.80.35.35:40010/site_media/media/course/096bc012-db2f-4c2b-a983-bbf7056af08e/network/%E5%9B%BE%E7%89%87_DEfprYK.png" alt="02.png"><br>root /home/openlab这里填写你的静态文件存储根目录。  </p>
<p>找到nginx程序所在的目录，执行nginx -s reload命令，重新加载Nginx配置文件。  </p>
<p>root /home/openlab这里填写你的静态文件存储根目录。</p>
]]></content>
      <categories>
        <category>服务器应用</category>
      </categories>
      <tags>
        <tag>Web服务器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Cisco配置VPN IPSec</title>
    <url>/2019/03/28/Cisco%E9%85%8D%E7%BD%AEVPN-IPSec/</url>
    <content><![CDATA[<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2019/03/28/5c9c3006a1ccd.png" alt="00.png"></p>
<h1 id="配置运营商网络"><a href="#配置运营商网络" class="headerlink" title="配置运营商网络"></a>配置运营商网络</h1><p>在配置VPN之前，首先要保证模拟的运营商网络是可以正常通信的，这里我配置的是OSPF，需要注意的是两边的路由器不要把内网网段也给宣告出去了，如果是这样那VPN也就没有存在的意义了。<br>首先是左边的R1：</p>
<blockquote>
</blockquote>
<pre><code>Router(config)#int f0/0
Router(config-if)#ip add 202.1.1.1 255.255.255.0
Router(config-if)#no shut
Router(config-if)#exit
Router(config)#router ospf 1
Router(config-router)#net 202.1.1.0 0.0.0.255 area 0
</code></pre><p>中间的R0：</p>
<blockquote>
</blockquote>
<pre><code>Router(config)#int f0/0
Router(config-if)#ip add 202.1.1.254 255.255.255.0
Router(config-if)#no shut
Router(config)#int f0/1
Router(config-if)#ip add 210.1.1.254 255.255.255.0
Router(config-if)#no shut
Router(config-if)#exit
Router(config)#router ospf 1
Router(config-router)#net 202.1.1.0 0.0.0.255 area 0
Router(config-router)#net 210.1.1.0 0.0.0.255 area 0
</code></pre><p>右边的R2：</p>
<blockquote>
</blockquote>
<pre><code>Router(config)#int f0/0
Router(config-if)#ip add 210.1.1.1 255.255.255.0
Router(config-if)#no shut
Router(config-if)#exit
Router(config)#router ospf 1
Router(config-router)#net 210.1.1.0 0.0.0.255 area 0
</code></pre><p>等待收敛完成验证网络是否可以正常通信。</p>
<h1 id="配置内网"><a href="#配置内网" class="headerlink" title="配置内网"></a>配置内网</h1><p>内网过于简单这里不再赘述，我的左边的区域1的网段是10.0.1.0/24，右边的区域2是10.0.2.0/24，网关则分别为1.1和2.1。</p>
<h1 id="配置IPSec-site-to-site"><a href="#配置IPSec-site-to-site" class="headerlink" title="配置IPSec(site to site)"></a>配置IPSec(site to site)</h1><p>R1:</p>
<blockquote>
</blockquote>
<pre><code>Router(config)#crypto isakmp enable #启用IKE,默认即为启动
Router(config)#crypto isakmp policy 1 #定义IKE安全策略集1
Router(config-isakmp)#authentication pre-share #IKE验证方式胃预共享密钥
Router(config-isakmp)#encryption 3des #IKE加密方式为3des
Router(config-isakmp)#group 1 #IKE使用Diffie-Hellman组1
Router(config-isakmp)#hash md5 #IKE的Hash验证为MD5
Router(config-isakmp)#exit
Router(config)#crypto isakmp key cyne address 210.1.1.1 #两端的KEY必须一致，210.1.1.1是对端的公网地址
Router(config)#crypto ipsec transform-set lab ah-md5-hmac esp-3des #定义VPN使用IPSec策略集，lab为策略集名称
Router(config)#access-list 100 permit ip 10.0.1.0 0.0.0.255 10.0.2.0 0.0.0.255 #定义在R1上需要加密的流量
Router(config)#crypto map test 110 ipsec-isakmp #定义加密图
Router(config-crypto-map)#match address 100 #在加密图中声明加密流量列表
Router(config-crypto-map)#set peer 210.1.1.1 #对端公网ip
Router(config-crypto-map)#set transform-set lab #在加密图中调用IPSec的策略集lab
Router(config-crypto-map)#exit
Router(config)#int f0/0
Router(config-if)#crypto map test #将加密图应用到此端口
Router(config-if)#exit 
Router(config)#ip route 10.0.2.0 255.255.255.0 f0/0 #指定VPN的静态路由
</code></pre><p>R2:</p>
<blockquote>
</blockquote>
<pre><code>Router(config)#crypto isakmp enable
Router(config)#crypto isakmp policy 1
Router(config-isakmp)#authentication pre-share 
Router(config-isakmp)#encryption 3des
Router(config-isakmp)#group 1
Router(config-isakmp)#hash md5
Router(config-isakmp)#exit
Router(config)#crypto isakmp key cyne address 202.1.1.1 #两端的KEY必须一致，202.1.1.1是对端的公网地址
Router(config)#crypto ipsec transform-set lab ah-md5-hmac esp-3des
Router(config)#access-list 100 permit ip 10.0.2.0 0.0.0.255 10.0.1.0 0.0.0.255
Router(config)#crypto map test 110 ipsec-isakmp 
Router(config-crypto-map)#match address 100 
Router(config-crypto-map)#set peer 202.1.1.1 #对端公网ip
Router(config-crypto-map)#set transform-set lab
Router(config-crypto-map)#exit
Router(config)#int f0/0
Router(config-if)#crypto map test
Router(config-if)#exit 
Router(config)#ip route 10.0.1.0 255.255.255.0 f0/0
</code></pre><h1 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h1><p>使用区域1内的PC ping 区域2中的PC，发现已经可以通信：<br><img src="https://i.loli.net/2019/03/28/5c9c3cfee86a3.png" alt="01.png"></p>
<h1 id="NAT-IPSec-VPN"><a href="#NAT-IPSec-VPN" class="headerlink" title="NAT + IPSec VPN"></a>NAT + IPSec VPN</h1><p>NAT和IPSec存在一些不兼容的情况，比如NAT更改了IP头部中的源地址和目的地址，校验和会被重新计算并修改，所以导致被对端IPSec丢弃等等。  </p>
<p>那如果配置了NAT之后应该如何让IPSec正常工作呢？今天在敲实验的时候思考了很久，最后找到了通过更改ACL也就是更改IPSec的“感兴趣”流量来解决，简单拓扑如下：<br><img src="https://i.loli.net/2019/06/25/5d121572efee411287.png" alt="21.png"><br>两端公网接入路由器的ACL进行如下配置：</p>
<blockquote>
</blockquote>
<pre><code>R1#sh access-lists 100
Extended IP access list 100
    permit ip 172.16.5.0 0.0.0.255 172.16.2.0 0.0.0.255
    permit ip 172.16.2.0 0.0.0.255 218.18.1.0 0.0.0.3
    permit ip 218.18.1.0 0.0.0.3 172.16.2.0 0.0.0.255
</code></pre><blockquote>
</blockquote>
<pre><code>R2#sh access-lists 100
Extended IP access list 100
    permit ip 172.16.2.0 0.0.0.255 172.16.5.0 0.0.0.255
    permit ip host 218.18.1.2 172.16.2.0 0.0.0.255
    permit ip 172.16.2.0 0.0.0.255 218.18.1.0 0.0.0.3
</code></pre><p>上述ACL的作用也就是把NAT之后的公网IP地址加入到IPSec的感兴趣流量中。当然，这也只是我在实验中自己摸索的解决方法。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://wenku.baidu.com/view/aec4df5a5727a5e9856a61eb" target="_blank" rel="noopener">https://wenku.baidu.com/view/aec4df5a5727a5e9856a61eb</a><br><a href="http://www.solves.com.cn/doc-view-2025.html" target="_blank" rel="noopener">http://www.solves.com.cn/doc-view-2025.html</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>VPN</tag>
        <tag>IPSec</tag>
      </tags>
  </entry>
  <entry>
    <title>SDN中的南向接口和北向接口</title>
    <url>/2018/09/11/SDN%E4%B8%AD%E7%9A%84%E5%8D%97%E5%90%91%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%8C%97%E5%90%91%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="SDN的意义"><a href="#SDN的意义" class="headerlink" title="SDN的意义"></a>SDN的意义</h1><p>SDN网络的最终目标是服务于多样化的业务应用创新。因此随着SDN技术的部署和推广，将会有越来越多的业务应用被研发，这类应用将能够便捷地通过SDN北向接口调用底层网络能力，按需使用网络资源。  </p>
<p>SDN推动业务创新已经是业界不争的事实，它可以被广泛地应用在云数据中心、宽带传输网络、移动网络等种种场景中，其中为云计算业务提供网络资源服 务就是一个非常典型的案例。众所周知，在当前的云计算业务中，服务器虚拟化、存储虚拟化都已经被广泛应用，它们将底层的物理资源进行池化共享，进而按需分配给用户使用。相比之下，传统的网络资源远远没有达到类似的灵活性，而SDN的引入则能够很好地解决这一问题。</p>
<h1 id="南向接口"><a href="#南向接口" class="headerlink" title="南向接口"></a>南向接口</h1><p>SDN通过标准的南向接口屏蔽了底层物理转发设备的差异，实现了资源的虚拟化，同时开放了灵活的北向接口供上层业务按需进行网络配置并调用网络资源。  </p>
<p>云计算领域中知名的OpenStack就是可以工作在SDN应用层的云管理平台，通过在其网络资源管理组件中增加SDN管理插件，管理者和使用者可利 用SDN北向接口便捷地调用SDN控制器对外开放的网络能力。当有云主机组网需求(例如建立用户专有的VLAN)被发出时，相关的网络策略和配置可以在 OpenStack管理平台的界面上集中制定并进而驱动SDN控制器统一地自动下发到相关的网络设备上。  </p>
<p>当前，最知名的南向接口莫过于ONF倡导的OpenFlow协议。作为一个开放的协议，OpenFlow突破了传统网络设备厂商对设备能力接口的壁垒，经过多年的发展，在业界的共同努力下，当前已经日臻完善，能够全面解决SDN网络中面临的各种问题。  </p>
<p>因此，网络资源可以和其他类型的虚拟化资源一样，以抽象的资源能力的面貌统一呈现给业务应用开发者，开发者无需针对底层网络设备的差异耗费大量开销从事额外的适配工作，这有助于业务应用的快速创新。</p>
<h1 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h1><p>控制层是SDN的大脑，负责对底层转发设备的集中统一控制，同时向上层业务提供网络能力调用的接口，在SDN架构中具有举足轻重的作用，SDN控制 器也是SDN关注的焦点。从技术实现上看，控制器除了南向的网络控制和北向的业务支撑外，还需要关注东西的扩展，以避免SDN集中控制导致的性能和安全瓶颈问题，SDN控制器也在南向、北向、东西向上引入了相应的核心技术，有效解决与各层通信以及控制集群横向扩展的难题。  </p>
<p>当前，业界有很多基于OpenFlow控制协议的开源的控制器实现，例如NOX、Onix、Floodlight等，它们都有各自的特色设计，能够实现链路发现、拓扑管理、策略制定、表项下发等支持SDN网络运行的基本操作。虽然不同的控制器在功能和性能上仍旧存在差异，但是从中已经可以总结出SDN控制器应当具备的技术特征，从这些开源系统的研发与实践中得到的经验和教训将有助于推动SDN控制器的规范化发展。  </p>
<p>另外，用于网络集中化控制的控制器作为SDN网络的核心，其性能和安全性非常重要，其可能存在的负载过大、单点失效等问题一直是SDN领域中亟待解决的问题。当前，业界对此也有了很多探讨，从部署架构、技术措施等多个方面提出了很多有创见的方法。  </p>
<p>SDN控制器对网络的控制主要是通过南向接口协议实现,包括链路发现、拓扑管理、策略制定、表项下发等，其中链路发现和拓扑管理主要是控制其利用南 向接口的上行通道对底层交换设备上报信息进行统一监控和统计;而策略制定和表项下发则是控制器利用南向接口的下行通道对网络设备进行统一控制。</p>
<h1 id="北向接口"><a href="#北向接口" class="headerlink" title="北向接口"></a>北向接口</h1><p>SDN北向接口是通过控制器向上层业务应用开放的接口，其目标是使得业务应用能够便利地调用底层的网络资源和能力。通过北向接口，网络业务的开发者 能以软件编程的形式调用各种网络资源;同时上层的网络资源管理系统可以通过控制器的北向接口全局把控整个网网络的资源状态，并对资源进行统一调度。因为北 向接口是直接为业务应用服务的，因此其设计需要密切联系业务应用需求，具有多样化的特征。同时，北向接口的设计是否合理、便捷，以便能被业务应用广泛调用，会直接影响到SDN控制器厂商的市场前景。  </p>
<p>与南向接口方面已有OpenFlow等国际标准不同，北向接口方面还缺少业界公认的标准，因此，北向接口的协议制定成为当前SDN领域竞争的焦点， 不同的参与者或者从用户角度出发，或者从运营角度出发，或者从产品能力角度出发提出了很多方案。据悉,目前至少有20种控制器,每种控制器会对外提供北向 接口用于上层应用开发和资源编排。虽然北向接口标准当前还很难达成共识，但是充分的开放性、便捷性、灵活性将是衡量接口优劣的重要标准，例如REST API就是上层业务应用的开发者比较喜欢的接口形式。部分传统的网络设备厂商在其现有设备上提供了编程接口供业务应用直接调用，也可被视作是北向接口之一，其目的是在不改变其现有设备架构的条件下提升配置管理灵活性，应对开放协议的竞争。</p>
<h1 id="SDN交换机"><a href="#SDN交换机" class="headerlink" title="SDN交换机"></a>SDN交换机</h1><p>SDN的核心理念之一就是将控制功能从网络设备中剥离出来，通过中央控制器实现网络可编程，从而实现资源的优化利用，提升网络管控效率。  </p>
<p>工作在基础设施层的SDN交换机虽然不在需要对逻辑控制进行过多考虑，但作为SDN网络中负责具体数据转发处理的设备，为了完成高速数据转发，还是 要遵循交换机工作原理。本质上看，传统设备中无论是交换机还是路由器，其工作原理都是在收到数据包时，将数据包中的某些特征域与设备自身存储的一些表项进 行比对，当发现匹配时则按照表项的要求进行相应处理。SDN交换机也是类似的原理，但是与传统设备存在差异的是，设备中的各个表项并非是由设备自身根据周 边的网络环境在本地自行生成的，而是由远程控制器统一下发的，因此各种复杂的控制逻辑(例如链路发现、地址学习、路由计算等等)都无需在SDN交换机中实现。  </p>
<p>SDN交换机可以忽略控制逻辑的实现，全力关注基于表项的数据处理，而数据处理的性能也就成为评价SDN交换机优劣的最关键指标，因此，很多高性能 转发技术被提出，例如基于多张表以流水线方式进行高速处理的技术。另外，考虑到SDN和传统网络的混合工作问题，支持混合模式的SDN交换机也是当前设备 层技术研发的焦点。同时，随着虚拟化技术的出现和完善，虚拟化环境将是SDN交换机的一个重要应用场景，因此SDN交换机可能会有硬件、软件等多种形态。 例如，OVS(Open vSwitch，开放虚拟交换标准)交换机就是一款基于开源软件技术实现的能够集成在服务器虚拟化Hypervisor中的交换机，具备完善的交换机功能，在虚拟化组网中起到了非常重要的作用。  </p>
<p>SDN交换机的出现，对传统的网络设备厂商造成了最直接的威胁，如何将新兴的网络技术与传统设备产品的优势相融合，是这些厂商正在苦苦思索的问题。 虽然SDN交换机已经对传统的网络产业链造成了巨大的冲击，但是仅凭单独的数据转发设备还不足以支撑起整个SDN的天空，未来更激烈地竞争必将会在SDN的控制层和应用层发生。</p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的str.format</title>
    <url>/2018/03/25/Python%E4%B8%AD%E7%9A%84str-format/</url>
    <content><![CDATA[<h1 id="str-format-的引入"><a href="#str-format-的引入" class="headerlink" title="str.format 的引入"></a>str.format 的引入</h1><p>在 Python 中，我们可以使用 + 来连接字符串，在简单情况下这种方式能够很好的工作。但是当我们需要进行复杂的字符串连接时，如果依然使用 + 来完成，不仅会使代码变得晦涩难懂，还会让代码变得难以维护，此时这种方式就显得力不从心了。<br><br>例如，我们想打印这样一条记录：<br></p>
<blockquote>
</blockquote>
<pre><code>User:John has completed Action:payment at Time:13:30:00  
</code></pre><p>如果使用加号实现，会是下面这种形式：<br></p>
<blockquote>
</blockquote>
<pre><code>print &quot;User:&quot; + user_name + &quot; has completed Action:&quot; + \ 
action_name + &quot; at Time:&quot; + current_time
</code></pre><p>如果以后回过头来阅读这段代码，我们很难直观看出它的输出格式，且修改起来也相对麻烦。<br>我们可以换用 % 来实现：<br></p>
<blockquote>
</blockquote>
<pre><code>print &quot;User:%s has completed Action:%s at Time:%s&quot; %\ 
(user_name, action_name, current_time)
</code></pre><p>这回代码变得清晰简洁多了。<br>不过，Python 为我们提供了另一种简洁优雅的实现方式，也是官方更加推荐的方式：<br><br>&nbsp;&nbsp;&nbsp;&nbsp;使用 str.format() 来实现字符串的格式化：</p>
<blockquote>
</blockquote>
<pre><code>print &quot;User:{} has completed Action:{} at Time:{}&quot;.format( 
user_name, action_name, current_time)
</code></pre><p>str.format 既能够用于简单的场景，也能够胜任复杂的字符串替换，而无需繁琐的字符串连接操作。Python 的内置类型 str 和 unicode 均支持使用 str.format() 来格式化字符串。<br>我们接下来就详细地讨论 str.format() 的具体用法。</p>
<h1 id="str-format-基本语法"><a href="#str-format-基本语法" class="headerlink" title="str.format 基本语法"></a>str.format 基本语法</h1><p>格式化字符串使用花括号 {} 来包围替换字段，也就是待替换的字符串。而未被花括号包围的字符会原封不动地出现在结果中。</p>
<h2 id="使用位置索引"><a href="#使用位置索引" class="headerlink" title="使用位置索引"></a>使用位置索引</h2><p>以下两种写法是等价的：<br>“Hello, {} and {}!”.format(“John”, “Mary”)<br>“Hello, {0} and {1}!”.format(“John”, “Mary”)<br>花括号内部可以写上目标字符串的索引，也可以省略。如果省略，则按 format 括号里的目标字符串顺序依次替换。</p>
<h2 id="使用关键字索引"><a href="#使用关键字索引" class="headerlink" title="使用关键字索引"></a>使用关键字索引</h2><p>除了通过位置来指定目标字符串，我们还可以通过关键字来指定它。<br><br>例如：</p>
<blockquote>
</blockquote>
<p>“Hello, {boy} and {girl}!”.format(boy=”John”, girl=”Mary”)</p>
<p>使用关键字索引的好处是，我们无需关心参数的位置，且字符串的最终结果能够一目了然。在以后的代码维护中，我们能够快速地修改对应的参数，而不用对照字符串挨个去寻找相应的参数。<br>注意：如果字符串本身含有花括号，则需要将其重复两次来转义。例如，字符串本身含有 &#123; ，为了让 Python 知道这是一个普通字符，而不是用于包围替换字段的花括号，我们只需将它改写成 &#123;&#123; 即可。</p>
<h1 id="str-format-高级语法"><a href="#str-format-高级语法" class="headerlink" title="str.format 高级语法"></a>str.format 高级语法</h1><p>str.format 非常强大，足以完成日常工作中遇到的格式化输出。熟练掌握该方法，能够为以后的字符串处理打好基础，还能节省不少时间。</p>
<h2 id="访问参数的属性或元素"><a href="#访问参数的属性或元素" class="headerlink" title="访问参数的属性或元素"></a>访问参数的属性或元素</h2><p>在使用 str.format 来格式化字符串时，我们通常将目标字符串作为参数传递给 format 方法。实际上，我们还可以在格式化字符串中访问参数的某个属性或某个元素：</p>
<blockquote>
</blockquote>
<pre><code>&quot;My car is {0.color}.&quot;.format(black_car)
&quot;The first student is {student[0]}.&quot;.format(student=stu_list)
&quot;John is {d[john]} years old.&quot;.format(d=age_dict)
</code></pre><h2 id="参数输出转换"><a href="#参数输出转换" class="headerlink" title="参数输出转换"></a>参数输出转换</h2><p>参数的字符串输出，默认是由其自身的 <strong>format</strong> 方法来实现的。也就是说<strong>Python</strong> 使用参数的 <strong>format</strong> 输出来取代替换字段。如果我们想调用 str() 或 repr() 来转换参数，可以通过添加转换标志来实现：</p>
<blockquote>
</blockquote>
<pre><code> call str() on argument
&quot;It&apos;s a {0!s}.&quot;
</code></pre><blockquote>
</blockquote>
<pre><code>call repr() on argument
&quot;We can get info from {name!r}.&quot;
</code></pre><h1 id="str-format-一般形式"><a href="#str-format-一般形式" class="headerlink" title="str.format 一般形式"></a>str.format 一般形式</h1><p>格式化字符串的一般形式如下：</p>
<blockquote>
</blockquote>
<pre><code>&quot;... {field_name!conversion:format_spec} ...&quot;
</code></pre><p>从上面的代码可以看到，格式化字符串可分为 field_name、conversion、format_spec 三部分，分别对应替换字段名称（索引）、转换标志、格式描述。其中，字段名称是必选的，而后两者是可选的。转换标志紧跟在英文感叹号后面，而格式描述紧跟在英文冒号后面。<br><br>前面已经提到过，字段名称既可是位置索引，也可是关键字索引。字段名称后面可以通过点来访问属性，或通过方括号来访问元素。<br><br>在这里，我们重点看一下格式描述（format_spec）这一项。<br>格式描述中含有6个选项，分别是 fill、align、sign、width、precision、type。 它们的位置关系如下：</p>
<blockquote>
</blockquote>
<pre><code>[[fill]align][sign][#][0][width][,][.precision][type]
</code></pre><blockquote>
<blockquote>
</blockquote>
<p>fill 可以是任意字符，默认为空格。<br><br>align 仅当指定最小宽度时有效。<br><br>&lt; 左对齐（默认选项）<br><br>“&gt;” 右对齐<br><br>= 仅对数字有效；将填充字符放到符号与数字间，例如 +0001234<br><br>^ 居中对齐<br><br>sign<br>仅对数字有效<br></p>
<ul>
<li>所有数字均带有符号<br></li>
</ul>
<ul>
<li>仅负数带有符号（默认选项）<br><br>&nbsp;即空格；正数前面带空格，负数前面带符号<br><br>‘#’ 只对整数有效<br>自动在二进制、八进制、十六进制数值前添加对应的 0b、0o、 0x。<br><br>‘,’<br>自动在每三个数字之间添加 , 分隔符。<br><br>width<br>十进制数字，定义最小宽度。如果未指定，则由内容的宽度来决定。<br>如果没有指定对齐方式（align），那么可以在 width 前面添加一个0来实现自动填充0，等价于 fill 设为 0 并且 align 设为 =。<br><br>precision<br>用于确定浮点数的精度，或字符串的最大长度。不可用于整型数值。<br><br>type<br>确定参数类型，默认为 s ，即字符串。<br><br>整数输出类型：<blockquote>
<blockquote>
</blockquote>
<p>b：以二进制格式输出<br><br>c：将整数转换成对应的 unicode 字符<br><br>d：以十进制输出（默认选项）<br><br>o：以八进制输出<br><br>x：以十六进制小写输出<br><br>X：以十六进制大写输出<br><br>n：与 d 相同，但使用当前环境的分隔符来分隔每3位数字<br><br>十进制浮点数输出类型：<br><br>e：指数标记；使用科学计数法输出，用e来表示指数部分，默认 precision 为6<br><br>E：与 e 相同，但使用大写 E 来表示指数部分<br><br>f：以定点形式输出数值，默认 precision 为6<br><br>F：与 f 相同<br><br>g：通用格式；对于给定的 precision p &gt;= 1，取数值的p位有效数字，并以定点或科学计数法输出（默认选项）<br><br>G：通用格式；与 g 相同，当数值过大时使用 E 来表示指数部分<br><br>n：与 g 相同，但使用当前环境的分隔符来分隔每3位数字<br><br>%：百分比标记；使用百分比的形式输出数值，同时设定 f 标记</p>
</blockquote>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SDN实验（二）——Open vSwitch</title>
    <url>/2018/10/16/SDN%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Open-vSwitch/</url>
    <content><![CDATA[<p>Open vSwitch是由Nicira Networks主导，运行在虚拟化平台（例如KVM，Xen）上的虚拟交换机。Open vSwitch基于C语言开发，遵循Apache 2.0许可证，能同时支持多种标准的管理接口和协议（比如NetFlow、sFlow、SPAN、RSPAN、CLI、LACP、802.1ag等）。Open vSwitch通过OpenFlow协议由统一的控制器管理，从而实现对接入的虚拟机（或设备）的网络联通。  </p>
<p>整体组网结构如下图：<br><img src="https://i.loli.net/2018/10/16/5bc592232631f.png" alt="01.png"><br>Open vSwitch内部架构图：<br><img src="https://i.loli.net/2018/10/16/5bc592a15b2de.png" alt="02.png"></p>
<blockquote>
<p><strong>ovs-vswtichd：</strong>主要模块，实现vswitch的守候进程daemon，包括一个支持流交换的Linux内核模块。<br><strong>ovsdb-server：</strong>轻量级数据库服务器，保存配置信息，ovs-vswitchd通过这个数据库获取配置信息。<br><strong>ovs-dpctl：</strong>用来配置vswitch内核模块的一个工具。<br><strong>ovs-vsctl：</strong>主要是获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。<br><strong>ovs-appctl：</strong>一个向ovs-vswtichd的守护进程发送命令的的程序。<br><strong>datapath：</strong>内核模块，根据流表匹配结果做相应处理。<br><strong>ovs-ofctl：</strong>查询和控制OpenFlow虚拟交换机的流表。</p>
</blockquote>
<h1 id="Open-vSwitch的安装"><a href="#Open-vSwitch的安装" class="headerlink" title="Open vSwitch的安装"></a>Open vSwitch的安装</h1><h1 id="Open-vSwitch网桥管理"><a href="#Open-vSwitch网桥管理" class="headerlink" title="Open vSwitch网桥管理"></a>Open vSwitch网桥管理</h1><p>在网络中，交换机和桥概念类似，Open vSwitch是一个虚拟交换软件，也就是说，Open vSwitch实现了网桥的功能。学习Open vSwitch的第一步要弄清楚网桥的概念。网桥是连接两个局域网的设备，工作在数据链路层，根据MAC地址来转发帧。在Open vSwitch中创建一个网桥后，此时网络功能不受影响，但是会产生一个虚拟网卡，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个网桥以后，还需要为这个网桥增加端口（port），一个端口就是一个物理网卡，当网卡加入到这个网桥之后，其工作方式就和普通交换机的一个端口的工作方式类似了。以下是一个网桥的具体信息：</p>
<blockquote>
</blockquote>
<pre><code>root@localhost:~# ovs-vsctl show
bc12c8d2-6900-42dd-9c1c-30e8ecb99a1b
Bridge &quot;br0&quot;
    Port &quot;eth0&quot;
        Interface &quot;eth0&quot;
    Port &quot;br0&quot;
        Interface &quot;br0&quot;
            type: internal
ovs_version: &quot;1.4.0+build0&quot;
</code></pre><p>上述信息显示了一个名为br0的桥（交换机），这个交换机有两个接口，一个是eth0，一个是br0。  </p>
<p>上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口实现了桥的功能。Open vSwitch的内核模块实现了多个“数据路径”，每个都可以有多个vports。每个数据路径也通过关联流表（flow table）来设置操作，而这些流表中的流都是用户空间在报文头和元数据的基础上映射的关键信息，一般的操作都是将数据包转发到另一个vport。当一个数据包到达一个vport，内核模块所做的处理是提取其流的关键信息并在流表中查找这些关键信息，当有一个匹配的流时它执行对应的操作，如果没有匹配，它会将数据包送到用户空间的处理队列中，作为处理的一部分，用户空间可能会设置一个流用于以后碰到相同类型的数据包可以在内核中执行操作。</p>
<h2 id="ovs-vsctl关于网桥管理的常用命令"><a href="#ovs-vsctl关于网桥管理的常用命令" class="headerlink" title="ovs-vsctl关于网桥管理的常用命令"></a>ovs-vsctl关于网桥管理的常用命令</h2><blockquote>
</blockquote>
<p><strong>init</strong>    初始化数据库（前提数据分组为空）<br><strong>show</strong>    打印数据库信息摘要<br><strong>add-br BRIDGE</strong>    添加新的网桥<br><strong>del-br BRIDGE</strong>    删除网桥<br><strong>list-br</strong>    打印网桥摘要信息<br><strong>list-ports BRIDGE</strong>    打印网桥中所有port摘要信息<br><strong>add-port BRIDGE PORT</strong>    向网桥中添加端口<br><strong>del-port [BRIDGE] PORT</strong>    删除网桥上的端口<br><strong>get-controller BRIDGE</strong>    获取网桥的控制器信息<br><strong>del-controller BRIDGE</strong>    删除网桥的控制器信息<br><strong>set-controller BRIDGE TARGET</strong>    向网桥添加控制器</p>
<h1 id="Open-vSwitch流表管理"><a href="#Open-vSwitch流表管理" class="headerlink" title="Open vSwitch流表管理"></a>Open vSwitch流表管理</h1><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议连接Open vSwitch来创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。ovs-ofctl关于流表管理的常用命令如下表所示。<br><img src="https://i.loli.net/2018/10/16/5bc5b553dc0a6.png" alt="03.png"><br>对于add-flow、add-flows和mod-flows这3个命令，还需要指定要执行的动作actions=[target],[target]…，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br><img src="https://i.loli.net/2018/10/16/5bc5b5bebfed1.png" alt="04.png"><br>在OpenFlow白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或空格分开，一些常用的字段列举如下表所示。<br><img src="https://i.loli.net/2018/10/16/5bc5b664441f1.png" alt="05.png"></p>
<h1 id="Open-vSwitchQoS设置"><a href="#Open-vSwitchQoS设置" class="headerlink" title="Open vSwitchQoS设置"></a>Open vSwitchQoS设置</h1><h1 id="Open-vSwitch端口映射"><a href="#Open-vSwitch端口映射" class="headerlink" title="Open vSwitch端口映射"></a>Open vSwitch端口映射</h1><h1 id="Open-vSwitch流量监控"><a href="#Open-vSwitch流量监控" class="headerlink" title="Open vSwitch流量监控"></a>Open vSwitch流量监控</h1>]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
        <tag>Open vSwitch</tag>
      </tags>
  </entry>
  <entry>
    <title>SDN实验（一）——常用开源工具</title>
    <url>/2018/10/15/SDN%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><p>Wireshark这款网络数据包分析工具，在传统网络中就有很广泛的应用，这里就不再多说了，主要记录一下笔者之前没有发现的功能或使用方法。  </p>
<h2 id="OpenFlow数据包"><a href="#OpenFlow数据包" class="headerlink" title="OpenFlow数据包"></a>OpenFlow数据包</h2><p>OpenFlow数据包主要包含五层，依次是：  </p>
<blockquote>
<p><strong>Frame：</strong>物理层数据帧概况。<br><strong>Ethernet II：</strong>数据链路层以太网帧头部信息。<br><strong>Internet Protocol Version 4：</strong>互联网IP包头信息。<br><strong>transmission control protocol：</strong>传输层数据段头部信息，此处是TCP。<br><strong>OpenFlow：</strong>位于TCP协议之上，负责解析应用层。  </p>
</blockquote>
<h2 id="保存捕获的数据"><a href="#保存捕获的数据" class="headerlink" title="保存捕获的数据"></a>保存捕获的数据</h2><p>wireshark除了有“save”和“save as”的保存方式外，还提供特殊保存的方法（Export Specified）：</p>
<blockquote>
<p><strong>All packets:</strong>保存所有已抓取的数据包。<br><strong>Selected packets only:</strong>保存当前鼠标选中的数据包。<br><strong>Marked packets only:</strong>保存当前标记的数据包。标记数据包的方法是在数据包列表中选中目标数据包，然后右击选择“mark packet toggle”。<br><strong>First to last marked:</strong>则将两个标记数据包之间所有的数据包导出。<br><strong>Range:</strong>并输入数据包的编号范围，则将编号连续的数据包导出。<br><strong>Remove ignored packets:</strong>则放弃部分数据包并导出其他所有数据包。放弃数据包的方法是，在数据包列表中选中数据包，右击，选择“ignore packet toggle”。</p>
</blockquote>
<h1 id="性能测试工具iPerf和Netperf"><a href="#性能测试工具iPerf和Netperf" class="headerlink" title="性能测试工具iPerf和Netperf"></a>性能测试工具iPerf和Netperf</h1><h2 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h2><p>1、网络吞吐量：单位时间内通过某个网络（信道或接口）的数据量，吞吐量受网络的带宽或者网络的额定速率限制，单位通常表示为bit/s或bps。  </p>
<p>2、网络延时：一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。影响网络延时的主要因素是路由的跳数和网络的流量。交换机延时（Latency）是指从交换机接收到数据包到开始向目的端口复制数据包之间的时间间隔。有许多因素会影响交换机延时大小，比如转发技术等等。  </p>
<p>3、抖动：用于描述包在网络中的传输延时的变化，抖动越小，说明网络质量越稳定越好。抖动是评价一个网络性能的最重要的因素。  </p>
<p>4、丢包率：理想状态下是发送了多少数据包就能接收到多少数据包，但是由于信号衰减、网络质量等诸多因素的影响并不能达到理想状态，而丢包率就是指测试中所丢失的数据包数量占所发送的数据包的比率。</p>
<h2 id="iPerf"><a href="#iPerf" class="headerlink" title="iPerf"></a>iPerf</h2><p>iPerf 是一种网络性能测试工具，可以运行于Linux、BSD、Unix及Windows等操作系统。 iPerf具有多种参数和特性，支持协议、定时、缓冲区等参数的配置调整，能够测试TCP/UDP最大带宽、延迟抖动、数据包丢失等统计信息，可以根据需求采用不同的参数从而达到不同的测试目的。iPerf基于Server/Client的工作模式，如下图所示：  </p>
<p><img src="https://i.loli.net/2018/10/15/5bc45614c9c99.png" alt="01.png"><br>客户端向服务端发送一定数量的数据，服务端统计并记录带宽、延时抖动等信息。客户端将数据全部发送后，服务端会回复一个数据包给客户端，将测试数据反馈给客户端。不过，如果网络较为拥塞或者误码率较高，客户端无法收到服务端回复的数据包，则只能显示本地记录的部分测试结果，所以服务端和客户端的测试结果可能有所不同。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote>
</blockquote>
<pre><code>iperf [-s|-c host] [options]
</code></pre><h4 id="客户端-服务端通用参数"><a href="#客户端-服务端通用参数" class="headerlink" title="客户端/服务端通用参数"></a>客户端/服务端通用参数</h4><blockquote>
</blockquote>
<pre><code>-f/—format  [kmKM]分别表示以Kbits, Mbits, KBytes, MBytes显示报告，默认以Mbits为单位
-i/—interval  以秒为单位显示报告间隔
-l/—len  读写的缓冲区大小，默认8KB
-m/—print_mss  打印最大的TCP数据段大小 (MTU - TCP/IP header)
-o/—output    将报告和错误信息输出到指定文件
-p/—port    指定服务器端使用的端口或客户端所连接的端口
-u/—udp    使用udp协议
-w/—window    指定TCP窗口（socket缓冲区）大小，默认是8KB
-B/—bind    绑定一个主机地址或接口
-C/—compatibility    兼容旧版本（当server端和client端版本不一样时使用）
-M/—mss    设置TCP最大数据段大小（MTU - 40 bytes）
-N/—nodelay    设置无延迟TCP，禁用 Nagle’s Algorithm
-V/—IPv6Version    设置传输Ipv6数据包
</code></pre><h4 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h4><blockquote>
</blockquote>
<pre><code>-s/—server    服务器模式下运行
-U/— single_udp    单线程UDP模式下运行
-D/— daemon    以守护进程模式运行服务器
</code></pre><h4 id="客户端参数"><a href="#客户端参数" class="headerlink" title="客户端参数"></a>客户端参数</h4><blockquote>
</blockquote>
<pre><code>-b/— bandwidth    对于UDP，使用bits/sec （默认 1 Mbit/sec, 亦即 -u）传送带宽
-c/— client    运行为客户端，连接到“主机”
-d/— dualtest    同步进行双向测试
-n/— num    传输的字节量
-r/— tradeoff    分别进行双向测试
-t/— time    传输持续时间 （默认10 secs）
-F/— fileinput    从文件中读取要传输的数据
-I/— stdin    从标准输入（stdin）中读取要传输的数据
-L/— listenport    双向测试接受端口
-P/— parallel    并行客户线程数量
-T/— ttl    多点传送的生存时间（默认1）
</code></pre><h2 id="Netperf"><a href="#Netperf" class="headerlink" title="Netperf"></a>Netperf</h2><p>Netperf是一种网络性能测量工具，主要用于测试TCP或UDP和Berkeley套接字接口的批量数据传输（bulk data transfer）和请求/应答（request/reponse）性能。Netperf工具以Client/Server方式工作，如下图所示：  </p>
<p><img src="https://i.loli.net/2018/10/15/5bc458630db61.png" alt="02.png"><br>服务端是netServer，用来侦听来自客户端的连接，客户端是netperf，用来向服务发起网络测试。在客户端与服务端之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果。在控制连接建立并传递了测试配置信息以后，客户端与服务端之间会再建立一个测试连接，用于来回传递特殊的流量，以测试网络的性能。当netServer在服务端启动后，就可在客户端运行netperf来测试网络的性能。netperf通过命令行参数来控制测试的类型和具体的测试选项，根据作用范围的不同，netperf的命令行参数可以分为两大类：全局命令行参数和测试相关的局部参数，两者之间使用—分隔。</p>
<h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote>
</blockquote>
<pre><code>netperf [global options] —[test-specific options]
</code></pre><h4 id="global-options"><a href="#global-options" class="headerlink" title="global options"></a>global options</h4><blockquote>
</blockquote>
<pre><code>-H host    指定远端运行netserver的server IP地址
-l testlen    指定测试的时间长度（秒）
-t testname    指定进行的测试类型（TCP_STREAM，UDP_STREAM，TCP_RR，TCP_CRR，UDP_RR）
</code></pre><h4 id="test-specific-options"><a href="#test-specific-options" class="headerlink" title="test-specific options"></a>test-specific options</h4><blockquote>
</blockquote>
<pre><code>-s size    设置本地系统的socket发送与接收缓冲大小
-S size    设置远端系统的socket发送与接收缓冲大小
-m size    设置本地系统发送测试分组的大小
-M size    设置远端系统接收测试分组的大小
-D    对本地与远端系统的socket设置TCP_NODELAY选项
-r req,resp    设置request和reponse分组的大小
</code></pre><h1 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h1><p>Scapy是一个基于Python编写的交互式数据包处理程序，使用Python解释器作为命令面板。可以用来发送、嗅探、解析和伪造网络数据包，常常被用于网络攻击和测试。Scapy可以实现扫描、路由跟踪、探测、单元测试、攻击和发现网络等传统功能，也可以代替hping、arpspoof、arp-sk、arping、p0f，实现了部分Namp、Tcpdump和tshark的功能。它能够伪造或者解码大量的网络协议数据包，能够发送、捕捉、匹配请求和回复包等等。它可以很容易地处理一些典型操作，比如端口扫描，tracerouting，探测，单元测试，攻击或网络发现（可替代hping，NMAP，arpspoof，ARP-SK，arping，tcpdump，tethereal，P0F等）。最重要的他还有很多更优秀的特性——发送无效数据帧、注入修改的802.11数据帧、在WEP上解码加密通道（VOIP）、ARP缓存攻击（VLAN）等，这也是其他工具无法处理完成的。  </p>
<p>Scapy有其他网络工具无法匹敌的优势，在大多数工具无法完成的任务中也有出色表现，比如发送无效帧、添加自定义的802.11帧、多技术结合等。其实，Scapy的理念非常简单，主要负责定义、发送和接收报文。用户利用Scapy定义一系列报文，接着发送这些报文，然后会收到回应，Scapy将收到的回应与请求匹配，返回到存放报文对（请求，回应）的列表和没有匹配报文的列表。  </p>
<p>Scapy不仅可以进行交互式数据包处理，还可以作为Python模块在Python程序中使用。需要注意的是，无论是交互式数据处理还是在Python代码中使用，都需要基于root权限。  </p>
<p>Scapy既然是第三方库，系统上默认是没有安装的。在Ubuntu下，我们可以直接使用命令：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install scapy
</code></pre><p>进行安装，安装完成以后，只需要在终端下执行sudo scapy就可以进入Scapy的命令行模式。  </p>
<p>Scapy常用功能:</p>
<blockquote>
<p>1、conf：查看配置信息<br>2、lsc()：查看支持的指令集<br>3、ls()：查看实现的网络协议。ls()中携带的参数可以是任何的一个具体的包，常用的有ARP、Ether、ICMP、IP、UDP、TCP，也支持SNMP、DHCP、STP等。<br>4、IP模块的使用:</p>
<blockquote>
<p>我们可以像在Python中一样实例化一个IP对象:</p>
<blockquote>
<p>data = IP()<br>data<br>    <ip><br>也可以传入需要自定义的参数:</ip></p>
</blockquote>
<blockquote>
<p>data = IP(dst=”172.16.2.79”)<br>data<br>    <ip dst="172.16.2.79"><br>查看 IP 模块对象的所有信息:</ip></p>
</blockquote>
<blockquote>
<p>data = IP()<br>data.show() </p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>###[ IP ]### 
version= 4 
ihl= None 
tos= 0x0 
len= None 
id= 1 
flags= 
frag= 0 
ttl= 64 
proto= ip 
chksum= None 
src= 127.0.0.1 
dst= 127.0.0.1 
\options\
</code></pre><blockquote>
<p>5、发送和接收报文：<br>可以将上面的 IP 对象封装成一个数据包发送出去。</p>
<blockquote>
<p>send：在第三层发送数据包，但没有接收功能。</p>
<blockquote>
<p>send(data, iface=”eth0”)<br>    .<br>    Sent 1 packets.<br>sendp：在第二层发送数据包，同样没有接收功能。<br>sr：在第三层发送数据包，有接收功能。<br>sr1：在第三层发送数据包，有接收功能，但只接收第一个包。<br>srp：在第二层发送数据包，有接收功能。<br>srp1：在第二层发送数据包，有接收功能，但只接收第一个包。</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="HTTP请求测试工具Postman"><a href="#HTTP请求测试工具Postman" class="headerlink" title="HTTP请求测试工具Postman"></a>HTTP请求测试工具Postman</h1><p>Postman是Google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件。其主要功能包括：<br>模拟各种HTTP requests：</p>
<blockquote>
<p>从常用的GET、POST到RESTful的PUT、DELETE等等。甚至还可以发送文件、送出额外的header。</p>
</blockquote>
<p>Collection功能（测试集合）:</p>
<blockquote>
<p>Collection是requests的集合，在做完一个测试的时候，你可以把这次的 request 存到特定的 Collection 里面，如此一来，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API。而且 Collection还可以Import或是Share出来，让团队里面的所有人共享你建立起来的Collection。</p>
</blockquote>
<p>人性化的Response整理:</p>
<blockquote>
<p>一般在用其他工具来测试的时候，response的内容通常都是纯文字的raw，但如果是JSON，就是塞成一整行的JSON。这会造成阅读的障碍，而Postman可以针对response内容的格式自动美化。JSON、XML或是HTML都会整理成我们可以阅读的格式。</p>
</blockquote>
<p>内置测试脚本语言:</p>
<blockquote>
<p>Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果。</p>
</blockquote>
<p>设定变量与环境</p>
<blockquote>
<p>Postman可以自由设定变量与环境，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我们可能会有多种环境，development、staging或local，而这几种环境中的request URL也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。</p>
</blockquote>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04安装OpenDaylight(锂版本)</title>
    <url>/2019/02/27/Ubuntu14-04%E5%AE%89%E8%A3%85OpenDaylight/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="下载OpenDaylight"><a href="#下载OpenDaylight" class="headerlink" title="下载OpenDaylight"></a>下载OpenDaylight</h2><p>下载OpenDaylight Lithium压缩包：<a href="https://pan.baidu.com/s/16rLxNFvz-XhGuSz62a5eQQ" target="_blank" rel="noopener">提取码：y4ae </a>  </p>
<h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><blockquote>
</blockquote>
<pre><code>sudo apt-get install openjdk-7-jdk
</code></pre><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>编辑 ~/.bashrc文件：</p>
<blockquote>
</blockquote>
<pre><code>vim ~/.bashrc
</code></pre><p>将以下内容添加至文件末尾：</p>
<blockquote>
</blockquote>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64 
</code></pre><p>应用 ~/.bashrc文件：</p>
<blockquote>
</blockquote>
<pre><code>source ~/.bashrc
</code></pre><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><blockquote>
</blockquote>
<pre><code>java -version
</code></pre><h1 id="安装OpenDaylight"><a href="#安装OpenDaylight" class="headerlink" title="安装OpenDaylight"></a>安装OpenDaylight</h1><p>将之前准备的安装包文件解压，并进入目录：</p>
<blockquote>
</blockquote>
<pre><code>unzip lithium.zip
cd distribution-karaf-0.3.0-Lithium
</code></pre><p>启动控制器，并进入karaf控制台：</p>
<blockquote>
</blockquote>
<pre><code>./bin/karaf
</code></pre><p>这样启动后关闭命令终端，控制器进程也会随之关闭，我们采用如下方式后台启动：</p>
<blockquote>
</blockquote>
<pre><code>./bin/start
./bin/client -u karaf
</code></pre><p>加载组件：</p>
<blockquote>
</blockquote>
<pre><code>feature:install odl-restconf
feature:install odl-l2switch-switch
feature:install odl-openflowplugin-all
feature:install odl-dlux-all
feature:install odl-mdsal-all
feature:install odl-adsal-northbound
</code></pre><h1 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h1><p>最后使用mininet创建拓扑连接OpenDaylight控制器进行验证：</p>
<blockquote>
</blockquote>
<pre><code>mn --controller=remote,ip=192.168.1.3,port=6633
&gt; pingall
</code></pre><p><img src="https://i.loli.net/2019/03/05/5c7e7ae09ba8e.png" alt="01.png"><br>可以看到两台设备通过控制器自动下发的流表已经可以互通了。<br>打开浏览器访问：http://[controller ip]:8080/index.html,用户名密码为admin/admin，登录控制器就可以看到刚刚创建的拓扑了：<br><img src="https://i.loli.net/2019/03/05/5c7e7ae093d62.png" alt="02.png"></p>
<h1 id="ODL关闭后重新启动出错"><a href="#ODL关闭后重新启动出错" class="headerlink" title="ODL关闭后重新启动出错"></a>ODL关闭后重新启动出错</h1><p>进入ODL主目录，(删除data目录，我在尝试时没删除也不影响效果),执行：</p>
<blockquote>
</blockquote>
<pre><code>./karaf clean
</code></pre><p>然后重新启动：</p>
<blockquote>
</blockquote>
<pre><code>./karaf
</code></pre><p>重新加载组件：</p>
<blockquote>
</blockquote>
<pre><code>feature:install odl-restconf
feature:install odl-l2switch-switch
feature:install odl-openflowplugin-all
feature:install odl-dlux-all
feature:install odl-mdsal-all
feature:install odl-adsal-northbound
</code></pre><h1 id="参考链接-与本文安装方式无关-："><a href="#参考链接-与本文安装方式无关-：" class="headerlink" title="参考链接(与本文安装方式无关)："></a>参考链接(与本文安装方式无关)：</h1><p>maven下载地址（bin.tar.gz）：</p>
<blockquote>
<p><a href="http://archive.apache.org/dist/maven/maven-3/3.3.3/binaries/" target="_blank" rel="noopener">http://archive.apache.org/dist/maven/maven-3/3.3.3/binaries/</a></p>
</blockquote>
<p><a href="https://wiki.opendaylight.org/view/Install_On_Ubuntu_14.04" target="_blank" rel="noopener">https://wiki.opendaylight.org/view/Install_On_Ubuntu_14.04</a></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>OpenDaylight</tag>
        <tag>Lithium</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04安装包方式安装Open vSwitch</title>
    <url>/2018/12/28/Ubuntu16-04%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Open-vSwitch/</url>
    <content><![CDATA[<h1 id="下载安装Open-vSwitch"><a href="#下载安装Open-vSwitch" class="headerlink" title="下载安装Open vSwitch"></a>下载安装Open vSwitch</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote>
</blockquote>
<pre><code>apt-get update
apt-get install build-essential
</code></pre><h2 id="下载解压安装包"><a href="#下载解压安装包" class="headerlink" title="下载解压安装包"></a>下载解压安装包</h2><p>下载Open vSwitch安装包：<a href="http://www.openvswitch.org/download/" target="_blank" rel="noopener">Open vSwitch官网下载地址</a><br>这里我下载的是最新的2.10.1版本：</p>
<blockquote>
</blockquote>
<pre><code>wget https://www.openvswitch.org/releases/openvswitch-2.10.1.tar.gz
tar -xzvf openvswitch-2.10.1.tar.gz
</code></pre><h2 id="构建基于Linux内核的交换机"><a href="#构建基于Linux内核的交换机" class="headerlink" title="构建基于Linux内核的交换机"></a>构建基于Linux内核的交换机</h2><blockquote>
</blockquote>
<pre><code>cd openvswitch-2.10.1
./configure --with-linux=/lib/modules/&quot;uname -r&quot;/build
# 注意这条命令中的&quot;uname -r&quot;是输出当前系统的版本号
# 比如我执行&quot;uname -r&quot;后的结果为4.4.0-21-generic，那么我应该执行的命令即为：
# ./configure --with-linux=/lib/modules/4.4.0-21-generic/build
</code></pre><h2 id="编译安装Open-vSwitch"><a href="#编译安装Open-vSwitch" class="headerlink" title="编译安装Open vSwitch"></a>编译安装Open vSwitch</h2><blockquote>
</blockquote>
<pre><code>make
make install
</code></pre><h2 id="加载openvswitch-ko模块-遇到错误"><a href="#加载openvswitch-ko模块-遇到错误" class="headerlink" title="加载openvswitch.ko模块(遇到错误)"></a>加载openvswitch.ko模块(遇到错误)</h2><p>如果需要OVS支持VLAN功能，还需要加载openvswitch.ko模块，如果不需要，此步可以忽略。  </p>
<blockquote>
</blockquote>
<pre><code>modprobe gre
insmod datapath/linux/openvswitch.ko
</code></pre><p>我在执行第二条命令时遇到了如下错误：</p>
<blockquote>
</blockquote>
<pre><code>insmod: ERROR: could not insert module openvswitch.ko: Unkown symbol in module
</code></pre><p>google了几个方法都没能成功解决问题，有人说是bug，也有说是因为兼容性问题，因为我暂时用不到VLAN功能，就暂时跳过此步骤了。</p>
<h2 id="安装并加载构建的内核模块"><a href="#安装并加载构建的内核模块" class="headerlink" title="安装并加载构建的内核模块"></a>安装并加载构建的内核模块</h2><blockquote>
</blockquote>
<pre><code>make modules_install
/sbin/modprobe openvswitch
</code></pre><h2 id="使用ovsdb工具初始化配置数据库"><a href="#使用ovsdb工具初始化配置数据库" class="headerlink" title="使用ovsdb工具初始化配置数据库"></a>使用ovsdb工具初始化配置数据库</h2><blockquote>
</blockquote>
<pre><code>ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema
# 在执行此命令时报错没有此文件夹，我直接手动创建了对应的文件夹：
# mkdir -p /usr/local/etc/openvswitch
</code></pre><h1 id="启动Open-vSwitch"><a href="#启动Open-vSwitch" class="headerlink" title="启动Open vSwitch"></a>启动Open vSwitch</h1><h2 id="启动ovsdb-server配置数据库"><a href="#启动ovsdb-server配置数据库" class="headerlink" title="启动ovsdb-server配置数据库:"></a>启动ovsdb-server配置数据库:</h2><blockquote>
</blockquote>
<pre><code>ovsdb-server -v --remote=punix:/usr/local/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,Open_vSwitch,manager_options --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --pidfile --detach --log-file
# 这里同样报错没有此文件夹，同样手动创建了相应的文件夹
</code></pre><p>首次用ovsdb-tool创建数据库时需用ovs-vsctl命令初始化下数据库:</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl --no-wait init
</code></pre><h2 id="启动OVS主进程"><a href="#启动OVS主进程" class="headerlink" title="启动OVS主进程:"></a>启动OVS主进程:</h2><blockquote>
</blockquote>
<pre><code>ovs-vswitchd --pidfile --detach --log-file
</code></pre><h2 id="查看OVS进程是否启动"><a href="#查看OVS进程是否启动" class="headerlink" title="查看OVS进程是否启动:"></a>查看OVS进程是否启动:</h2><blockquote>
</blockquote>
<pre><code>ps aux|grep ovs
</code></pre><h2 id="查看所安装OVS的版本号"><a href="#查看所安装OVS的版本号" class="headerlink" title="查看所安装OVS的版本号:"></a>查看所安装OVS的版本号:</h2><blockquote>
</blockquote>
<pre><code>ovs-vsctl --version
</code></pre><p>至此，Open vSwitch就安装完成了，安装过程中的几个小问题本次没有解决，希望之后能找到解决办法。最后再补充一个更简单的方式——使用apt install的方式直接安装：</p>
<blockquote>
</blockquote>
<pre><code>apt-get install openvswitch-switch
</code></pre>]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>Open vSwitch</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu开机网卡无法正常启动</title>
    <url>/2019/08/06/Ubuntu%E5%BC%80%E6%9C%BA%E7%BD%91%E5%8D%A1%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>之前在学校实训的时候用到一台Ubuntu虚拟机，一开始不知道为什么重启之后网卡无法正常启动和加载，执行ifconfig命令之后只显示有本地环回网卡，当时折腾了半天也没找到原因。  </p>
<p>今天又打开这个虚拟机，突然发现系统这不是给出了错误提示吗？<br><img src="https://i.loli.net/2019/08/06/mCMdLzTGOarEYSj.png" alt="00.png"><br>查了一下misplaced是不适宜的意思（没办法词汇量匮乏），也就是说，interfaces文件的第一行有错误了。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>既然定位到了问题根源，那就追根溯源，去查看一下interfaces文件，打眼一看一点问题都没有。<br><img src="https://i.loli.net/2019/08/06/Pz3ZwEmshAKY7cH.png" alt="01.png"><br>等等，第一行不应该是注释么？有可能是之前不小心误删了，改之。<br><img src="https://i.loli.net/2019/08/06/nCihLwIHWDJ6vrx.png" alt="02.png"><br>注释行颜色亮起的那一刻我就知道问题解决了，重启一下网络，问题解决。<br><img src="https://i.loli.net/2019/08/06/7b5udhXcSPiB24R.png" alt="03.png"></p>
<p>这样一个小的错误，小到犹豫半天要不要写这篇博客，最后还是决定简单记录一下，就当给自己提个醒吧，而且也不违背当时写博客的初衷——是记录，亦是成长。</p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04安装ONOS Hummingbird(1.7.1)</title>
    <url>/2019/05/14/Ubuntu16-04%E5%AE%89%E8%A3%85ONOS-Hummingbird-1-7-1/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>Ubuntu 16.04 Desktop (内存推荐4G)<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html" target="_blank" rel="noopener">server-jre</a><br><a href="https://wiki.onosproject.org/display/ONOS/Downloads" target="_blank" rel="noopener">onos-1.7.1</a>  </p>
<p>*目前Oracle网站需要登录账户才能下载</p>
<h1 id="配置JRE"><a href="#配置JRE" class="headerlink" title="配置JRE"></a>配置JRE</h1><p>将下载下来的JRE文件解压到自定义目录中：</p>
<blockquote>
</blockquote>
<pre><code>mkdir -p /opt/java #将下载下来的安装包移动到此目录（目录可自己定义）
tar -xzvf server-jre-8u211-linux-x64.tar.gz
</code></pre><p>配置环境变量：</p>
<blockquote>
</blockquote>
<pre><code>vim /etc/profile
</code></pre><p>在文件末尾添加如下配置：</p>
<blockquote>
</blockquote>
<pre><code>export JAVA_HOME=/opt/java/jdk1.8.0_211
export JRE_HOME=/opt/java/jdk1.8.0_211
export CLASSPATH=$JRE_HOME/lib/rt.jar:$JRE_HOME/lib/ext
export PATH=$PATH:$JRE_HOME/bin
</code></pre><p>使配置生效：</p>
<blockquote>
</blockquote>
<pre><code>source /etc/profile
</code></pre><p>验证配置成功：</p>
<blockquote>
</blockquote>
<pre><code>java -version #显示java版本信息
</code></pre><h1 id="配置ONOS"><a href="#配置ONOS" class="headerlink" title="配置ONOS"></a>配置ONOS</h1><p>解压ONOS压缩包：</p>
<blockquote>
</blockquote>
<pre><code>tar -xzvf onos-1.7.1.tar.gz
</code></pre><p>设置ONOS_ROOT和KARAF_ROOT的路径：</p>
<blockquote>
</blockquote>
<pre><code>vim /etc/profile
</code></pre><p>在文件末尾添加以下内容,注意修改为自己对应的目录：</p>
<blockquote>
</blockquote>
<pre><code>export ONOS_ROOT=/home/sdn/vmlab/onos-1.7.1
export KARAF_ROOT=/home/sdn/vmlab/onos-1.7.1/apache-karaf-3.0.5
export PATH=$PATH:$KARAF_ROOT/bin:$ONOS_ROOT/bin
</code></pre><p>使配置生效：</p>
<blockquote>
</blockquote>
<pre><code>source /etc/profile
</code></pre><p>运行onos(第一次启动可能时间较长)：</p>
<blockquote>
</blockquote>
<pre><code>karaf clean
</code></pre><p>安装应用：</p>
<blockquote>
</blockquote>
<pre><code>&gt; app activate org.onosproject.openflow
&gt; app activate org.onosproject.fwd
&gt; app activate org.onosproject.mobility
</code></pre><p><img src="https://i.loli.net/2019/05/14/5cda1aee3aa5210524.png" alt="01.png"></p>
<h1 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h1><p>查看端口监听状态：</p>
<blockquote>
</blockquote>
<pre><code>netstat -an | grep 8181 #onos Web监听端口
netstat -an | grep 6633 #onos OF监听端口
</code></pre><p><img src="https://i.loli.net/2019/05/14/5cda1c09acf8f39168.png" alt="02.png"></p>
<p>访问Web界面，地址为：http://[ip]:8181/onos/ui/index.html,账户/密码：onos/rocks ：<br><img src="https://i.loli.net/2019/05/14/5cda1d7ed2e3e92022.png" alt="03.png"></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>ONOS</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin使用ssr不能和谐上网</title>
    <url>/2018/11/25/deepin%E4%BD%BF%E7%94%A8ssr%E4%B8%8D%E8%83%BD%E5%92%8C%E8%B0%90%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<p>最近在笔记本上装了deepin体验一番，看到深度商店有SSR客户端毫不犹豫的就安装上了，但是添加节点后发现并不能奏效。搜索不到解决方法，自己尝试了很多方法也没能解决，最后终于在深度商店的应用评论里看到了解决办法。  </p>
<p>首先保证客户端设置正确，在添加节点信息之后，软件默认的本地端口是0，这里需要改为1080。<br><img src="https://i.loli.net/2018/11/25/5bfaa5fc3cc94.png" alt="01.png"><br>然后到系统设置中，选择网络，设置系统代理模式为手动，将Socks代理参数改为127.0.0.1，端口改为1080。<br><img src="https://i.loli.net/2018/11/25/5bfaa6dc4926d.png" alt="02.png"></p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>ssr</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04安装OpenDaylight Carbon</title>
    <url>/2019/03/14/Ubuntu16-04%E5%AE%89%E8%A3%85OpenDaylight-Carbon/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="JRE安装配置"><a href="#JRE安装配置" class="headerlink" title="JRE安装配置"></a>JRE安装配置</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html</a><br>我这里下载的是目前的最新版本：</p>
<blockquote>
</blockquote>
<pre><code>wget https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/server-jre-8u201-linux-x64.tar.gz
</code></pre><p>解压到自定义目录中：</p>
<blockquote>
</blockquote>
<pre><code>mkdir -p /opt/java #将下载下来的安装包移动到此目录（目录可自己定义）
tar -xzvf server-jre-8u201-linux-x64.tar.gz
</code></pre><p>配置环境变量：</p>
<blockquote>
</blockquote>
<pre><code>vim /etc/profile
</code></pre><p>在文件末尾添加如下配置：</p>
<blockquote>
</blockquote>
<pre><code>export JAVA_HOME=/opt/java/jdk1.8.0_201
export JRE_HOME=/opt/java/jdk1.8.0_201
export CLASSPATH=$JRE_HOME/lib/rt.jar:$JRE_HOME/lib/ext
export PATH=$PATH:$JRE_HOME/bin
</code></pre><p>使配置生效：</p>
<blockquote>
</blockquote>
<pre><code>source /etc/profile
</code></pre><p>验证配置成功：</p>
<blockquote>
</blockquote>
<pre><code>java -version #显示java版本信息
</code></pre><h1 id="OpenDaylight-Carbon-安装配置"><a href="#OpenDaylight-Carbon-安装配置" class="headerlink" title="OpenDaylight(Carbon)安装配置"></a>OpenDaylight(Carbon)安装配置</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>我这里下载的是0.6.4版本：</p>
<blockquote>
</blockquote>
<pre><code>wget https://nexus.opendaylight.org/content/repositories/public/org/opendaylight/integration/distribution-karaf/0.6.4-Carbon/distribution-karaf-0.6.4-Carbon.zip
</code></pre><h2 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h2><blockquote>
</blockquote>
<pre><code>uzip distribution-karaf-0.6.4-Carbon.zip
</code></pre><h2 id="启动karaf"><a href="#启动karaf" class="headerlink" title="启动karaf"></a>启动karaf</h2><blockquote>
</blockquote>
<pre><code>cd distribution-karaf-0.6.4-Carbon
./bin/karaf
</code></pre><h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><p>安装REST API组件</p>
<blockquote>
</blockquote>
<pre><code>feature:install odl-restconf
</code></pre><p>安装L2 switch组件：</p>
<blockquote>
</blockquote>
<pre><code>feature:install odl-l2switch-switch-ui
</code></pre><p>安装API查看器：</p>
<blockquote>
</blockquote>
<pre><code>feature:install odl-mdsal-apidocs
</code></pre><p>安装 dlux 展示页面:</p>
<blockquote>
</blockquote>
<pre><code>feature:install odl-dluxapps-applications
</code></pre><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><h3 id="登录管理页面"><a href="#登录管理页面" class="headerlink" title="登录管理页面"></a>登录管理页面</h3><p>用浏览器访问：<a href="http://localhost:8080/index.html" target="_blank" rel="noopener">http://localhost:8080/index.html</a><br>用户名/密码：admin/admin</p>
<h3 id="使用OpenvSwitch连接ODL控制器"><a href="#使用OpenvSwitch连接ODL控制器" class="headerlink" title="使用OpenvSwitch连接ODL控制器"></a>使用OpenvSwitch连接ODL控制器</h3><p>用下面的命令将br0网桥连接至指定的控制器:</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl set-controller br0 tcp:&lt;controller IP&gt;:&lt;port&gt;
</code></pre><p>执行：ovs-vsctl show,出现is_connected:true字样表示连接成功：<br><img src="https://i.loli.net/2019/03/14/5c89ad571b951.png" alt="01.png"><br>登录管理页面查看拓扑发现已经连接的OVS交换机：<br><img src="https://i.loli.net/2019/03/14/5c89ad5730b6b.png" alt="02.png"></p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>OpenDaylight</tag>
        <tag>Ubuntu16.04</tag>
      </tags>
  </entry>
  <entry>
    <title>RHEL使用CentOS的yum源</title>
    <url>/2021/01/15/RHEL%E4%BD%BF%E7%94%A8CentOS%E7%9A%84yum%E6%BA%90/</url>
    <content><![CDATA[<h1 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h1><p>RHEL 7.7</p>
<h1 id="删除RHEL自带yum"><a href="#删除RHEL自带yum" class="headerlink" title="删除RHEL自带yum"></a>删除RHEL自带yum</h1><blockquote>
</blockquote>
<pre><code>rpm -qa | grep yum
rpm -qa | grep yum | xargs rpm -e --nodeps
</code></pre><p><img src="https://i.loli.net/2021/01/15/3zTJoPNOxGujUlr.png" alt="01.png"></p>
<h1 id="安装CentOS的yum"><a href="#安装CentOS的yum" class="headerlink" title="安装CentOS的yum"></a>安装CentOS的yum</h1><p>访问阿里或网易等镜像源，下载对应版本的CentOS yum安装包，我使用的是阿里的：</p>
<blockquote>
<p><a href="http://mirrors.aliyun.com/centos/7/os/x86_64/Packages/" target="_blank" rel="noopener">http://mirrors.aliyun.com/centos/7/os/x86_64/Packages/</a></p>
</blockquote>
<p>下载如图所示的4个rpm包：<br><img src="https://i.loli.net/2021/01/15/PkpujiVMSY6RXdB.png" alt="03.png"></p>
<p>已下载的rpm包：<br><img src="https://i.loli.net/2021/01/15/LT7ZdA4Xywe9WNi.png" alt="04.png"></p>
<p>安装刚刚下载的rpm包，他们之间有依赖关系，推荐一起安装</p>
<blockquote>
</blockquote>
<pre><code>rpm -ivh yum-3.4.3-168.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm yum-rhn-plugin-2.0.1-10.el7.noarch.rpm yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm 
</code></pre><p><img src="https://i.loli.net/2021/01/15/67JdUeACOsvZyLo.png" alt="05.png"></p>
<p><img src="https://i.loli.net/2021/01/15/WJgABKOtQM5xno4.png" alt="02.png"></p>
<h1 id="下载repo并修改"><a href="#下载repo并修改" class="headerlink" title="下载repo并修改"></a>下载repo并修改</h1><p>yum安装后，下载对应版本CentOS的repo文件，同样在阿里镜像站下载：</p>
<blockquote>
<p><a href="http://mirrors.aliyun.com/repo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/</a></p>
</blockquote>
<p><img src="https://i.loli.net/2021/01/15/j4GIMhzrsvJAW1S.png" alt="06.png"></p>
<p>需要注意的是这时候还不能直接使用yum安装软件，安装时会有如下错误：<br><img src="https://i.loli.net/2021/01/15/vp27FLhcKj1rMJ3.png" alt="07.png"></p>
<p>原因是因为repo文件中CentOS是直接取的是releasever的值，这里我们手动修改为对应的CentOS版本的值就可以了，如我这里修改为7，直接在vim编辑器中进行全文替换：</p>
<blockquote>
</blockquote>
<pre><code>:%s/$releasever/7/
</code></pre><p><img src="https://i.loli.net/2021/01/15/efwE13o8JOY7mlF.png" alt="08.png"></p>
<p>使用yum安装软件可正常安装：</p>
<p><img src="https://i.loli.net/2021/01/15/cTAK52rkMmj1HE6.png" alt="09.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RHEL</tag>
        <tag>yum源</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统配置检测工具——Superbench</title>
    <url>/2018/10/10/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Superbench/</url>
    <content><![CDATA[<p>我曾经就暗暗吐槽Linux没有一条可以查看配置信息的命令，只能一项一项的查看，体验不是很好。今天无意中发现了一个叫做<strong>Superbench</strong>的脚本，试着用了一下，非常方便，在这里推荐一下。  </p>
<p>这个脚本主要有以下几个特点：</p>
<blockquote>
<p>采用颜色显示，便于区分查找  </p>
<p>磁盘I/O测试分别使用小文件、中等文件、大文件进行测试，最终计算平均值。  </p>
<p>网速测试通过多个节点进行测试，其中CM,CU,CT分别代表移动、联通和电信。</p>
<blockquote>
<p>ps:<br>中国移动：CMCC ，全称ChinaMobile Communication Company<br>中国联通：CUCC，全称China unicom Communications Corporation<br>中国电信：CTC，全称China Telecommunications Corporation  </p>
</blockquote>
</blockquote>
<h1 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h1><p>执行如下命令:</p>
<blockquote>
</blockquote>
<pre><code>wget -qO- git.io/superbench.sh | bash
</code></pre><p>稍等一会就会打印出详细的配置信息：  </p>
<p><img src="https://i.loli.net/2018/10/10/5bbdccb7a8783.png" alt="01.png"><br><img src="https://i.loli.net/2018/10/10/5bbdccb7aa383.png" alt="02.png"><br>同时我们看到最后还附带了一个分享链接用于分享我们的配置信息，在浏览器打开是这个样子的：  </p>
<p><img src="https://i.loli.net/2018/10/10/5bbdccb7b6cd2.png" alt="03.png"></p>
]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>脚本</tag>
        <tag>配置检测</tag>
      </tags>
  </entry>
  <entry>
    <title>WinSCP——基于SSH的安全文件传输软件</title>
    <url>/2018/07/03/WinSCP%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ESSH%E7%9A%84%E5%AE%89%E5%85%A8%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>我的一个影视网站因为之前买的虚拟主机到期了，就想着把它放到我那台ssr主机上，结果配置vstp的时候不知道什么原因，配置完用客户端登录的时候总是提示说密码验证失败。然后看到一个博主推荐，就是WinSCP了，它的好处在于他是基于SSH协议的sftp文件传输，也就是说，只要你的linux主机可以使用ssh，就可以用它进行文件传输。  </p>
<h1 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h1><p>sftp(Secure File Transfer Protocol)，安全文件传送协议，可以为传输文件提供一种安全的网络的加密方法。sftp与ftp有着几乎一样的语法和功能。SFTP是SSH的一部分，其实在SSH软件包中，已经包含了一个叫作SFTP的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。<br>SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，所以在对网络安全性要求更高时，可以使用SFTP代替FTP。</p>
<h1 id="sftp于ftp的区别"><a href="#sftp于ftp的区别" class="headerlink" title="sftp于ftp的区别"></a>sftp于ftp的区别</h1><p>FTP是一种文件传输协议，一般是为了方便数据共享的，包括一个FTP服务器和多个FTP客户端，FTP客户端通过FTP协议在服务器上下载资源。而SFTP协议是基于SSH，并在FTP的基础上对数据进行加密，使得传输的数据相对来说更安全。但是这种安全是以牺牲效率为代价的，也就是说SFTP的传输效率比FTP要略低。<br>而且在我的使用过程中，并没有感觉sftp的效率较于ftp有太大的差异，而且使用sftp最大的一个好处就是不需要安装而且安全性更高。<br>更详细的区别可以移步这里：<a href="https://www.cnblogs.com/mfryf/archive/2013/05/29/3107286.html" target="_blank" rel="noopener">Sftp和ftp 区别、工作原理等（汇总ing）</a></p>
<h1 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h1><p>官网地址：<a href="https://winscp.net/eng/docs/lang:chs" target="_blank" rel="noopener">https://winscp.net/eng/docs/lang:chs</a><br>除了WinSCP，Windows环境下还可以使用Core FTP，FileZilla, WinSCP，Xftp来连接SFTP进行上传，下载文件，建立，删除目录等操作。</p>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>文件传输</tag>
        <tag>工具</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>mininet gave up after 3 retries问题</title>
    <url>/2019/03/02/mininet-gave-up-after-3-retries%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用mn创建拓扑时，出现以下错误：</p>
<blockquote>
</blockquote>
<pre><code>*** Creating network
*** Adding controller
*** Adding hosts:
h1 h2 
*** Adding switches:
s1 
*** Adding links:
*** gave up after 3 retries
</code></pre><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>出现如上错误是因为kernel版本的问题，在安装mininet时使用的是apt-get install mininet的方式安装的，这种方式安装的mininet并不是最新版本，安装最新版本以解决问题：<br>1、卸载之前的安装</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get remove mininet
sudo apt-get remove --auto-remove mininet
sudo apt-get purge mininet
</code></pre><p>2、安装最新版本(<a href="https://cyne.tk/2018/06/24/Mininet%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">详细步骤</a>)</p>
<blockquote>
</blockquote>
<pre><code>git clone git://github.com/mininet/mininet
cd mininet
util/install.sh -a
</code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>后来使用Ubuntu16.04，同样使用apt-get install直接安装openvswitch和mininet时，没有出现上述问题，推荐使用16.04版本安装环境。</p>
]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>mininet</tag>
      </tags>
  </entry>
  <entry>
    <title>利用FRP实现内网穿透</title>
    <url>/2018/10/20/Windows%E7%8E%AF%E5%A2%83%E5%88%A9%E7%94%A8FRP%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>FRP (Fast Reverse Proxy) 是一个可用于内网穿透的高性能的反向代理应用，支持TCP,UDP,HTTP,HTTPS协议。  </p>
<p>项目地址：<br><a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。  </p>
<p>比如我们平时用的翻墙工具就属于正向代理的一种应用。<br><img src="https://i.loli.net/2018/10/20/5bcaf373cd030.png" alt="01.png"></p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。<br><img src="https://i.loli.net/2018/10/20/5bcaf373ef44d.png" alt="02.png"></p>
<h1 id="安装部署frp"><a href="#安装部署frp" class="headerlink" title="安装部署frp"></a>安装部署frp</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.拥有公网ip的设备</p>
<blockquote>
<p>作为反向代理服务器，外网访问内网设备时通过此设备进行访问。</p>
</blockquote>
<p>2.域名（非必须）</p>
<blockquote>
<p>域名的作用仅仅是为了方便记忆，有了域名在访问时就不需要输入那些难以记忆的数字进行访问了。</p>
</blockquote>
<h2 id="下载安装程序"><a href="#下载安装程序" class="headerlink" title="下载安装程序"></a>下载安装程序</h2><p>到<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">GitHub</a>下载frp程序，如果是64位系统下载“amd64”结尾的zip包，如果是32位系统就下载“386”结尾的zip包。  </p>
<p>下载完成后分别在客户端和服务端选择一个合适的位置直接解压出来就可以了。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="放行端口"><a href="#放行端口" class="headerlink" title="放行端口"></a>放行端口</h3><p>因为博主使用的是阿里云的学生机，默认是没有放行其它端口的，所以在配置frp之前需要配置一下入方向的安全组规则：<br><img src="https://i.loli.net/2018/10/20/5bcaf78e8b887.png" alt="03.png"></p>
<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>在上面过程中解压出来的文件包含有frps.ini和frps_full.ini两个配置文件，frps_full.ini是全配置，里面所有的配置都有，玩法很多，感兴趣的可以研究一下。将下面配置代码复制到frps.ini后保存：</p>
<blockquote>
</blockquote>
<pre><code>[common]
bind_port = 7000 ;要绑定的端口

dashboard_user = admin ;控制台的用户名
dashboard_pwd = password ;控制台的密码
dashboard_port = 7500 ;控制台的端口
</code></pre><p>在配置文件所在位置按住shift右键打开cmd或power shell，执行命令：<br>cmd:</p>
<blockquote>
</blockquote>
<pre><code>frps -c frps.ini
</code></pre><p>power shell:</p>
<blockquote>
</blockquote>
<pre><code>.\frps.exe -c frps.ini
</code></pre><h2 id="客户端-内网设备"><a href="#客户端-内网设备" class="headerlink" title="客户端(内网设备)"></a>客户端(内网设备)</h2><h3 id="编辑配置文件-1"><a href="#编辑配置文件-1" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>将如下代码复制到frpc.ini中：</p>
<blockquote>
</blockquote>
<pre><code>[common]
server_addr = 1.2.3.4 ;服务器的 IP
server_port = 7000 ;服务器上设置的服务绑定端口

[RDP] ;这个是反向代理的名称，可以随意设置
type = tcp ;RDP 是 TCP 协议的
local_ip = 127.0.0.1 ;本机IP,可以直接使用127.0.0.1
local_port = 3389 ;远程桌面的默认端口
remote_port = 7001 ;外网访问的端口
</code></pre><p>在配置文件所在位置按住shift右键打开cmd或power shell，执行命令：<br>cmd:</p>
<blockquote>
</blockquote>
<pre><code>frpc -c frpc.ini
</code></pre><p>power shell:</p>
<blockquote>
</blockquote>
<pre><code>.\frpc.exe -c frpc.ini
</code></pre><h3 id="开启远程桌面（非必须）"><a href="#开启远程桌面（非必须）" class="headerlink" title="开启远程桌面（非必须）"></a>开启远程桌面（非必须）</h3><p>如果你配置frp是为了使用远程桌面，而恰巧你的内网设备又是win7或win10等桌面版系统，那么你还需要右击“此电脑”，选择“系统”——“远程设置”——“允许远程连接至此电脑”。而如果是server版本直接忽略此步骤即可。  </p>
<p>至此，你已经可以使用你的ip加端口号的形式访问你的相应服务了。</p>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>设置自己的域名解析，添加一条A类记录指向你的公网ip。<br><img src="https://i.loli.net/2018/10/20/5bcb0775422ac.png" alt="04.png"></p>
<h3 id="配置frpc-ini"><a href="#配置frpc-ini" class="headerlink" title="配置frpc.ini"></a>配置frpc.ini</h3><p>在刚才复制的配置之后添加如下内容即可：</p>
<blockquote>
</blockquote>
<pre><code>custom_domains = xxx.yourdomain.xxx
</code></pre><p>这样，你就可以使用域名+端口的形式访问你的服务了。</p>
<h1 id="Linux环境后台运行frp"><a href="#Linux环境后台运行frp" class="headerlink" title="Linux环境后台运行frp"></a>Linux环境后台运行frp</h1><p>在Linux环境下使用frp与Linux并没有太大的区别，配置文件的写法都一样，主要是frp的后台运行，因为如果我们使用ssh方式登录服务器的方式，启动了frp服务，当断开ssh连接的时候frp服务也就随之关闭。这里有两种后台运行frp服务的方式：</p>
<h2 id="使用nohup"><a href="#使用nohup" class="headerlink" title="使用nohup"></a>使用nohup</h2><p>首先进入frp的解压目录！<br>服务端：</p>
<blockquote>
</blockquote>
<pre><code>nohup ./frps -c ./frps.ini &amp;
</code></pre><p>客户端：</p>
<blockquote>
</blockquote>
<pre><code>nohup ./frpc -c ./frpc.ini &amp;
</code></pre><h2 id="使用screen"><a href="#使用screen" class="headerlink" title="使用screen"></a>使用screen</h2><p>首先进入frp的解压目录！<br>服务端：</p>
<blockquote>
</blockquote>
<pre><code>screen -S frp  # 创建一个screen
./frps -c ./frps.ini
</code></pre><p>客户端：</p>
<blockquote>
</blockquote>
<pre><code>screen -S frp  # 创建一个screen
./frpc -c ./frpc.ini
</code></pre><h1 id="Windows开机自动连接"><a href="#Windows开机自动连接" class="headerlink" title="Windows开机自动连接"></a>Windows开机自动连接</h1><p>为了能够让Windows开机启动后能够自动连接到frp服务端，需要添加一个开机时启动的计划任务，Windows计划任务不过多介绍，没用过的可以Google/百度。  </p>
<p>在frp程序所在目录新建一个记事本文件，内容如下：</p>
<blockquote>
</blockquote>
<pre><code>CreateObject(&quot;WScript.Shell&quot;).Run &quot;cmd /c frpc -c frpc.ini&quot;,0
</code></pre><p><img src="https://i.loli.net/2019/07/08/5d233881631db89601.png" alt="05.png"><br>也就是启动frpc程序，然后将.txt修改为.vbs格式，然后再新建一个Windows计划任务，将这个vbs脚本程序添加进去就ok了。</p>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>frp</tag>
        <tag>内网穿透</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu执行apt-get-update出现Error in &#39;appstreamcli&#39;错误</title>
    <url>/2019/03/13/ubuntu%E6%89%A7%E8%A1%8Capt-get-update%E5%87%BA%E7%8E%B0Error%20in%20&#39;appstreamcli&#39;%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>新装Ubuntu16.04桌面版后执行apt-get update时出现了如下图所示的错误：<br><img src="https://i.loli.net/2019/03/13/5c890d5cd7212.png" alt="11.png"></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>执行如下命令：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt install appstream/xenial-backports 
sudo appstreamcli refresh –-force 
sudo apt-get update
</code></pre><p>然后再次执行：</p>
<blockquote>
</blockquote>
<pre><code>apt-get update
</code></pre><p>这时已经可以成功执行。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>apt-get</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows计划任务+sendEmail实现系统启动邮件提醒</title>
    <url>/2018/07/01/Windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-sendemail%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/</url>
    <content><![CDATA[<p>由于实验室线路的问题，经常跳闸断电，通电后虽然服务器可以自动开机，但是包括vcenter在内的所有虚拟机都会down掉，为了能够及时的知晓服务器断电，昨天想了个一个办法。就是从从控制机pc入手，首先设置bios将电脑设置为通电自启，然后启动后给我的邮箱发送邮件，这样就能够在服务器重启之后及时的恢复服务。  </p>
<h1 id="sendEmail"><a href="#sendEmail" class="headerlink" title="sendEmail"></a>sendEmail</h1><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>sendemail是一个用来发送邮件的命令行工具，极其轻量和方便。<br>首先到sendemail的官网下载sendEmail压缩包，Windows有两个版本，一个是包含tls验证，一个没有，这里我们下载有tls验证的版本。<br><img src="https://i.loli.net/2018/07/01/5b38b2878efad.png" alt="01.png"></p>
<h2 id="测试sendEmail能否正常使用"><a href="#测试sendEmail能否正常使用" class="headerlink" title="测试sendEmail能否正常使用"></a>测试sendEmail能否正常使用</h2><p>将下载下来的压缩包解压到自己想要的目录中，然后用cmd定位到此目录。<br><img src="https://i.loli.net/2018/07/01/5b38b3647ea3c.png" alt="02.png"><br>然后根据官网的语法说明即可编写相应的命令，这里我们用官网给出的模板直接进行修改：</p>
<blockquote>
</blockquote>
<pre><code>sendEmail -o tls=yes -f YourEmail@gmail.com -t SomeoneYoureEmailing@domain.com -s smtp.gmail.com:587 -xu YourEmail@gmail.com -xp YOURPASSWORD -u &quot;Hello from sendEmail&quot; -m &quot;How are you? I&apos;m testing sendEmail from the command line.&quot;
</code></pre><p>例子中的说明：</p>
<blockquote>
</blockquote>
<pre><code>-f YourEmail@gmail.com #发件人邮箱
-t SomeoneYoureEmailing@domain.com #收件人邮箱
-s smtp.gmail.com:587 #发件人邮箱的smtp服务器
-xu YourEmail@gmail.com #用户名
-xp YOURPASSWORD #密码
-u &quot;Hello from sendEmail&quot; #邮件的标题
-m &quot;How are ... line.&quot; #邮件的内容
</code></pre><p>要注意的是发件人邮箱首先要开启stmp服务，如果密码中包含特殊字符，请用双引号包裹一下。<br><img src="https://i.loli.net/2018/07/01/5b38b5efabacf.png" alt="03.png"><br>正确的修改之后直接回车，看到successfully就说明发送成功了，如果这时候你并没有在邮箱中收到邮件，那么建议你去垃圾箱看一下。  </p>
<h1 id="将命令保存为bat并调用vps执行"><a href="#将命令保存为bat并调用vps执行" class="headerlink" title="将命令保存为bat并调用vps执行"></a>将命令保存为bat并调用vps执行</h1><p>为了能让Windows计划任务可以执行，我们将以上的cmd命令写成批处理命令，然后通过vbs调用这个bat，这样就可以将bat的运行过程隐藏了。  </p>
<h2 id="编辑bat"><a href="#编辑bat" class="headerlink" title="编辑bat"></a>编辑bat</h2><p>新建一个记事本文件，将要在cmd中执行的命令写进去：</p>
<blockquote>
</blockquote>
<pre><code>@echo off
ping 172.0.0.1 -n 100 #延时执行
f:
cd sendEmail-156
sendEmail -o tls=yes -f YourEmail@gmail.com -t SomeoneYoureEmailing@domain.com -s smtp.gmail.com:587 -xu YourEmail@gmail.com -xp YOURPASSWORD -u &quot;Hello from sendEmail&quot; -m &quot;How are you? I&apos;m testing sendEmail from the command line.&quot;
</code></pre><p>写完之后将记事本的txt格式改为bat，双击执行一下检查是否可以正常收到邮件。我在开头加入一条ping命令是为了延时执行，因为在通电之后并不能立马恢复网络，所以让它在发送100个包之后再去执行下面的命令，这个可根据情况自己选择。</p>
<h2 id="编辑vbs"><a href="#编辑vbs" class="headerlink" title="编辑vbs"></a>编辑vbs</h2><p>同样新建一个记事本文件，将以下命令复制进去：</p>
<blockquote>
</blockquote>
<pre><code>set ws=WScript.CreateObject(&quot;WScript.Shell&quot;) 
ws.Run &quot;d:\sendEmail-156\sendemail.bat&quot;,0
</code></pre><p>然后另存为vbs文件。</p>
<h1 id="添加Windows计划任务"><a href="#添加Windows计划任务" class="headerlink" title="添加Windows计划任务"></a>添加Windows计划任务</h1><p>win+r然后输入taskschd.msc打开Windows计划任务。</p>
<h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p><img src="https://i.loli.net/2018/07/01/5b38bb2192ec6.png" alt="04.png"></p>
<h2 id="输入任务名称配置改为自己的系统"><a href="#输入任务名称配置改为自己的系统" class="headerlink" title="输入任务名称配置改为自己的系统"></a>输入任务名称配置改为自己的系统</h2><p><img src="https://i.loli.net/2018/07/01/5b38bb2187e91.png" alt="05.png"><br>不要接着点确定，点上面的触发器。</p>
<h2 id="设置触发条件"><a href="#设置触发条件" class="headerlink" title="设置触发条件"></a>设置触发条件</h2><p><img src="https://i.loli.net/2018/07/01/5b38bb2183430.png" alt="06.png"></p>
<h2 id="新建操作"><a href="#新建操作" class="headerlink" title="新建操作"></a>新建操作</h2><p><img src="https://i.loli.net/2018/07/01/5b38bb21825a8.png" alt="07.png"><br>程序选择刚刚写的那个vbs文件，其它设置可以根据情况自己把握。  </p>
<p>这样，就可以在系统启动时收到一封邮件提醒了。<br>感谢您的访问，如果你有什么好的建议或想法，欢迎与我联系：</p>
<blockquote>
<p>email:<a href="mailto:666@cyne.cf" target="_blank" rel="noopener">666@cyne.cf</a><br>QQ:1543740487</p>
</blockquote>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>监控</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>ovs-vsctl: unix:/usr/local/var/run/openvswitch/db.sock: database connection failed</title>
    <url>/2019/03/13/ovs-vsctl-unix-usr-local-var-run-openvswitch-db-sock-database-connection-failed/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在OpenvSwitch中执行ovs-vsctl show命令时，出现如下错误提示：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl: unix:/usr/local/var/run/openvswitch/db.sock: database connection failed
</code></pre><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在每次重启开机之后执行如下命令：</p>
<blockquote>
</blockquote>
<pre><code>ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \
                 --remote=db:Open_vSwitch,Open_vSwitch,manager_options \
                 --private-key=db:Open_vSwitch,SSL,private_key \
                 --certificate=db:Open_vSwitch,SSL,certificate \
                 --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \
                 --pidfile --detach
ovs-vsctl --no-wait init
ovs-vswitchd --pidfile --detach
</code></pre>]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>OpenvSwitch</tag>
      </tags>
  </entry>
  <entry>
    <title>一键安装 Caddy+PHP7+Sqlite3 环境</title>
    <url>/2018/10/13/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85-Caddy-PHP7-Sqlite3-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>相信很多人都有自己搭建网站的需求，但个人网站一般都是个人博客之类的，并不需要很高的服务器配置，这时候就可以考虑使用一个配置比较低的vps来放置自己的个人网站，那么下面这个脚本包你可能刚好会用得到。  </p>
<p>这个脚本支持Centos 7+ Debian 8+，最小支持内存为64M，可以一键安装 typecho、wordpress、zblog、kodexplorer、laverna、一键整站备份等操作，不仅如此还可以安装v2ray、rinetdbbr来科学上网和加速。</p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>配置过程很简单，首先将自己的域名解析到vps的ip地址上。然后执行如下命令：</p>
<blockquote>
</blockquote>
<pre><code>wget -N --no-check-certificate git.io/c.sh &amp;&amp; chmod +x c.sh &amp;&amp; bash c.sh
</code></pre><p>安装完成后可以根据需要上传自己的网站或者选择一键安装：<br><strong>一键安装typecho博客</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -t
</code></pre><p><strong>一键安装wordpress博客</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -w
</code></pre><p><strong>一键安装zblog博客</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -z
</code></pre><p><strong>一键安装 kodexplorer 可道云</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -k
</code></pre><p><strong>一键安装 laverna 印象笔记</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -l
</code></pre><p><strong>一键整站备份（一键打包/www目录 含数据库）</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -a
</code></pre><p><strong>一键安装 v2ray 翻墙</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -v
</code></pre><p><strong>一键安装 rinetd bbr 端口加速</strong></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -b
</code></pre><p><strong>一键卸载命令：</strong></p>
<p><em>卸载 caddy</em></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -unc
</code></pre><p><em>卸载 php+sqlite</em></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -unp
</code></pre><p><em>卸载 v2ray</em></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -unv
</code></pre><p><em>卸载 rinetdbbr</em></p>
<blockquote>
</blockquote>
<pre><code>bash c.sh -unb
</code></pre><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3" target="_blank" rel="noopener">https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3</a></p>
]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>科学上网</tag>
        <tag>脚本</tag>
        <tag>vps</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>专治疑难杂症</title>
    <url>/2018/05/30/%E4%B8%93%E6%B2%BB%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
    <content><![CDATA[<h1 id="添加开机启动项"><a href="#添加开机启动项" class="headerlink" title="添加开机启动项"></a>添加开机启动项</h1><p>因为电脑装了某管家，不知道哪天自己把我的开机启动项给关了，只能手动添加回去，之前用的计划任务并不好用，今天知道了一个简单办法。<br>Windows有专门的启动目录，只要把想要开机启动的应用的快捷方式复制进去就可以了。<br>开机启动目录：</p>
<blockquote>
</blockquote>
<pre><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp
</code></pre><p>当然，有可能你根本找不到这个路径，只要把以上地址复制到地址栏，回车访问即可。  </p>
<p>这种方法虽然简单，但是也有一定的缺陷，就是必须在系统登陆后才能运行，也就是说如果你的电脑设有密码，必须在输入密码进入系统后才能运行相应程序。如果需要不登陆就运行的话可以采用计划任务或修改注册表等方式添加开机启动项。</p>
]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mysql8.0服务无法启动的问题</title>
    <url>/2018/11/29/%E5%85%B3%E4%BA%8Emysql8-0%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>如图：<br><img src="https://i.loli.net/2018/11/29/5bff526bca5e0.png" alt="02.png"><br>我下载的是mysql-8.0.13-winx64解压版本，但安装后出现如上图所示服务无法启动的问题。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>首先简单说明一下我的安装过程，将压缩包解压后在mysql的根目录创建“my.ini”，内容如下：</p>
<blockquote>
</blockquote>
<pre><code>[mysqld]  
#basedir代表自己MySQL的安装根目录  
basedir = E:\\mysql-8.0.13-winx64  
#datadir代表自己MySQL的数据库保存的目录  
datadir = E:\\mysql-8.0.13-winx64\\data  
#port代表端口号  
port = 3306  
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  
</code></pre><p><img src="https://i.loli.net/2018/11/29/5bff564b8580d.png" alt="03.png"></p>
<p>删除根目录下自带的data文件夹，原因下面会有说明。  </p>
<p>然后以管理员身份运行cmd，进入mysql根目录下的bin目录中。  </p>
<p>移除之前安装的服务：</p>
<blockquote>
</blockquote>
<pre><code>mysqld -remove
</code></pre><p>初始化：</p>
<blockquote>
</blockquote>
<pre><code>mysqld --initialize-insecure  #这里我使用的是无密的方式
</code></pre><p>这个步骤会重新生成data文件夹，需要等待一会。</p>
<p>重新安装mysql服务：</p>
<blockquote>
</blockquote>
<pre><code>mysqld -install
</code></pre><p>启动mysql服务：</p>
<blockquote>
</blockquote>
<pre><code>net start mysql
</code></pre><p><img src="https://i.loli.net/2018/11/29/5bff526bc3777.png" alt="01.png"></p>
<p>最后说明一下删除data文件夹的原因，网上很多教程里写的是直接在配置文件中写上data文件夹的路径就可以甚至没有data文件夹自己新建的一个。  </p>
<p>不能说那些教程里的做法就是错的，因为版本不同的原因，情况也不尽相同，新版本在初始化时会自动生成data文件夹，如果直接使用自带的data文件夹而不删除让它自动创建的话，很容易出错。</p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>利用kvm制作qcow2格式镜像</title>
    <url>/2020/06/18/%E5%88%A9%E7%94%A8kvm%E5%88%B6%E4%BD%9Cqcow2%E6%A0%BC%E5%BC%8F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="准备KVM环境"><a href="#准备KVM环境" class="headerlink" title="准备KVM环境"></a>准备KVM环境</h1><p>首先需要转杯KVM的环境，本文使用的是CentOS桌面版，因为没有现成的物理机环境，所以是在ESXI上创建的虚拟机，而由于是虚拟机，所以涉及潜逃虚拟化的问题，需要开启虚拟机的cpu虚拟化支持。<br>登录ESXI的web端，首先将虚拟机关机，然后编辑虚拟机设置，在cpu设置下勾选“硬件虚拟化”支持。<br><img src="https://i.loli.net/2020/06/18/pxbu9JKwcyGrQ7i.png" alt="01.png"><br>开启后打开虚拟机，确认虚机已开启cpu虚拟化：</p>
<blockquote>
</blockquote>
<pre><code>egrep -o &apos;(vmx|svm)&apos; /proc/cpuinfo
lscpu | grep Virtualization
</code></pre><p><img src="https://i.loli.net/2020/06/19/GAIFXMONC2ljpBZ.png" alt="02.png"><br><img src="https://i.loli.net/2020/06/19/wpykr8s7O9I2UgB.png" alt="03.png"></p>
<h1 id="使用kvm创建虚拟机"><a href="#使用kvm创建虚拟机" class="headerlink" title="使用kvm创建虚拟机"></a>使用kvm创建虚拟机</h1><p>安装virt-manager:</p>
<blockquote>
</blockquote>
<p>yum -y install virt-install<br>yum -y install virt-manager</p>
<p>安装完成后执行在终端执行virt-manager，打开虚拟机管理器：<br><img src="https://i.loli.net/2020/06/19/ycO5v7oABqgewj4.png" alt="04.png"><br>环境安装好后将下载好的操作系统镜像上传至环境种中，上传后使用虚拟机管理器创建kvm虚拟机：<br><img src="https://i.loli.net/2020/06/19/FEUBC1t4aHQ7cNe.png" alt="05.png"><br><img src="https://i.loli.net/2020/06/19/QdTmZr8qGkcIySH.png" alt="06.png"><br><img src="https://i.loli.net/2020/06/19/G9QRp3eE8rT1BAa.png" alt="07.png"></p>
<h1 id="压缩qcow2镜像大小"><a href="#压缩qcow2镜像大小" class="headerlink" title="压缩qcow2镜像大小"></a>压缩qcow2镜像大小</h1><p>kvm虚机安装完成后,登录虚机对虚拟机系统剩余空间进行写零操作：</p>
<blockquote>
</blockquote>
<p>dd if=/dev/zero of=/zero.dat<br>rm /zero.dat</p>
<p>关闭虚拟机，进入虚拟机存放目录下对原镜像进行转换压缩：</p>
<blockquote>
</blockquote>
<p>cd /var/lib/libvirt/images/<br>qemu-img convert -c -O qcow2 /path/old_image.qcow2 new_image.qcow2 #根据实际情况替换实际目录及文件名</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
        <tag>kvm</tag>
        <tag>qcow2</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Win2012在VMware环境下部署DHCP服务器的问题</title>
    <url>/2018/11/20/%E5%85%B3%E4%BA%8EWin2012%E5%9C%A8VMware%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="客户端无法获取来自DHCP地址池的正确ip"><a href="#客户端无法获取来自DHCP地址池的正确ip" class="headerlink" title="客户端无法获取来自DHCP地址池的正确ip"></a>客户端无法获取来自DHCP地址池的正确ip</h1><p>昨天在VMware WorkStation的Server 2012安装完DHCP服务之后，使用另一台虚拟机测试时怎么都获取不到正确的ip，给到的是一个不同于DHCP地址池的其它子网的ip地址，两个小时愣是没找出原因。  </p>
<p>今天早上终于找到了原因，在这里记录一下。</p>
<h1 id="原因简述"><a href="#原因简述" class="headerlink" title="原因简述"></a>原因简述</h1><p>VMware中的VMnet虚拟网卡默认开启了本地DHCP服务，虚拟机在使用dhcp自动获取ip时是从VMnet的本地dhcp拿到的ip地址，因为每个人的VMnet网卡设置的网段不一样，获取的ip地址就是VMnet设置的网段，比如我的VMnet子网地址是192.168.138.0，我拿到的ip地址就是这个网段内的地址。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><img src="https://i.loli.net/2018/11/20/5bf3caebf40da.png" alt="01.png"><br>打开虚拟网络编辑器，选择你正在使用的虚拟网卡，比如我使用的是仅主机模式，对应的就是我的VMnet1网卡。更改设置，将“使用本地DHCP服务将IP分配给虚拟机”取消勾选就可以了。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Windows Server</tag>
        <tag>DHCP</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>华为交换机console口密码重置</title>
    <url>/2019/10/24/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BAconsole%E5%8F%A3%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="设置console密码"><a href="#设置console密码" class="headerlink" title="设置console密码"></a>设置console密码</h1><p>因为之前已经把console密码删掉了，为了重现一下，重新设置一下console密码：</p>
<blockquote>
</blockquote>
<pre><code>&lt;HUAWEI&gt; system-view
[HUAWEI] user-interface console 0
[HUAWEI-ui-console0] authentication-mode password
[HUAWEI-ui-console0] set authentication password cipher Huawei@123
[HUAWEI-ui-console0] return
&lt;HUAWEI&gt; save
</code></pre><h1 id="密码重置"><a href="#密码重置" class="headerlink" title="密码重置"></a>密码重置</h1><p>将console线连接到设备的console口，打开Xshell或putty等连接设备，此时出现如下界面：<br><img src="https://i.loli.net/2019/10/24/btz7nFcoEJM924A.png" alt="00.png"><br>将交换机断电，然后上电设备自动启动，此时按Ctrl+B：<br><img src="https://i.loli.net/2019/10/24/ulg9wTbEKzchmFS.png" alt="01.png"><br>输入密码：<a href="mailto:Admin@huawei.com" target="_blank" rel="noopener">Admin@huawei.com</a> 进入BootLoad menu:<br><img src="https://i.loli.net/2019/10/24/aIX8drbJMwEjSWZ.png" alt="02.png"><br>输入数字：7，清除console用户的密码并输入：y确认清除：<br><img src="https://i.loli.net/2019/10/24/rfA9lYGCHeMIaib.png" alt="03.png"><br>弹出提示显示密码清除成功，然后再根据提示输入：1按默认模式启动，启动后就可以设置新密码了。选择：8，即可放弃此次重置并重启。<br><img src="https://i.loli.net/2019/10/24/Qv3cUwiOpxlJdoG.png" alt="04.png"><br>重启后登入设备输入：save保存，这样console密码就被清除了。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>华为</tag>
        <tag>console，密码重置</tag>
      </tags>
  </entry>
  <entry>
    <title>在ESXI环境中部署fuel openstack虚拟环境</title>
    <url>/2019/03/20/%E5%9C%A8ESXI%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%83%A8%E7%BD%B2fuel-openstack%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>一年之前就开始接触OpenStack，但是还没入门就放弃了，因为实验环境实在是太难装了，尝试了很多次均以失败告终，大多教程中都是安装devstack的方式进行部署，但是作为一个刚入门的小白，个人觉得这种方式可能并不是太友好。最近看了一份教程，了解到fuel openstack的部署方式，决定再尝试一下，据说这也是企业生产环境中经常用到的方式。<br>由于自己的电脑配置比较低，在笔记本上安装虚拟环境体验不是很好，正好身边有一套ESXI环境，所以尝试在ESXI环境中进行部署，尝试了很多次之后终于成功，在此记录一下部署过程，以供参考。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先下载fuel openstack镜像文件，主要有两个途径可以获取到fuel的镜像，第一个是fuel的官网，目前可以下载到9.0的版本。第二个是OpenStack的wiki，目前提供的最新版本是11.0：</p>
<blockquote>
</blockquote>
<p><a href="https://www.mirantis.com/software/openstack/" target="_blank" rel="noopener">https://www.mirantis.com/software/openstack/</a><br><a href="https://wiki.openstack.org/wiki/Fuel#Where_to_get_Fuel" target="_blank" rel="noopener">https://wiki.openstack.org/wiki/Fuel#Where_to_get_Fuel</a></p>
<h1 id="规划网络"><a href="#规划网络" class="headerlink" title="规划网络"></a>规划网络</h1><p>我的esxi主机所在网络为192.168.100.0/24网段，此网段对OpenStack来说也就是公网（Public），此外还需要有一个PXE网段，用于fuel部署系统，此外还有management、storage、private等网段，我们使用三块网卡来连接这三个网段。</p>
<h2 id="在ESXI中部署网络"><a href="#在ESXI中部署网络" class="headerlink" title="在ESXI中部署网络"></a>在ESXI中部署网络</h2><p>首先是创建两个新的虚拟交换机，选中esxi主机，点击配置，网络，添加网络：<br><img src="https://i.loli.net/2019/03/21/5c9394143c777.png" alt="01.png"><br>连接类型选择虚拟机：<br><img src="https://i.loli.net/2019/03/21/5c93948b28789.png" alt="02.png"><br>选择创建vSphere标准交换机，将下面的网卡取消勾选：<br><img src="https://i.loli.net/2019/03/21/5c9394ff6c53d.png" alt="03.png"><br>网络标签可以自行修改，vlan id选择全部：<br><img src="https://i.loli.net/2019/03/21/5c93955b01f35.png" alt="04.png"><br>编辑vSwitch属性，开启混杂模式：<br><img src="https://i.loli.net/2019/03/21/5c9395965b223.png" alt="05.png"><br>要注意左边列表中的两项都要开启<br><img src="https://i.loli.net/2019/03/21/5c939596595d3.png" alt="06.png"><br>用相同的方法再创建一个vSwitch，我这里分别是fuel_pxe和fuel_private：<br><img src="https://i.loli.net/2019/03/21/5c9394143c777.png" alt="01.png"><br>最后再修改以下vSwitch0的属性，修改如下两项：<br><img src="https://i.loli.net/2019/03/26/5c99754ebeec5.png" alt="31.png"><br><img src="https://i.loli.net/2019/03/26/5c99754ed633c.png" alt="32.png"></p>
<h1 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h1><p>fuel的架构如下图所示：<br><img src="https://i.loli.net/2019/03/21/5c93976f857b9.png" alt="09.png"><br>这里我没有部署单独的Storage节点，只部署三个节点：master、controller和compute，三个节点的配置及网卡连接情况如下：  </p>
<blockquote>
<p>master节点：</p>
<blockquote>
<p>8核 8G内存 100G存储 fuel_pxe vmnet vmnet</p>
</blockquote>
</blockquote>
<blockquote>
<p>controller节点：</p>
<blockquote>
<p>8核 8G内存 100G存储 fuel_pxe vmnet fuel_private</p>
</blockquote>
</blockquote>
<blockquote>
<p>compute节点</p>
<blockquote>
<p>8核 16G内存 200G存储 fuel_pxe vmnet fuel_private</p>
</blockquote>
</blockquote>
<h2 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h2><p>新建名称为fuel_master的虚拟机,网卡配置如下图所示：<br><img src="https://i.loli.net/2019/03/21/5c9395966aa1c.png" alt="07.png"><br>开机并挂载fuel镜像：<br><img src="https://i.loli.net/2019/03/21/5c939597b4d7e.png" alt="08.png"><br>选择第一项直接开始安装，安装时间较长，耐心等待其安装完成。<br>安装完成后登录master节点，修改一些配置，首先是配置一个我们可以连接的ip，默认情况下eth0的ip地址已经设置为10.20.0.2，我这里选择使用eth1进行修改：</p>
<blockquote>
</blockquote>
<pre><code>vim /etc/sysconfig/network-scrips/eth1
</code></pre><p>将配置文件中的ONBOOT=no改为yes,ip地址我这里使用的是dhcp分配的方式，当然你也可以手工指定。<br>修改完成后保存退出并重启网络:</p>
<blockquote>
</blockquote>
<pre><code>service network restart
</code></pre><p>然后允许ssh登录，默认情况下是只允许10.20.0.0/24这个网段登录的：</p>
<blockquote>
</blockquote>
<pre><code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
service iptables save
service iptables restart
</code></pre><p>查看eth1的ip地址，这时我们就可以使用eth1的ip访问mater的web界面了(浏览器通常会阻止访问，点击继续访问或添加例外即可)：<br><img src="https://i.loli.net/2019/03/22/5c943671a130c.png" alt="11.png"><br>使用默认用户名/密码：admin/admin登录，登录进去之后会提示修改密码，暂时先不修改。此外因为安装时master节点并没有连接外网，所以这时会有如下提示信息：<br><img src="https://i.loli.net/2019/03/22/5c94373142e10.png" alt="10.png"><br>有以下两种解决方式：</p>
<h3 id="联网方式"><a href="#联网方式" class="headerlink" title="联网方式"></a>联网方式</h3><p>根据提示信息执行命令：</p>
<blockquote>
</blockquote>
<pre><code>fuel-bootstrap build --activate
</code></pre><p>这种方式的前提是master节点可以连接到外网，而且根据网络环境的不同可能时间会比较长。另外这条命令在11.0的版本可以正常使用，而在9.0版本中貌似有些源已经访问不到了，所以推荐使用本地源。</p>
<h3 id="本地方式"><a href="#本地方式" class="headerlink" title="本地方式"></a>本地方式</h3><p>下载以下两个文件(如果失效可以自己google)：<br><em>mirrors.zip</em>：<a href="https://pan.baidu.com/s/1npQ2MBps6ypx2X_ebCJ2jg" target="_blank" rel="noopener">密码：j0yk</a><br><em>bootstraps.zip</em>：<a href="https://pan.baidu.com/s/1EeLLaenosPr2OLULw-VB_w" target="_blank" rel="noopener">密码：miwf</a></p>
<p>解压bootstrap.zip，上传“bootstrap”文件夹至master节点的<em>/var/www/nailgun/</em>目录下，覆盖原有bootstrap目录，然后执行如下命令：</p>
<blockquote>
</blockquote>
<pre><code>fuel-bootstrap activate d01c72e6-83f4-4a19-bb86-6085e40416e6  #激活bootstrap
fuel-bootstrap list   #查看处于活动状态的bootstrap
</code></pre><p>解压mirrors.zip，上传解压的“mirrors”文件夹至master节点的<em>/var/www/nailgun/</em>目录，</p>
<blockquote>
</blockquote>
<pre><code>fuel-createmirror   #在处于离线状态的master节点运行命令（会报错，直接忽略）
</code></pre><p>注意以上两个解压文件不要出现同名嵌套的文件夹，比如bootstrap文件夹下还有一个bootstrap文件夹。</p>
<h2 id="controller和compute节点"><a href="#controller和compute节点" class="headerlink" title="controller和compute节点"></a>controller和compute节点</h2><p>新建两台虚拟机，配置可以自行设置，我这里按上面预先规划的配置进行设置，重点是两个节点的网卡配置，如下分别是我的controller节点和compute节点配置：<br><img src="https://i.loli.net/2019/03/25/5c98db1d162a3.png" alt="27.png"><br><img src="https://i.loli.net/2019/03/25/5c98db1ce03c4.png" alt="26.png"><br>启动controller和compute两个节点，两个节点会自动从pxe完成启动进入bootstrap，登录fuel的web界面，mater节点已经获取到两个节点的基本信息：<br><img src="https://i.loli.net/2019/03/22/5c943c595f95c.png" alt="14.png"></p>
<h1 id="创建OpenStack环境"><a href="#创建OpenStack环境" class="headerlink" title="创建OpenStack环境"></a>创建OpenStack环境</h1><p>点击“New OpenStack Enviroment”创建一个OpenStack环境：<br><img src="https://i.loli.net/2019/03/22/5c943a1e20593.png" alt="12.png"><br>相关选项根据需要自己修改，我这里全部保持默认，点击<em>create</em>完成创建。  </p>
<h2 id="修改网络配置"><a href="#修改网络配置" class="headerlink" title="修改网络配置"></a>修改网络配置</h2><p>点击Networks进入网络配置页面，修改Public网段，即连接外网的网段：<br><img src="https://i.loli.net/2019/03/22/5c943da406cf0.png" alt="15.png"><br>同时需要修改L3的网络配置，L3需要跟Public处在同一网段且地址块不能重叠：<br><img src="https://i.loli.net/2019/03/22/5c943dff6d1ac.png" alt="16.png"><br>修改DNS：<br><img src="https://i.loli.net/2019/03/22/5c943e66ecd60.png" alt="17.png"><br>其它配置，建议勾选此选项，并将两个server地址设置为master节点的地址：10.20.0.2<br><img src="https://i.loli.net/2019/03/25/5c98dbe04cab6.png" alt="28.png"></p>
<h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><p>进入<em>Nodes</em>页面，点击<em>Add Nodes</em>添加已经发现到的两个节点并选择相应的角色：<br><img src="https://i.loli.net/2019/03/22/5c948f7d7dd43.png" alt="20.png"><br>上图是我第一遍操作时截的图，没有选择cinder角色，后来重新部署的时候遵从建议选择了cinder角色（fuel建议至少有一个cinder节点），这里也推荐大家部署cinder角色。在controller节点安装了cinder角色，补一个部署之后的截图：<br><img src="https://i.loli.net/2019/03/25/5c98de4957eac.png" alt="29.png"><br>点击节点右侧的齿轮按钮，设置一下接口配置，我的两个节点接口配置：<br><img src="https://i.loli.net/2019/03/22/5c94916f9bbc6.png" alt="22.png"></p>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>以上操作完成后到<em>Network</em>页面检查一下网络配置是否正确：<br><img src="https://i.loli.net/2019/03/22/5c949006bed85.png" alt="21.png"><br>检查通过就可以开始部署了，回到<em>Dashboard</em>页面，点击<em>Deploy Changes</em>开始部署：<br><img src="https://i.loli.net/2019/03/22/5c949299188fc.png" alt="24.png"><br>经过漫长的等待，最后部署成功：<br><img src="https://i.loli.net/2019/03/25/5c98df0dd505a.png" alt="30.png"><br>点击Horizon即可访问dashboard，输入用户名/密码：admin/admin登录：<br><img src="https://i.loli.net/2019/03/25/5c98df780c4df.png" alt="66.png"></p>
<h1 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h1><h2 id="sync-time-error"><a href="#sync-time-error" class="headerlink" title="sync_time error"></a>sync_time error</h2><p>时间同步错误，原因在于fuel主节点没有合适的时间同步，所以子节点无法完成时间同步，修改fuel主节点的ntp配置即可解决：</p>
<blockquote>
</blockquote>
<pre><code>vim /etc/ntp.conf
</code></pre><p>在server段添加如下内容,并将原来的server注释掉。</p>
<blockquote>
</blockquote>
<pre><code>server asia.pool.ntp.org  iburst minpoll 3 maxpoll 9
</code></pre><p>重启ntp服务：</p>
<blockquote>
</blockquote>
<pre><code>systemctl restart ntpdate.service
systemctl restart ntpd.service
</code></pre><h2 id="build-deploy-image-error"><a href="#build-deploy-image-error" class="headerlink" title="build_deploy_image error"></a>build_deploy_image error</h2><p>错误提示信息：<br>All nodes are finished. Failed tasks: Task[build_deploy_image/master] Stopping the deployment process!<br><img src="https://i.loli.net/2019/03/22/5c94aaf11fd3a.png" alt="25.png"><br>原因是master节点无法连接外网，修改相关网络配置即可，我这里是启用eth1网卡连接外网。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.51cto.com/goome/1916247" target="_blank" rel="noopener">https://blog.51cto.com/goome/1916247</a><br><a href="https://www.cnblogs.com/shoufengwei/p/6901173.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoufengwei/p/6901173.html</a><br><a href="https://blog.csdn.net/qq_35180983/article/details/82181496" target="_blank" rel="noopener">https://blog.csdn.net/qq_35180983/article/details/82181496</a></p>
]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
        <tag>Esxi</tag>
        <tag>fuel</tag>
      </tags>
  </entry>
  <entry>
    <title>Ventoy——N合一U盘装机神器</title>
    <url>/2020/08/30/Ventoy%E2%80%94%E2%80%94N%E5%90%88%E4%B8%80U%E7%9B%98%E8%A3%85%E6%9C%BA%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Ventoy简介"><a href="#Ventoy简介" class="headerlink" title="Ventoy简介"></a>Ventoy简介</h1><p><strong>官网介绍：</strong>Ventoy是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你只需要把ISO/WIM/IMG/EFI文件拷贝到U盘里面就可以启动了，无需其他操作。 你可以一次性拷贝很多个不同类型的ISO文件，在启动时Ventoy会显示一个菜单来选择。 无差异支持Legacy BIOS和UEFI模式。目前已经测试了各类超过470+个ISO文件。同时提出了”Ventoy Compatible”的概念，若被支持则理论上可以启动任何ISO文件。<br><img src="https://i.loli.net/2020/08/30/YydJIkWMUlaQnfA.png" alt="screen_bios2.png"><br>一句话概括就是可以用一个U盘制作成支持多种系统的启动盘，比如windows、linux以及ESXI等等等等，对于博主这种经常需要进机房装各种系统的人是很方便了。</p>
<h1 id="制作Ventoy启动盘"><a href="#制作Ventoy启动盘" class="headerlink" title="制作Ventoy启动盘"></a>制作Ventoy启动盘</h1><p>制作Ventoy U盘的话跟其它的PE工具类似，双击打开程序选择自己的U盘进行制作就可以了。  </p>
<blockquote>
</blockquote>
<p>Ventoy官方下载地址：<a href="https://www.ventoy.net/cn/download.html" target="_blank" rel="noopener">www.ventoy.net</a><br>一些相关的使用说明及插件使用等，感兴趣的朋友可以直接参考。</p>
<h1 id="定制自己的Ventoy"><a href="#定制自己的Ventoy" class="headerlink" title="定制自己的Ventoy"></a>定制自己的Ventoy</h1><p>因为Ventoy的启动菜单是基于grub的，所以理论上Ventoy对所有的grub主题都是可以支持的，其实主题修改在官方文档写的很清楚，但是因为我当时没有好好看上文所以折腾了一会时间，这里简单记录一下。  </p>
<h2 id="下载Ventoy并制作U盘"><a href="#下载Ventoy并制作U盘" class="headerlink" title="下载Ventoy并制作U盘"></a>下载Ventoy并制作U盘</h2><p>详细步骤略，大家都会。</p>
<h2 id="挑选下载grub主题"><a href="#挑选下载grub主题" class="headerlink" title="挑选下载grub主题"></a>挑选下载grub主题</h2><p>我们可以在官网推荐的<a href="https://www.gnome-look.org/browse/cat/109/order/latest/" target="_blank" rel="noopener">这个网站</a>,挑选一个自己喜欢的grub主题下载到本地并解压。<br>然后我们需要在制作好的U盘分区下创建一个”ventoy”目录，其实这个目录我们下载的ventoy压缩包里就已经包含了这个目录及全局配置文件等，我们可以直接拷贝到U盘并做一些简单的修改就好了。<br><img src="https://i.loli.net/2020/08/30/tQPuloOvsLaeR6K.png" alt="01.png"><br>可以看到这个ventoy目录下已经有主题目录及ventoy.json文件，也就是全局配置文件等，我们把这个目录拷贝到U盘后，用刚才下载的主题目录替换掉原本的主题。<br><img src="https://i.loli.net/2020/08/30/hjTRi75b1v2Pu9W.png" alt="02.png"></p>
<h2 id="修改全局配置文件"><a href="#修改全局配置文件" class="headerlink" title="修改全局配置文件"></a>修改全局配置文件</h2><p>修改U盘中主题的theme.txt的绝对目录为正确目录后，主题就应用成功了。<br><img src="https://i.loli.net/2020/08/30/TevCoaAfiDKIYHg.png" alt="03.png"><br>同时菜单栏也支持设置别名和ICON等，可以参考官方说明进行相应的修改。<br>最后附上我修改之后的Ventoy样式：<br><img src="https://i.loli.net/2020/08/30/nWBOjzRQroKPtl5.png" alt="04.png"><br>启动菜单的背景可以通过修改主题的theme.txt中的”desktop-image”参数修改。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.ventoy.net/cn/doc_news.html" target="_blank" rel="noopener">https://www.ventoy.net/cn/doc_news.html</a></p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>Ventoy</tag>
      </tags>
  </entry>
  <entry>
    <title>基于阿卡信自建聊天服务器</title>
    <url>/2018/06/03/%E5%9F%BA%E4%BA%8E%E9%98%BF%E5%8D%A1%E4%BF%A1%E8%87%AA%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一、安装JAVA和MAVEN环境"><a href="#一、安装JAVA和MAVEN环境" class="headerlink" title="一、安装JAVA和MAVEN环境"></a>一、安装JAVA和MAVEN环境</h1><p>这两个安装很简单，网上一大把的教程，因为我手头可用的只有一个Windows Server，所以这里只演示Win版的安装配置过程。</p>
<blockquote>
<p>①首先在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre10-downloads-4417026.html" target="_blank" rel="noopener">ORACLE官网</a>下载jre，然后直接运行安装就可以。<br>②同样，在<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">maven官网</a>下载maven的压缩包，具体的安装配置过程可以参考CSDN博主的<a href="https://blog.csdn.net/h312387398/article/details/79136960" target="_blank" rel="noopener">教程</a>。<br>③安装成功后，在cmd命令行分别用一下两条命令测试是否正确安装配置：</p>
<blockquote>
<p>java -version<br>mvn -v</p>
</blockquote>
</blockquote>
<h1 id="二、安装Akaxin服务端程序"><a href="#二、安装Akaxin服务端程序" class="headerlink" title="二、安装Akaxin服务端程序"></a>二、安装Akaxin服务端程序</h1><p>在<a href="https://github.com/akaxincom/openzaly/blob/master/README.md" target="_blank" rel="noopener">Github</a>下载官方提供的jar包，并移动到C盘目录下，在cmd中首先切换到本目录：cd C:\ <img src="https://i.loli.net/2018/06/03/5b1352a48dbf1.png" alt="aaa.png"><br>然后直接运行jar包：java -jar openzaly-server.jar 然后看到提示就说明启动成功了。</p>
<h1 id="三、安装客户端程序连接使用"><a href="#三、安装客户端程序连接使用" class="headerlink" title="三、安装客户端程序连接使用"></a>三、安装客户端程序连接使用</h1><p>最后就是下载客户端程序了，在<a href="https://www.akaxin.com/" target="_blank" rel="noopener">官网</a>下载客户端程序后，输入服务器ip地址就可以正常使用了。<br><img src="https://i.loli.net/2018/06/03/5b1354ced508f.jpg" alt="QQ图片20180603103858.jpg">这里需要注意的是，首个成员需要输入邀请码：000000进入，这样就会默认成为站点的管理员并提供管理权限。</p>
<h1 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h1><p>我在配置完成之后遇到一个问题就是用客户端连接服务器的时候提示：请稍后重试，解决的办法是在服务器的安全组策略中放行：2021/2021端口。<br><img src="https://i.loli.net/2018/06/03/5b1355a46befb.png" alt="snipaste_20180603_104228.png"></p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>阿卡信官网：<a href="https://www.akaxin.com/" target="_blank" rel="noopener">https://www.akaxin.com/</a><br>Github项目：<a href="https://github.com/akaxincom/openzaly" target="_blank" rel="noopener">https://github.com/akaxincom/openzaly</a><br>码云：<a href="https://gitee.com/akaxin/openzaly" target="_blank" rel="noopener">https://gitee.com/akaxin/openzaly</a><br>QQ群：655249600</p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>聊天服务器</tag>
        <tag>阿卡信</tag>
      </tags>
  </entry>
  <entry>
    <title>同时使用Github和码云部署博客</title>
    <url>/2019/07/18/%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8Github%E5%92%8C%E7%A0%81%E4%BA%91%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Gitee-Pages"><a href="#Gitee-Pages" class="headerlink" title="Gitee Pages"></a>Gitee Pages</h1><p>Gitee Pages是码云推出的一个静态网站服务，与Github Pages类似，这是官方给出的简单介绍：</p>
<blockquote>
</blockquote>
<p>码云Pages是一个免费的静态网页托管服务，您可以使用码云Pages托管博客、项目官网等静态网页。目前码云Pages支持Jekyll、Hugo、Hexo编译静态资源。</p>
<p>之前在部署自己博客的时候使用的是Hexo + Github Pages的方式，但是这种方式有一个最大的问题就是博客的访问速度问题，根据不同的运营商不同地点的网络，访问速度还会有些差别。忍无可忍，决定把博客迁移到码云上，但是使用了码云后发现这家伙有个特别人性化的功能——从GitHub同步。  </p>
<p>既然如此，与其迁移，还不如同时在两个仓库中同时部署。</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>首先注册一个<a href="https://gitee.com" target="_blank" rel="noopener">码云</a>账号，注册之后新建一个仓库：<br><img src="https://i.loli.net/2019/07/18/5d302cf5bed5a24580.png" alt="01.png"><br>到最下面找到导入已有仓库，点击并填写自己的GitHub仓库地址(.git结尾的链接)<br><img src="https://i.loli.net/2019/07/18/5d302db6c8dbf86321.png" alt="02.png"><br>仓库导入之后进入仓库，点击<strong>服务</strong>→<strong>Gitee Pages</strong>，部署目录不填，点击部署即可。<br><img src="https://i.loli.net/2019/07/18/5d302f3d46d7b67296.png" alt="03.png"><br>上图是我已经部署好之后的截图，当时忘记截图了，部署之后的网址应该是<strong>*.gitee.io/name这样的链接，我们打开这个链接会看到下面这样的网页：<br><img src="https://i.loli.net/2019/07/18/5d302fee7596d45273.png" alt="04.png"><br>原因是由于路径的问题，无法正确加载样式，我们只需要将链接后的二级目录去掉就好了。点击</strong>管理**，将仓库的路径设置为与用户名一样即可。<br><img src="https://i.loli.net/2019/07/18/5d3030e002a3d39741.png" alt="05.png"><br>访问Gitee Pages，幸福感扑面而来。</p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Github</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>安装VMware后没有虚拟网卡的解决方法</title>
    <url>/2018/11/22/%E5%AE%89%E8%A3%85VMware%E5%90%8E%E6%B2%A1%E6%9C%89%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>这两天好几位同学找我说在安装VMware后都出现了没有VMnet虚拟网卡的问题，经过数次尝试终于找到了比较靠谱点的解决方式。</p>
<h1 id="还原虚拟网络设置"><a href="#还原虚拟网络设置" class="headerlink" title="还原虚拟网络设置"></a>还原虚拟网络设置</h1><p>因为每个人的电脑环境不同，问题的原因当然也不会完全一样，在发现没有虚拟网卡的情况下，最先应该尝试的方法应该是找到虚拟网络编辑器，还原默认设置，这样移除虚拟网卡又重新安装激活后有的时候就解决问题了。</p>
<h1 id="清理注册表和历史痕迹"><a href="#清理注册表和历史痕迹" class="headerlink" title="清理注册表和历史痕迹"></a>清理注册表和历史痕迹</h1><p>在还原默认设置没有效果之后，就可以用下面说的这个方法，清除掉VMware的痕迹了。  </p>
<p>为什么需要这么做呢？因为我发现出现这个问题的电脑都是之前安装过VMware的，然后保留了注册表和部分历史文件的。  </p>
<h2 id="卸载VMware"><a href="#卸载VMware" class="headerlink" title="卸载VMware"></a>卸载VMware</h2><p>首先将VMware卸载掉，推荐使用专门的卸载工具，在卸载的同时会清理掉残留的文件和注册表等，当然没有卸载工具的话也没有关系，按照下面的步骤继续做就ok。</p>
<h2 id="清理注册表"><a href="#清理注册表" class="headerlink" title="清理注册表"></a>清理注册表</h2><p>使用专门的注册表清理工具清理掉VMware留下的注册表，这里我用的是CCleaner，直接百度找一个靠谱的网站下载就行，打开CCleaner之后点击注册表，扫描问题，等待扫描完成后选择修复选定的问题。这里会弹出提示询问你是否需要备份注册表，这里根据自己的需要选择就可以，我个人感觉没有必要去备份。最后点击修复所有问题，VMware残留的注册表就被删除掉了。  </p>
<h2 id="清理残留文件"><a href="#清理残留文件" class="headerlink" title="清理残留文件"></a>清理残留文件</h2><p>打开系统盘，搜索“vmware”，等待搜索完成后将找到的所有文件删除，可能会有一些文件无法删除，跳过这些文件就行。 </p>
<h2 id="重启计算机"><a href="#重启计算机" class="headerlink" title="重启计算机"></a>重启计算机</h2><p>推荐在这时候重启电脑，因为不重启的话重新安装上VMware后还是会没有网卡，给一台重装的时候就忘记了重启，安装后发现还是没有虚拟网卡，在安装之后重启之后就有了。所以最后重启应该也是可以的，但是不能没有这个操作。</p>
<h2 id="重新安装VMware"><a href="#重新安装VMware" class="headerlink" title="重新安装VMware"></a>重新安装VMware</h2><p>最后重新安装上VMware，打开网络适配器，看到你的VMnet1和VMnet8网卡，就说明成功了。</p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>虚拟网卡</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的SDN实验环境</title>
    <url>/2019/05/16/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84SDN%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>这学期开了SDN选修课程，虽然课程内容之前大部分都接触过，但是不同于之前在实验平台上的学习，上课用到的环境都是在自己电脑上安装部署，今天课程已经结束，这里对整个实验环境的安装部署以及一些使用上的问题做一个小总结，既是为了加深自己的理解，也希望给初学者一些参考。</p>
<h1 id="SDN实验环境简介"><a href="#SDN实验环境简介" class="headerlink" title="SDN实验环境简介"></a>SDN实验环境简介</h1><p>课程中使用的实验环境主要包括三个SDN控制器，分别是OpenDaylight、Floodlight以及ONOS，另外还有OpenvSwitch和mininet，其中有很多官方已经给出了虚拟机文件，我们只需要下载然后导入到VMware或者VirtualBox就可以了。</p>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><h2 id="OpenDaylight"><a href="#OpenDaylight" class="headerlink" title="OpenDaylight"></a>OpenDaylight</h2><p><strong>官网地址：</strong><a href="https://www.opendaylight.org" target="_blank" rel="noopener">www.opendaylight.org</a>  </p>
<p><img src="https://i.loli.net/2019/05/16/5cdd6274c5d6910580.png" alt="01.png"></p>
<p>ODL控制器的版本以元素周期表命名，截止到目前ODL已经发布了最新的氖(Neon)版本，可以在官网下载到各个版本的安装包以及安装教程等。  </p>
<p>具体的安装过程也可以参考我之前的两篇文章：</p>
<blockquote>
<p><a href="https://cyne.tk/2019/03/14/Ubuntu16-04%E5%AE%89%E8%A3%85OpenDaylight-Carbon/" target="_blank" rel="noopener">Ubuntu16.04安装OpenDaylight Carbon</a><br><a href="https://cyne.tk/2019/02/27/Ubuntu14-04%E5%AE%89%E8%A3%85OpenDaylight/" target="_blank" rel="noopener">Ubuntu14.04安装OpenDaylight(锂版本)</a></p>
</blockquote>
<h2 id="Floodlight"><a href="#Floodlight" class="headerlink" title="Floodlight"></a>Floodlight</h2><p><strong>官网地址：</strong><a href="http://www.projectfloodlight.org/" target="_blank" rel="noopener">www.projectfloodlight.org</a></p>
<p><img src="https://i.loli.net/2019/05/16/5cdd64d9c971f55579.png" alt="02.png"></p>
<p>同样，Floodlight的官网也提供了各个版本的下载地址以及相关文档等。另外，官方也给出了一个部署好的虚拟机文件，但是国内的下载速度不是很理想，需要扶墙下载。当然，我这里也有下载好的文件：</p>
<blockquote>
</blockquote>
<p>百度网盘：<a href="https://pan.baidu.com/s/1WrNJEqKtUkl9MnYPcjQ92w" target="_blank" rel="noopener">提取码：no1y</a></p>
<p>需要注意的是这并不是一个ovf或者ova文件，而是一个磁盘文件，所以不能直接导入使用，需要手动创建一台空虚拟机，并将此虚拟磁盘文件挂载到虚拟机上，这里我用VMware进行演示：</p>
<blockquote>
</blockquote>
<p>打开VMware，点击“创建新的虚拟机”，选择“自定义”，因为不需要安装操作系统，所以选择“稍后安装操作系统”，操作系统类型选择“Ubuntu 64位”，其它参数默认。  </p>
<blockquote>
<p>在选择磁盘时，选择“使用现有虚拟磁盘”，选择下载下来的vmdk文件，完成虚拟机创建，然后启动虚拟机就可以使用官方已经配置好的Floodlight虚拟机了。</p>
</blockquote>
<h2 id="ONOS"><a href="#ONOS" class="headerlink" title="ONOS"></a>ONOS</h2><p><strong>官网地址：</strong><a href="https://onosproject.org/" target="_blank" rel="noopener">onosproject.org</a><br>推荐到ONOS的wiki中下载安装包或者封装好的虚拟机文件：<br><strong>Wiki</strong>：<a href="https://wiki.onosproject.org/display/onos15/download+packages+and+tutorial+vms" target="_blank" rel="noopener">wiki.onosproject.org</a>  </p>
<p><img src="https://i.loli.net/2019/05/16/5cdd6a388293924243.png" alt="03.png"></p>
<p>当然，也可以选择自己安装ONOS控制器，一些基础的功能还是自己装的用起来好用一点，而一些特殊的项目如SDN-IP等则推荐在wiki中下载相应的虚拟机文件，具体的安装步骤可以参考我之前的文章：</p>
<blockquote>
</blockquote>
<p><a href="https://cyne.tk/2019/05/14/Ubuntu16-04%E5%AE%89%E8%A3%85ONOS-Hummingbird-1-7-1/" target="_blank" rel="noopener">Ubuntu16.04安装ONOS Hummingbird(1.7.1)</a></p>
<h2 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h2><p><strong>官网地址:</strong><a href="http://mininet.org/" target="_blank" rel="noopener">mininet.org</a>  </p>
<p><img src="https://i.loli.net/2019/05/16/5cdd6d7731e4f41000.png" alt="04.png"></p>
<p>mininet有三种安装方式，官方推荐直接下载封装好的虚拟机文件，因为这非常简单而且快捷，如果你是一个喜欢自己动手的人，那我推荐你通过安装包方式进行安装，具体的安装步骤可参考之前的文章：</p>
<blockquote>
</blockquote>
<p><a href="https://cyne.tk/2018/06/24/Mininet%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">Mininet的安装配置</a>  </p>
<p>*文章中同时安装了Ryu,如果只是单纯安装mininet可直接跳过此步骤。</p>
<h2 id="OpenvSwitch"><a href="#OpenvSwitch" class="headerlink" title="OpenvSwitch"></a>OpenvSwitch</h2><p><strong>官网地址：</strong><a href="http://www.openvswitch.org/" target="_blank" rel="noopener">www.openvswitch.org</a></p>
<p><img src="https://i.loli.net/2019/05/16/5cdd6e639d2ea35783.png" alt="05.png"></p>
<p>OpenvSwitch也有多种安装方式，我之前都是采用安装包方式进行安装，具体的安装过程可参考：</p>
<blockquote>
</blockquote>
<p><a href="https://cyne.tk/2018/12/28/Ubuntu16-04%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Open-vSwitch/" target="_blank" rel="noopener">Ubuntu16.04安装包方式安装Open vSwitch</a></p>
<h1 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h1><h2 id="Could-not-get-lock-var-lib-apt-lists-lock"><a href="#Could-not-get-lock-var-lib-apt-lists-lock" class="headerlink" title="Could not get lock /var/lib/apt/lists/lock"></a>Could not get lock /var/lib/apt/lists/lock</h2><p>Ubuntu在使用apt-get命令时经常出现如下图所示的问题：<br><img src="https://i.loli.net/2019/05/18/5cdf9b917dcd823093.png" alt="06.png"><br>解决方法：</p>
<blockquote>
</blockquote>
<pre><code>rm /var/lib/dpkg/lock
sudo dpkg --configure -a
apt update
</code></pre><h2 id="ONOS启动"><a href="#ONOS启动" class="headerlink" title="ONOS启动"></a>ONOS启动</h2><p>如果是从ONOS官网下载的1.15.0的虚拟机，启动方式略有不同：先双击桌面的”Setup ONOS Cluster”,然后双击打开“ONOS GUI”即为ONOS的Web界面，双击“ONOS CLI”即为ONOS的命令行控制台。<br><img src="https://i.loli.net/2019/05/18/5cdf9dc09eb8159715.png" alt="07.png"><br>另外，这个镜像的ONOS服务监听端口可能并不是6633端口而是6653端口：<br><img src="https://i.loli.net/2019/05/18/5cdf9fb66b75983582.png" alt="08.png"><br>在进行一些基础的实验时，比如使用Mininet连接ONOS控制器等，推荐使用自己手动安装的ONOS；而对一些特殊的实验，比如SDN-IP等则推荐下载对应的ONOS虚拟机。</p>
<h2 id="Floodlight启动"><a href="#Floodlight启动" class="headerlink" title="Floodlight启动"></a>Floodlight启动</h2><p>我在安装Floodlight时使用的是官方的虚拟机，通过如下命令启动Floodlight：</p>
<blockquote>
</blockquote>
<pre><code>cd floodlight
ant
java -jar target/floodlight.jar
</code></pre><h2 id="ovs-ofctl-s1-is-not-a-bridge-or-a-socket"><a href="#ovs-ofctl-s1-is-not-a-bridge-or-a-socket" class="headerlink" title="ovs-ofctl: s1 is not a bridge or a socket"></a>ovs-ofctl: s1 is not a bridge or a socket</h2><p>如图：<br><img src="https://i.loli.net/2019/05/18/5cdfa1bec4c2618876.png" alt="09.png"><br>解决方法：</p>
<blockquote>
</blockquote>
<pre><code>ovs-vsctl set bridge br0 datapath_type=netdev
</code></pre><h2 id="Mininet的一些常用命令"><a href="#Mininet的一些常用命令" class="headerlink" title="Mininet的一些常用命令"></a>Mininet的一些常用命令</h2><p>查看/修改主机IP地址：</p>
<blockquote>
</blockquote>
<pre><code>h1 ip addr show
h1 ifconfig
h1 ifconfig h1-eth0 10.0.0.1/24 up
</code></pre><p>查看交换机流表信息：</p>
<blockquote>
</blockquote>
<pre><code>ovs-ofctl dump-flows s1
ovs-ofctl -O OpenFlow13 dump-flows s1
</code></pre><p>连接控制器：</p>
<blockquote>
</blockquote>
<pre><code>mn --switch=ovsk --controller=remote,ip=172.16.75.117,port=6633
mn --controller=remote,ip=192.168.1.31 --switch=ovsk,protocols=OpenFlow13 --topo=linear,2
</code></pre>]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>SDN实验环境</tag>
      </tags>
  </entry>
  <entry>
    <title>新手必须掌握的Linux命令</title>
    <url>/2018/04/10/%E6%96%B0%E6%89%8B%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="常用的系统工作命令"><a href="#常用的系统工作命令" class="headerlink" title="常用的系统工作命令"></a>常用的系统工作命令</h2><h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>用于在终端输出字符串或变量提取后的值，格式为“echo[字符串|$变量]”。</p>
<h3 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h3><p>格式为“date[选项][+指定的格式]”。  </p>
<blockquote>
</blockquote>
<pre><code>%Y  #年
%m  #月
%d  #天
%H  #小时
%M  #分钟
%S  #秒
%j  #今年中的第几天
</code></pre><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>poweroff命令与shutdown等命令作用相同。</p>
<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>用于在终端中下载网络文件，格式为“wget[参数]下载地址”。</p>
<blockquote>
</blockquote>
<pre><code>-P  #下载到指定目录
-p  #下载页面所有资源，包括图片、视频等 
-b  #后台下载模式
-t  #最大尝试次数
-c  #断点续传
</code></pre><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>用于查看系统中的进程状态，格式为“ps[参数]”。</p>
<blockquote>
</blockquote>
<pre><code>-a  #显示所有进程（包括其他用户的进程）
-u  #用户以及其它详细信息
-x  #显示没有控制终端的进程
</code></pre><p>5种常见的进程状态：</p>
<blockquote>
</blockquote>
<pre><code>R(运行):进程正在运行或在运行队列中等待。
S(中断):进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。
D(不可中端):不响应系统异步信号，即便用kill命令也无法中断。
Z(僵死):进程已经终止，但描述符依然存在，依然占用系统资源。
T(停止):收到停止信号后停止运行。
</code></pre><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>用于动态地监视进程活动与系统负载等信息，类似Windows中的任务管理器。<br><img src="https://i.loli.net/2018/08/18/5b77e3c6aafc6.png" alt="top.png"><br>第一行：系统时间、运行时间、登录终端数、系统负载（三个数值分别表示1、5、15分钟内的平均值）<br>第二行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。<br>第三行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比。<br>第四行：物理内存总量、内存空闲量、内存使用量、作为内存缓存的内存量。<br>第五行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量。</p>
<h3 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h3><p>查询某个指定服务进程的PID值。</p>
<h3 id="kill-amp-killall"><a href="#kill-amp-killall" class="headerlink" title="kill &amp; killall"></a>kill &amp; killall</h3><p>kill：终止某个指定PID的服务进程。<br>killall：终止某个指定名称的服务做对应的全部进程。<br>在命令后加上一个&amp;符号，命令将进入后天执行。</p>
<h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h3><p>用于查看系统内核和系统版本等信息，通常使用<em>uname -a</em>。</p>
<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>用于查看系统的负载信息，显示系统时间、已运行时间、启用终端数以及平均负载等信息。</p>
<blockquote>
<p>平均负载指的是最近1、5、15分钟内的压力情况；<br>负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p>
</blockquote>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>显示当前系统中内存使用量信息，常用参数为“free -h”。</p>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>查看登入主机的用户终端信息。</p>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>查看所有本机的登录记录。</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>显示执行过的命令，默认能显示出当前用户执行过的最近1000条命令，自定义记录数量可修改/etc/profile中的HISTSIZE的值，记录保存在家目录(~)中的“.bash_history”文件中。<br>清空当前用户的历史记录：</p>
<blockquote>
</blockquote>
<pre><code>history -c
</code></pre><h3 id="sosreport"><a href="#sosreport" class="headerlink" title="sosreport"></a>sosreport</h3><p>手机系统配置及架构信息并输出诊断文档。</p>
<h2 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示用户当先所处的工作目录。</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><blockquote>
</blockquote>
<pre><code>cd -  #返回上一次所处的目录
cd ..  #进入上级目录
cd ~username  #切换到其他用户的家目录
</code></pre><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><blockquote>
</blockquote>
<pre><code>ls -l  #查看文件的属性、大小等详细信息
ls -ld  #查看目录属性信息
</code></pre><h2 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><blockquote>
</blockquote>
<pre><code>cat -n  #显示行号
</code></pre><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>查看内容较多的纯文本文件，可使用空格或回车键翻页。</p>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>查看纯文本文档的前N行，例如：</p>
<blockquote>
</blockquote>
<pre><code>head -n  6 .bash_profile #查看前6行
</code></pre><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>查看纯文本文档的后N行或持续刷新内容。例如：</p>
<blockquote>
</blockquote>
<pre><code>tail -n  6 .bash_profile
</code></pre><p>还有一种情况是持续刷新一个文件的内容，比如日志文件:</p>
<blockquote>
</blockquote>
<pre><code>tail -f /var/log/message
</code></pre><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>用于替换文本文件中的字符。</p>
<blockquote>
</blockquote>
<pre><code>cat anaconda-ks.cfg | tr [a-z] [A-Z]  #将文件中的小写替换为大写。
</code></pre><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>统计指定文本的行数、字数、字节数。</p>
<blockquote>
</blockquote>
<pre><code>-l  #只显示行数
-w  #只显示单词数
-c  #只显示字节数
</code></pre><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>查看文件的具体存储信息和时间等信息。</p>
<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>按列提取文本字符，用-f参数设置需要看的列数，用-d参数设置间隔符号。例如：</p>
<blockquote>
</blockquote>
<pre><code>[root@localhost etc]# head -n 3 passwd #查看前三行
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
[root@localhost etc]# cut -d: -f1 passwd #查看以“：”为间隔符的第一列内容
root
bin
daemon
adm
......
</code></pre><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>用于比较多个文件的差异。</p>
<blockquote>
</blockquote>
<pre><code>diff diff a1.txt a2.txt  #找出文件内容中的具体不同
diff --brief a1.txt a2.txt #直接输出结果判断结果
diff  -c a1.txt a2.txt  #描述文件具体的不同
</code></pre><h2 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h2><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>用于创建空白文件或设置文件的时间。</p>
<blockquote>
</blockquote>
<pre><code>-a  #仅修改“读取时间”（atime）
-m  #仅修改“修改时间”（mtime）
-d  #同时修改atime和mtime
</code></pre><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建空白目录。<br>mkdir还可以结合-p参数递归创建出具有嵌套关系的文件目录:</p>
<blockquote>
</blockquote>
<pre><code>mkdir -p a/b/c/d/e
</code></pre><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>用于复制文件或目录，格式为“cp[选项] 源文件 目标文件”。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>用于剪切文件或将文件重命名。<br>剪切操作不同于复制操作，因为它默认会把源文件删除掉，只保留剪切后的文件。</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除文件或目录。  </p>
<blockquote>
</blockquote>
<pre><code>-f #强制删除
-r #删除目录
</code></pre><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>用于按照指定大小和个数的数据块来复制文件或转换文件。<br>Linux系统中有一个名为/dev/zero的设备文件，这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以用作dd的输入文件，用来生成一个指定大小的文件。</p>
<blockquote>
</blockquote>
<pre><code>if    输入的文件名称
of    输出的文件名称
bs    设置每个“块”的大小
count 设置要复制“块”的个数
</code></pre><blockquote>
</blockquote>
<pre><code>[root@localhost Desktop]# dd if=/dev/zero of=56file count=1 bs=56M
1+0 records in
1+0 records out
58720256 bytes (59 MB) copied, 9.14974 s, 6.4 MB/s
</code></pre><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>查看文件的类型，格式为“file 文件名”。</p>
<h2 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>对文件进行压缩或解压。</p>
<blockquote>
</blockquote>
<pre><code>-c  创建压缩文件
-x  解压缩文件
-t  查看压缩包内有哪些文件
-z  用Gzip压缩或解压
-j  用bzip2压缩或解压
-v  显示压缩或解压的过程
-f  目标文件夹（必须放在最后一位）
-p  保留原始的权限和属性
-P  使用绝对路径压缩
-C  指定解压到的目录
</code></pre><p>例如：</p>
<blockquote>
</blockquote>
<pre><code>tar -czvf 压缩包名.tar.gz 要打包的目录
tar -xzvf 压缩包名.tar.gz
</code></pre><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>用于在文本中执行关键词搜索，并显示匹配的结果。</p>
<blockquote>
</blockquote>
<pre><code>-b  将可执行文件当作文本文件来搜索
-c  仅显示找到的行数
-i  忽略大小写
-n  显示行号
-v  反向选择——仅列出没有关键字的行
</code></pre><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>按照指定条件来查找文件，格式为“find[查找路径] 寻找条件 操作”。</p>
<blockquote>
</blockquote>
<pre><code>-name   匹配名称
-perm   匹配权限（mode为完全匹配，-mode为包含即可）
-user   匹配所有者
-nouser 匹配无所有者的文件
-group  匹配所有组
-nogroup匹配无所有组的文件
-mtime -n +n  匹配修改内容的时间（-n指n天以内，+n指n天以前）
-atime -n +n  匹配访问文件的时间（-n指n天以内，+n指n天以前）
-ctime -n +n  匹配修改文件权限的时间（-n指n天以内，+n指n天以前）
-newer f1 !f2 匹配比文件f1新但比f2旧的文件
--type  匹配文件类型
-size   匹配文件大小
-prune  忽略某个目录
</code></pre><h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><p>输入模式  命令模式  末行模式(冒号模式)<br>需要说明一点的是输入模式的三种进入方式(a,i,o,s):</p>
<blockquote>
</blockquote>
<pre><code>a #在光标后面一位输入
i #在光标当前位置输入
o #在光标的下面创建空行并输入
s #删除光标位置字符并输入
</code></pre><h2 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h2><blockquote>
</blockquote>
<pre><code>:w   保存文件但不退出vi  
:w file 将修改另外保存到file中，不退出vi  
:w!  强制保存，不推出vi  
:wq  保存文件并退出vi  
:wq! 强制保存文件，并退出vi  
:q 不保存文件，退出vi  
:q! 不保存文件，强制退出vi  
:e! 放弃所有修改，从上次保存文件开始再编辑  
</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><blockquote>
</blockquote>
<pre><code>dd  剪切光标所在整行
3dd 剪切从光标开始的三行
yy  复制光标所在整行
3yy 复制从光标开始的三行
u   撤销上一步操作
uu  撤销所有更改
p   将之前剪切或复制的内容粘贴到光标之后
0   跳转到行首
$   跳转到行末
/   查找字符串
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网工具 - WireGuard</title>
    <url>/2018/11/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B7%A5%E5%85%B7-WireGuard/</url>
    <content><![CDATA[<h1 id="WireGuard是什么？"><a href="#WireGuard是什么？" class="headerlink" title="WireGuard是什么？"></a>WireGuard是什么？</h1><p>WireGuard是一个构建快速、现代、安全的VPN的协议和工具套件，它具有以下优点：</p>
<blockquote>
</blockquote>
<p>使用最先进的加密技术，防范攻击（RSA，SHA广被诟病都将被淘汰）<br>性能远超OpenVPN<br>效率极高，WireGuard协议作为Linux内核模块运行<br>通用用途，支持嵌入式和非嵌入式设备<br>跨平台，初期只在Linux平台发布，现已支持所有平台<br>易用，用过OpenVPN等工具集的人都明白这其中的痛苦<br>工作在3层（链路层），支持漫游，地址变更对用户无感知，使用更简单，切换更平滑<br>使用UDP传输数据，轻量、高效、节能、节省带宽（适用于 IOT 领域）<br>基于GPLv2Linux Kernel 基于 GPLv2）免费开源  </p>
<p>Linus Torvalds对WireGuard的评价：</p>
<blockquote>
<p>Can I just once again state my love for it and hope it gets merged soon? Maybe the code isn’t perfect, but I’ve skimmed it, and compared to the horrors that are OpenVPN and IPSec, it’s a work of art.</p>
</blockquote>
<h1 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h1><h2 id="脚本要求"><a href="#脚本要求" class="headerlink" title="脚本要求"></a>脚本要求</h2><blockquote>
<p>仅适用于centos7<br>vps架构必须为KVM<br>centos7的内核大部分为3.10，不能正确安装，必须升级（已经集成在脚本中）</p>
</blockquote>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>1、下载并执行脚本：</p>
<blockquote>
</blockquote>
<pre><code>wget https://raw.githubusercontent.com/yobabyshark/wireguard/master/wireguard_install.sh &amp;&amp; chmod +x wireguard_install.sh &amp;&amp; ./wireguard_install.sh
</code></pre><p><img src="https://i.loli.net/2018/11/14/5bec1723904fd.png" alt="01.png"></p>
<p>2、输入“1”升级内核，按照提示重启。  </p>
<p>3、重启完成后，再次执行脚本：</p>
<blockquote>
</blockquote>
<pre><code>./wireguard_install.sh
</code></pre><p>4、输入“2”安装WireGuard。  </p>
<p>5、使用ftp工具连接vps，将<strong>/etc/wireguard</strong>目录下的client.conf下载到本地。</p>
<p>6、下载安装TunSafe，这是一个windows端的第三方客户端，因为官方windows版本的还没开发完成，先用这个软件代替，TunSafe已经开源，可以放心使用。<br>官网下载：<a href="https://tunsafe.com/download" target="_blank" rel="noopener">TunSafe</a></p>
<p>7、打开TunSafe，单击file，选择import file，将下载的client.conf导入到软件中。  </p>
<p>8、导入后会自动进行连接，进入全局代理模式，也就是所有流量都会被代理。</p>
<h1 id="其它平台客户端"><a href="#其它平台客户端" class="headerlink" title="其它平台客户端"></a>其它平台客户端</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>1、下载WireGuard安卓客户端：  </p>
<blockquote>
<p>Android客户端：<a href="https://f-droid.org/repo/com.wireguard.android_439.apk" target="_blank" rel="noopener">点此下载</a></p>
</blockquote>
<p>2、打开app，点击加号导入client.conf文件。</p>
<blockquote>
<p>这里可能会提示错误，原因是没有文件操作权限，去权限管理里给软件勾上存储权限即可。</p>
</blockquote>
<h1 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h1><p>Youtube视频地址：<a href="https://youtu.be/A1tdPsdBATw" target="_blank" rel="noopener">点击观看</a></p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>VPS</tag>
        <tag>WireGuard</tag>
      </tags>
  </entry>
  <entry>
    <title>无vCenter的ESXI环境克隆虚拟机</title>
    <url>/2019/10/15/%E6%97%A0vCenter%E7%9A%84ESXI%E7%8E%AF%E5%A2%83%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>最近在公司的服务器上新装了ESXI，因为没有装vCenter，不支持虚拟机克隆功能，无奈只能手动克隆，今天有时间简单记录一下克隆的方法和一个小细节。</p>
<h1 id="两个文件"><a href="#两个文件" class="headerlink" title="两个文件"></a>两个文件</h1><p><strong>.vmx:</strong>VMware虚拟机配置文件，为虚拟机系统文件，通常通过打开这个虚拟机文件以启动系统；通过编辑该文件可以实现某种配置需求。<br><strong>.vmdk:</strong>VMware虚拟磁盘文件，相当于真实PC的硬盘。</p>
<h1 id="克隆方法"><a href="#克隆方法" class="headerlink" title="克隆方法"></a>克隆方法</h1><p>首先选中要克隆虚拟机的服务器，然后选择“配置”，然后选择“存储器”，在右侧的存储器中选择你要克隆的虚拟机所在的数据存储。<br><img src="https://i.loli.net/2019/10/21/vL8lIVe7bBxXumf.png" alt="01.png"><br>右键“浏览数据存储”，新建一个文件夹（用于存放克隆的虚拟机文件），在左侧选择要克隆的虚拟机所在的文件夹，复制<strong>.vmx</strong>和<strong>.vmdk</strong>两个文件到新建的文件夹中。<br><img src="https://i.loli.net/2019/10/21/WSCz8nE3QBcpG7L.png" alt="02.png"><br>复制完成后，右键复制后的.vmx文件，选择添加到清单即可。<br>虚拟机启动后会有如下提示，选择“I Copied It”即可。<br><img src="https://i.loli.net/2019/10/21/3ut1DF7MfcdK2LU.png" alt="开启复制的虚拟机时.png"></p>
<h1 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h1><p>在实际的操作中，我发现了一点需要注意的小细节，如果只是单纯的复制我在上图标出来两个文件的话，那么你克隆出来的虚拟机会是你新装的操作系统时的状态，如果想完整克隆虚拟机的当前状态，应该复制虚拟机当前引用的磁盘文件。<br>编辑虚拟机设置，查看被克隆的虚拟机引用的磁盘文件。<br><img src="https://i.loli.net/2019/10/21/Q9CoxLidFsS4mUA.png" alt="03.png"><br>然后复制该文件：<br><img src="https://i.loli.net/2019/10/21/hGkLngAoWC9rE35.png" alt="04.png"></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>ESXI</tag>
        <tag>vCenter</tag>
        <tag>虚拟机克隆</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈几种快充技术</title>
    <url>/2018/11/07/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8D%E5%BF%AB%E5%85%85%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>原来的充电宝丢了，今天又在某宝上溜达买了一个，溜达的时候发现了好多的新名词，就索性查了一下，整理一下写在这里了。</p>
<h1 id="PD快充协议"><a href="#PD快充协议" class="headerlink" title="PD快充协议"></a>PD快充协议</h1><p>PD充电协议是USB-IF组织公布的功率传输协议，它可以使目前默认最大功率5V/2A的type-c接口提高到100W，同时谷歌宣布Android7.0以上的手机搭载的快充协议必须支持PD协议，意在统一快充市场。  </p>
<p>USB-PowerDelivery（USBPD）是目前主流的快充协议之一。是由USB-IF组织制定的一种快速充电规范。USBPD透过USB电缆和连接器增加电力输送，扩展USB应用中的电缆总线供电能力。该规范可实现更高的电压和电流，输送的功率最高可达100瓦，并可以自由的改变电力的输送方向。  </p>
<p>USBPD和Type-C的关系。经常会有人把USBPD和Type-C放在一起谈，甚至就把Type-C充电器叫做PD充电器。USBPD和Type-C其实是两码事，USBPD是一种快速充电协议，而Type-C则是一种新的接口规范。Type-C接口默认最大支持5V/3A，但在实现了USBPD协议以后，能够使输出功率最大支持到前文提到的100W。所以现在许多实用Type-C接口的设备都会支持USBPD协议。</p>
<p>USBPD的发展前景。USBPD现在已经发展到了USBPD3.0版本。在谷歌的推动下目USBPD已经收编了高通的QC快充协议，并获得了中国工信部的支持。</p>
<h1 id="QC-1-0-2-0-3-0"><a href="#QC-1-0-2-0-3-0" class="headerlink" title="QC 1.0/2.0/3.0"></a>QC 1.0/2.0/3.0</h1><p>Qualcomm Quick Charge 3.0（下文简称QC 3.0）快充技术不知不觉已经是Qualcomm第三代快充技术，前几年快充技术还没百家齐放的时候，QC门派的关注度还是蛮高的。前几年QC 1.0和QC 2.0仍然比较受手机厂商和消费者欢迎。尤其是QC 2.0技术，如今很多手机厂商的快充技术其实都是基于QC 2.0基础上延伸出来的，例如下文将会提到的Moto涡轮快充和vivo双引擎闪充。  </p>
<blockquote>
</blockquote>
<p><strong>QC 1.0</strong>：最高支持5V/2A充电功率。</p>
<blockquote>
<p><strong>QC 2.0</strong>：兼容5V/9V/12V/20V四档充电电压。  </p>
</blockquote>
<p><strong>QC 3.0</strong>：以200mV增量为一档，提供从3.6V到20V电压的灵活选择，让手机厂商能够根据自身需求调整最佳电压，达到预期电流，提供充电效率同时降低功耗和发热。目前市面上标配QC 3.0快充头并支持该协议手机有LG G5、小米手机5等。</p>
<h1 id="MTK：PumpExpress-Plus"><a href="#MTK：PumpExpress-Plus" class="headerlink" title="MTK：PumpExpress Plus"></a>MTK：PumpExpress Plus</h1><p>说完高通的，再来看看联发科的快充技术。  </p>
<p>联发科MTP Pump Express Plus快充技术，原理与高通QC快充基本相同，都是在恒定电流的同时，通过提升充电电压来获得更大的充电功率。最新的Pump Express 3.0宣称能够在20分钟内为智能手机充满70%电量，同时相比PumpExpress Plus功耗减少50%，间接降低发热。  </p>
<p>PumpExpress允许充电器根据电流决定充电所需的初始电压，通过内置的PMIC电源管理集成电路发出脉冲电流指令给充电器，调整输出电压，逐渐增加到最大充电电流。相比QC 3.0的200mV为一档增量的做法，PumpExpress 3.0电压微调幅度仅为10mV，理论最高可提供5A充电电流。  </p>
<h1 id="手机厂商快充协议"><a href="#手机厂商快充协议" class="headerlink" title="手机厂商快充协议"></a>手机厂商快充协议</h1><blockquote>
</blockquote>
<p>华为：FCP（Fast Charger Protocol）<br>三星：AFC<br>一加：DASH极速闪充<br>vivo:双引擎闪充<br>OPPO：VOOC闪充技术<br>Moto：涡轮快充技术<br>魅族：mCharge 3.0  </p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>快充</tag>
      </tags>
  </entry>
  <entry>
    <title>秒懂MBR和GPT分区表</title>
    <url>/2018/09/13/%E7%A7%92%E6%87%82MBR%E5%92%8CGPT%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的Apple分区图。<br>MBR的全称是Master Boot Record（主引导记录），MBR早在1983年IBM PC DOS 2.0中就已经提出。之所以叫“主引导记录”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。主引导扇区是硬盘的第一扇区。它由三个部分组成，主引导记录MBR、硬盘分区表DPT和硬盘有效标志。在总共512字节的主引导扇区里MBR占446个字节，偏移地址（0000H–0088H），它负责从活动分区中装载，并运行系统引导程序；第二部分是Partition table区（DPT分区表），占64个字节；第三部分是Magic number，占2个字节。 </p>
<h1 id="MBR分区表系统"><a href="#MBR分区表系统" class="headerlink" title="MBR分区表系统"></a>MBR分区表系统</h1><p>所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。  </p>
<p>分区表偏移地址为01BEH–01FDH，每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4，分别对应MBR的四个主分区。Magic number也就是结束标志字，偏移地址01FE–01FF的2个字节，固定为55AA，如果该标志错误系统就不能启动。   </p>
<p>MBR最大支持2.2TB磁盘，它无法处理大于2.2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区。 </p>
<h1 id="GPT分区表系统"><a href="#GPT分区表系统" class="headerlink" title="GPT分区表系统"></a>GPT分区表系统</h1><p>GPT的全称是Globally Unique Identifier Partition Table，意即GUID分区表，它的推出是和UEFI BIOS相辅相成的，鉴于MBR的磁盘容量和分区数量已经不能满足硬件发展的需求，GPT首要的任务就是突破了2.2T分区的限制，最大支持18EB的分区。 </p>
<p>而在分区数量上，GPT会为每一个分区分配一个全局唯一的标识符，理论上GPT支持无限个磁盘分区，不过在Windows系统上由于系统的限制，最多只能支持128个磁盘分区，基本可以满足所有用户的存储需求。在每一个分区上，这个标识符是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符。   </p>
<p>而在安全性方面，GPT分区表也进行了全方位改进。在早期的MBR磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT还为这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏，GPT会发觉这些破坏，并从磁盘上的其他地方进行恢复。  </p>
<p>小结：所以对于新平台用户（Intel 6系以后/AMD 900系列以后和A系列）来说，都强烈推荐使用GPT分区表格式，目前包括Windows Vista、7、8、8.1、10已经都支持读取和使用GPT分区表。而对于使用Windows 8、8.1、10的用户，换用GPT后开机启动速度也可以进一步得到显著提升。 </p>
<h1 id="BIOS-MBR"><a href="#BIOS-MBR" class="headerlink" title="BIOS+MBR"></a>BIOS+MBR</h1><p>这种方式是目前最常见的装机方式，所有的系统都会支持，兼容较老硬件，目前新电脑大多出厂时就使用UEFI方式启动。</p>
<h1 id="UEFI-GPT"><a href="#UEFI-GPT" class="headerlink" title="UEFI+GPT"></a>UEFI+GPT</h1><p>GPT与UEFI是相辅相成的，如果分区表系统是GPT，那么必须使用UEFI，传统的BIOS方式无法启动，这也就是为什么现在很多人在给新机器重装系统时无法启动的原因。  </p>
<p>UEFI+GPT还有一个优点就是开机速度更快，原因是开机时跳过外设检测，并且可以实现启动时原生分辨率，搭载固态硬盘开机时间很短，十秒左右。  </p>
<p>UEFI可用鼠标操作图形界面，不再是枯燥的蓝底白字的英文。由Intel提出，用于取代BIOS。UEFI的优越特性：可操作性、安全性、兼容性、可扩展性。  </p>
<p>主板为了兼容MBR分区表，一般会提供Legacy BIOS和UEFI BIOS启动模式选项，可以把UEFI设置成Legacy模式（传统模式）、打开CSM兼容模块，让其支持传统MBR启动，此时效果同BIOS+MBR。如果要使用UEFI模式安装Windows，就必须开启UEFI启动模式。</p>
<h1 id="系统支持性"><a href="#系统支持性" class="headerlink" title="系统支持性"></a>系统支持性</h1><p>目前64bit Windows Vista、7、8、8.1、10都已经支持GPT分区表，而Windows 8、8.1、10都已经原生支持UEFI，安装这些系统的时候：只要硬盘设置为GPT分区表，主板设置为UEFI启动后，就可以直接开始安装操作系统了。 而对于Windows Vista、7系统，就需要手动添加UEFI支持：我们可以找一份Windows 8或者10安装镜像，从安装文件中提取Bootmgfw.efi文件，重命名为BOOTX64.EFI，拷贝到win7安装文件的\EFI\Boot\下，如果没有BOOT文件夹新建一个即可。 </p>
<h1 id="修改为传统方式启动"><a href="#修改为传统方式启动" class="headerlink" title="修改为传统方式启动"></a>修改为传统方式启动</h1><p>如果实在是搞不明白或者像之前的我一样不太懂的话，可以使用分区助手将GPT改为MBR，如图：<br><img src="https://i.loli.net/2018/09/13/5b9a589d17e85.jpg" alt="1.jpg"><br>选中磁盘，在左侧菜单中选择“转换到MBR磁盘”：<br><img src="https://i.loli.net/2018/09/13/5b9a589cddfb3.jpg" alt="2.jpg"><br>转换成功：<br><img src="https://i.loli.net/2018/09/13/5b9a589d066d8.jpg" alt="3.jpg"><br>转换完成进行分区后，不要忘了把装系统的分区转换成活动分区：<br><img src="https://i.loli.net/2018/09/13/5b9a589d099b4.jpg" alt="4.jpg"><br>最后还是建议大家花几分钟时间了解一下UEFI的方式，这必定是未来的一个趋势，并不推荐采用上图将GPT修改为MBR的方式重装系统。</p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>装机</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>端口检测小工具:tcping</title>
    <url>/2019/01/27/%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B%E5%B0%8F%E5%B7%A5%E5%85%B7-tcping/</url>
    <content><![CDATA[<p>tcping是一个可以用来检测端口是否开启的小工具，从名字就可以看出这个跟我们经常使用的ping命令比较相似，不同之处在于，ping是基于ICMP协议，而tcping顾名思义使用的是tcp协议，且不支持udp，所以不能检测udp端口。  </p>
<h1 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h1><p>工具下载：<a href="https://pan.baidu.com/s/1bjyXW2w8Z18FUofMrdf_Ng" target="_blank" rel="noopener">提取码 cyne</a>   </p>
<p>将下载文件解压后粘贴到 <em>C:\WINDOWS\system32</em> 目录下后就可以直接在cmd中使用了，查看命令帮助：</p>
<blockquote>
</blockquote>
<pre><code>tcping /?
</code></pre><p><img src="https://i.loli.net/2019/01/27/5c4d123c40c13.png" alt="02.png"></p>
<p>比如我们检测本机的端口：<br>首先查看我们开放了哪些端口：</p>
<blockquote>
</blockquote>
<pre><code>netstat -a
</code></pre><p><img src="https://i.loli.net/2019/01/27/5c4d12f9320e5.png" alt="01.png"></p>
<p>可以看到我的135端口是处于监听状态，我们用tcping测试一下：</p>
<blockquote>
</blockquote>
<pre><code>tcping -f 127.0.0.1 135
</code></pre><p><img src="https://i.loli.net/2019/01/27/5c4d14489478c.png" alt="03.png"></p>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>tcping</tag>
      </tags>
  </entry>
  <entry>
    <title>简单识别Linux vps架构(xen,openvz,kvm)</title>
    <url>/2018/11/14/%E7%AE%80%E5%8D%95%E8%AF%86%E5%88%ABLinux-vps%E6%9E%B6%E6%9E%84-xen-openvz-kvm/</url>
    <content><![CDATA[<h1 id="安装virt-what"><a href="#安装virt-what" class="headerlink" title="安装virt-what"></a>安装virt-what</h1><blockquote>
</blockquote>
<pre><code>yum -y install virt-what
</code></pre><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><blockquote>
</blockquote>
<pre><code>virt-what
</code></pre><p>如图，这台vps是基于xen架构。<br><img src="https://i.loli.net/2018/11/14/5bec12288d430.png" alt="01.png"></p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>自建ssr服务器</title>
    <url>/2018/05/07/%E8%87%AA%E5%BB%BAssr%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="VPS购买"><a href="#VPS购买" class="headerlink" title="VPS购买"></a>VPS购买</h1><p><img src="https://i.loli.net/2018/05/07/5af051641868c.png" alt="vpsAO">昨天晚上看见了一个便宜的VPS没怎么想就买了，毕竟3.5刀一年，虽然平时对富强上网需求不是特别大，但是想借着这个便宜主机了解一下SSR的搭建使用，所以这点钱花的还是很值的我自己觉得。当然便宜也就意味着配置不会好了，96M内存，不过做SSR足够了。</p>
<h1 id="SSR安装部署"><a href="#SSR安装部署" class="headerlink" title="SSR安装部署"></a>SSR安装部署</h1><p>在这之前就有过搭建SSR的想法，所以当时找了一个比较不错的教程，写的比较详细，毕竟搭建SSR还是比较傻瓜的，没什么难度，按照提示写参数就行，教程地址：<a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">点这里</a>。<br>唯一的一个遗憾就是我买的这个VPS不支持教程里说的谷歌BBR加速，而且不知道是不是因为这个原因，我做出来的这个SSR延迟还是比较高的。如图：<br><img src="https://i.loli.net/2018/05/07/5af0549490164.png" alt="网速测试.png"><br>当然，网速还是不太稳定的，下午测试的时候是1M左右，晚上就到6.9M了，不过这也都无所谓了。</p>
<h1 id="SSR客户端"><a href="#SSR客户端" class="headerlink" title="SSR客户端"></a>SSR客户端</h1><p>最后附上Win和Android端的客户端  </p>
<blockquote>
<p>Windows：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank" rel="noopener">下载地址</a><br>Android：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases/download/3.4.0.8/shadowsocksr-release.apk" target="_blank" rel="noopener">下载地址</a></p>
</blockquote>
]]></content>
      <categories>
        <category>打鱼晒网</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化运维笔记 —— Linux</title>
    <url>/2018/06/25/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux下使用Rinetd来实现端口转发"><a href="#Linux下使用Rinetd来实现端口转发" class="headerlink" title="Linux下使用Rinetd来实现端口转发"></a>Linux下使用Rinetd来实现端口转发</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>centos</strong><br>0、对于centos，由于官方的源中并没有Rinetd，所以首先需要第三方源<br>32位系统：</p>
<blockquote>
</blockquote>
<pre><code>$ vim /etc/yum.repos.d/nux-misc.repo

[nux-misc]
name=Nux Misc
baseurl=http://li.nux.ro/download/nux/misc/el6/i386/
enabled=0
gpgcheck=1
gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro
</code></pre><p>64位系统：</p>
<blockquote>
</blockquote>
<pre><code>$ vim  /etc/yum.repos.d/nux-misc.repo:

[nux-misc]
name=Nux Misc
baseurl=http://li.nux.ro/download/nux/misc/el6/x86_64/
enabled=0
gpgcheck=1
gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro
</code></pre><p>1、安装Rinetd</p>
<blockquote>
</blockquote>
<pre><code>$ yum --enablerepo=nux-misc install rinetd
</code></pre><p><strong>Ubuntu</strong></p>
<blockquote>
</blockquote>
<pre><code>apt-get install rinetd
</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>端口转发的配置文件在<em>/etc/rinetd.conf</em><br>配置文件的格式：</p>
<blockquote>
</blockquote>
<pre><code>[bindaddress] [bindport] [connectaddress] [connectport]
绑定的地址    绑定的端口  连接的地址      连接的端口

[Source Address] [Source Port] [Destination Address] [Destination Port]
源地址            源端口         目的地址               目的端口
</code></pre><p>例如：</p>
<blockquote>
</blockquote>
<pre><code>0.0.0.0 8080 172.19.94.3 8080
0.0.0.0 2222 192.168.0.103 3389
1.2.3.4 80 192.168.0.10 80
allow *.*.*.*
logfile /var/log/rinetd.log
</code></pre><p>说明  </p>
<blockquote>
<p>0.0.0.0表示本机绑定所有可用地址<br>将所有发往本机8080端口的请求转发到172.19.94.3的8080端口<br>将所有发往本机2222端口的请求转发到192.168.0.103的3389端口<br>将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口<br>allow设置允许访问的ip地址信息,<em>.</em>.<em>.</em>表示所有IP地址<br>logfil设置打印的log的位置  </p>
</blockquote>
<h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><blockquote>
</blockquote>
<pre><code>pkill rinetd  ##关闭进程
rinetd -c /etc/rinetd.conf  ##启动转发
</code></pre><p>把命令加到/etc/rc.local里面就可以开机自动运行</p>
<h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="默认编辑器nano"><a href="#默认编辑器nano" class="headerlink" title="默认编辑器nano"></a>默认编辑器nano</h2><p>用习惯了vim编辑器，有时候想修改配置文件，可设备又没网，Ubuntu默认使用的是nano编辑器，真心不如vim好用。</p>
<blockquote>
</blockquote>
<pre><code>ctrl+X  #退出
ctrl+O  #保存
</code></pre><h2 id="Ubuntu设置静态ip"><a href="#Ubuntu设置静态ip" class="headerlink" title="Ubuntu设置静态ip"></a>Ubuntu设置静态ip</h2><p>通过修改“/etc/network/interfaces”进行修改，<br><img src="https://i.loli.net/2018/06/25/5b30f4ef9991f.png" alt="QQ图片20180625214835.png"><br>注：在设置多个DNS服务器的时候要加“s”,如：</p>
<blockquote>
</blockquote>
<pre><code>dns-nameservers 114.114.114.114 8.8.8.8
</code></pre><p>修改之后需要执行：  </p>
<blockquote>
</blockquote>
<pre><code>sudo /etc/init.d/networking restart
</code></pre><p>使用这个方式修改ip地址，修改完interfaces文档中的内容后，需要修改/etc/NetworkManager/NetworkManager.conf文档中的managed参数，使之为true，并重启。否则，会提示说“有线网络设备未托管”。<br>重启网络或系统之后就修改完成了。  </p>
<h2 id="安装TeamViewer"><a href="#安装TeamViewer" class="headerlink" title="安装TeamViewer"></a>安装TeamViewer</h2><p>teamviewer远程登录的方式不建议使用！<br>1、到TeamViewer官网下载对应版本的安装包。<br>2、下载完成之后切换到下载目录，执行：</p>
<blockquote>
</blockquote>
<pre><code>sudo dpkg -i teamviewer_13.0.9865_amd64.deb
</code></pre><p>版本号要根据下载的包进行更改。<br>这时候可能会报出如下错误：</p>
<blockquote>
</blockquote>
<pre><code>正在选中未选择的软件包 teamviewer。 
(正在读取数据库 … 系统当前共安装有 253291 个文件和目录。) 
正准备解包 teamviewer_13.0.6634_amd64.deb … 
正在解包 teamviewer (13.0.6634) … 
dpkg：警告：无法删除原有的目录 /var/log/teamviewer12 ：目录非空 
dpkg: 依赖关系问题使得 teamviewer 的配置工作不能继续： 
teamviewer 依赖于 qtdeclarative5-dialogs-plugin (&gt;= 5.2) | qml-module-qtquick-dialogs (&gt;= 5.2)；然而： 
未安装软件包 qtdeclarative5-dialogs-plugin。 
未安装软件包 qml-module-qtquick-dialogs。 
dpkg: 处理软件包 teamviewer (–install)时出错： 
依赖关系问题 - 仍未被配置 
正在处理用于 desktop-file-utils (0.22-1ubuntu5.1) 的触发器 … 
正在处理用于 gnome-menus (3.13.3-6ubuntu3.1) 的触发器 … 
正在处理用于 bamfdaemon (0.5.3~bzr0+16.04.20160824-0ubuntu1) 的触发器 … 
Rebuilding /usr/share/applications/bamf-2.index… 
正在处理用于 mime-support (3.59ubuntu1) 的触发器 … 
正在处理用于 hicolor-icon-theme (0.15-0ubuntu1) 的触发器 … 
在处理时有错误发生： 
teamviewer
</code></pre><p>目前我遇到的有两种解决方式：<br>一、修复依赖关系</p>
<blockquote>
<p>一种解决方法是执行如下命令修复依赖关系：   </p>
</blockquote>
<pre><code>sudo apt install f
</code></pre><p>执行完后再安装看看能否成功，如果还是不成功就要采用第二种方式了。<br>二、更新源地址</p>
<blockquote>
<p>①删除安装到一半的teamviewer：</p>
</blockquote>
<pre><code>sudo apt-get remove teamviewer
</code></pre><p>②在Ubuntu的<a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">源列表</a>中找到对应系统的源，复制到/etc/apt/sources.list 里面，并把原来的链接注释掉。<br>③更新系统软件：</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get update #更新软件列表
sudo apt-get upgrade #更新软件
</code></pre><p>④运行安装命令：</p>
<blockquote>
</blockquote>
<pre><code>sudo dpkg -i teamviewer_13.0.9865_amd64.deb
</code></pre><p>3、在TeamViewer的使用中发现经常在系统重启后连接就出现“未知原因”的问题，原因还在摸索中，目前能解决的方法就是卸载重新安装：</p>
<blockquote>
</blockquote>
<pre><code>apt purge teamviewer
sudo dpkg -i teamviewer_13.0.9865_amd64.deb
</code></pre><h2 id="16-04出现“The-system-is-running-in-low-graphics-mode”"><a href="#16-04出现“The-system-is-running-in-low-graphics-mode”" class="headerlink" title="16.04出现“The system is running in low-graphics mode”"></a>16.04出现“The system is running in low-graphics mode”</h2><p>在虚拟机中安装的Ubuntu16.04无法显示完全，尝试修改分辨率后会卡死，然后重启就会出现如题所示的错误。<br>解决方法为：<br>1、重启虚拟机，按ctrl + alt + F1 进入纯字符界面，输入账号和密码<br>2、执行如下命令：</p>
<blockquote>
</blockquote>
<pre><code>cd /etc/X11
sudo cp xorg.conf.failsafe xorg.conf #刷新配置文件
sudo reboot
</code></pre><p>重启之后就可以正常显示了。</p>
<h2 id="启用root用户"><a href="#启用root用户" class="headerlink" title="启用root用户"></a>启用root用户</h2><p>执行：</p>
<blockquote>
</blockquote>
<pre><code>sudo passwd root
</code></pre><p>设置密码后即可使用su直接切换为root用户。<br><img src="https://img-blog.csdn.net/20160722112307840" alt></p>
<h2 id="安装GNOME-Shell桌面"><a href="#安装GNOME-Shell桌面" class="headerlink" title="安装GNOME Shell桌面"></a>安装GNOME Shell桌面</h2><p>1、安装GNOME Shell</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install gnome-shell
</code></pre><p>安装过程中出现如下界面，选择lightdm：<br><img src="https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2014/06/Switch_between_gdm_and_lightgdm_Ubuntu.jpeg" alt><br>2、退出当前账户，选择GNOME桌面系统<br>3、重新登陆，安装gnome-tweak</p>
<blockquote>
</blockquote>
<pre><code>sudo apt-get install gnome-tweak-tool
</code></pre><p>tweak是主题管理工具，具体使用方法参见：<br><a href="https://itsfoss.com/install-switch-themes-gnome-shell/" target="_blank" rel="noopener">https://itsfoss.com/install-switch-themes-gnome-shell/ </a><br>4、使用tweak更换主题<br>方法参考：<br><a href="https://itsfoss.com/gnome-shell-themes-ubuntu-1404/" target="_blank" rel="noopener">https://itsfoss.com/gnome-shell-themes-ubuntu-1404/</a>  </p>
<h2 id="执行sudo-apt-get-update出错"><a href="#执行sudo-apt-get-update出错" class="headerlink" title="执行sudo apt-get update出错"></a>执行sudo apt-get update出错</h2><p>在运行sudo apt-get update时出现如下信息：</p>
<blockquote>
</blockquote>
<pre><code>Reading package lists... Done
E: Problem executing scripts APT::Update::Post-Invoke-Success
&apos;if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli;
then appstreamcli refresh &gt; /dev/null;
fi&apos;
E: Sub-process returned an error code
</code></pre><p>解决方法如下：</p>
<blockquote>
</blockquote>
<pre><code>sudo pkill -KILL appstreamcli
wget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.deb
sudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb
</code></pre><p>或者：</p>
<blockquote>
</blockquote>
<pre><code>apt show appstream
sudo apt remove appstream
</code></pre><h2 id="Ubuntu在虚拟机中显示不全的问题"><a href="#Ubuntu在虚拟机中显示不全的问题" class="headerlink" title="Ubuntu在虚拟机中显示不全的问题"></a>Ubuntu在虚拟机中显示不全的问题</h2><p>关于这个问题之前也是尝试了无数的方法，今天无意间明白了原因并解决了问题。<br>1、首先要明白的是不是随便一个分辨率都可以更改，首先执行以下命令查询当前的显示状态：</p>
<blockquote>
</blockquote>
<pre><code>xrandr
</code></pre><p><img src="https://img-blog.csdn.net/20150602205903147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhczEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br>其中第一个带*的就是当前的分辨率，其下的数值是我们可以更改的分辨率，每个虚拟机可能略有不同。<br>2、执行：</p>
<blockquote>
</blockquote>
<pre><code>xrandr -s 1440x900_59.9
</code></pre><p>即可将分辨率设置为1440x900。<br>3、上述命令只能临时修改，永久修改需要执行：</p>
<blockquote>
</blockquote>
<pre><code>xrandr --output Virtual1 --mode 1440x900
</code></pre><p>其中“Virtual1”是显示器的名称，要根据执行xrandr返回的信息进行相应的替换。<br>4、错误<br>这些也是我自己遇到的一点问题。</p>
<blockquote>
<p>①有时候执行步骤3中所说的命令并不能永久更改，重启后会失效。目前一个方法就是在系统设置→显示中应用一下更改过来的分辨率，这样在重启之后就不会出现问题了。<br>②“xrandr: Configure crtc 0 failed”  </p>
<blockquote>
<p>这是一个系统bug，在设置,关于这台计算机,检查更新。更新完重启后就没问题了。</p>
</blockquote>
</blockquote>
<h2 id="Ubuntu16-04安装VNC"><a href="#Ubuntu16-04安装VNC" class="headerlink" title="Ubuntu16.04安装VNC"></a>Ubuntu16.04安装VNC</h2><p>“VNC有很多选择，VNC4server，tigervncserver等等，都不推荐，难装又难用。经过多次实验和测试，最后只采用x11vnc作为VNC服务器端。” <a href="https://blog.csdn.net/longhr/article/details/51657610" target="_blank" rel="noopener">查看原文</a><br>1、安装X11VNC</p>
<blockquote>
</blockquote>
<pre><code>sudo apt install x11vnc -y
</code></pre><p>2、配置访问密码</p>
<blockquote>
</blockquote>
<pre><code>sudo x11vnc -storepasswd /etc/x11vnc.pass 
</code></pre><p>3、创建服务</p>
<blockquote>
</blockquote>
<pre><code>vi  /lib/systemd/system/x11vnc.service
</code></pre><blockquote>
<p>粘贴如下代码：</p>
</blockquote>
<pre><code>[Unit]
Description=Start x11vnc at startup.
After=multi-user.target
[Service]
Type=simple
ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared
[Install]
WantedBy=multi-user.target
</code></pre><p>4、配置防火墙，配置并启动服务</p>
<blockquote>
</blockquote>
<pre><code>sudo ufw allow 5900
sudo systemctl enable x11vnc.service
sudo systemctl daemon-reload
</code></pre><p>如果出现如下图所示的错误，就说明第三步中你的配置信息粘贴错误了，修改正确即可解决。<img src="https://i.loli.net/2018/06/30/5b37243cc1a2e.jpg" alt="QQ图片20180630142539.jpg"><br>5、重启系统</p>
<blockquote>
</blockquote>
<pre><code>reboot
</code></pre><h2 id="Ubuntu14-04安装VNC"><a href="#Ubuntu14-04安装VNC" class="headerlink" title="Ubuntu14.04安装VNC"></a>Ubuntu14.04安装VNC</h2><p>1、安装X11VNC</p>
<blockquote>
</blockquote>
<pre><code>sudo apt install x11vnc -y
</code></pre><p>2、配置访问密码</p>
<blockquote>
</blockquote>
<pre><code>sudo x11vnc -storepasswd /etc/x11vnc.pass 
</code></pre><p>3、创建配置文件</p>
<blockquote>
</blockquote>
<pre><code>sudo touch /etc/init/x11vnc.conf
</code></pre><p>4、赋予权限</p>
<blockquote>
</blockquote>
<pre><code>sudo chmod a+w /etc/init/x11vnc.conf
</code></pre><p>5、在配置文件中加入以下内容：</p>
<blockquote>
</blockquote>
<pre><code>start on login-session-start
</code></pre><blockquote>
<pre><code>script 
x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -rfbport 5900 
end script 
</code></pre></blockquote>
<p>6、重启</p>
<blockquote>
</blockquote>
<pre><code>reboot
</code></pre><h2 id="nat123配置"><a href="#nat123配置" class="headerlink" title="nat123配置"></a>nat123配置</h2><p>nat123端口映射是专业的内网端口映射软件，在内网启动映射后，可在外网轻松访问连接内网网站等应用，不需要设置路由器，不需要公网ip,不需要固定ip,不需要动态域名。  </p>
<p>Ubuntu配置过程：（其它linux直接参考<a href="http://www.nat123.com/pages_17_600.jsp" target="_blank" rel="noopener">官网说明</a>）<br>0、注册账号<br>没有注册过账号的先到官网注册：<a href="http://www.nat123.com/" target="_blank" rel="noopener">http://www.nat123.com/</a><br>1、安装mono运行环境</p>
<blockquote>
</blockquote>
<pre><code>apt-get  install  mono-complete
</code></pre><p>安装完成后执行“mono -V”可查看安装的版本信息。<br>2、客户端安装</p>
<blockquote>
</blockquote>
<pre><code>cd  /opt
mkdir  nat123
cd  /nat123
wget  http://www.nat123.com/down/nat123linux.tar.gz
tar  -zxvf  nat123linux.tar.gz
</code></pre><p>3、启动客户端</p>
<blockquote>
</blockquote>
<pre><code>cd  /opt/nat123
mono  nat123linux.sh
</code></pre><p>输入用户名和密码登录成功后，直接结束当前进程，然后执行如下命令改为后台运行：</p>
<blockquote>
</blockquote>
<pre><code>cd  /opt/nat123
mono  nat123linux.sh service &amp;
ps  -ef|grep  nat123 #查看nat123状态
</code></pre><p>4、登录网页添加端口映射或动态域名解析</p>
<h1 id="RHEL"><a href="#RHEL" class="headerlink" title="RHEL"></a>RHEL</h1><h2 id="系统意外重启后VNC连接失败"><a href="#系统意外重启后VNC连接失败" class="headerlink" title="系统意外重启后VNC连接失败"></a>系统意外重启后VNC连接失败</h2><p>在服务器中运行着几个RHEL实例，VNC是之前老师配置的，这几个实例在服务器断电重启之后会出现VNC连接出错的问题。解决方法如下：</p>
<blockquote>
</blockquote>
<pre><code>cd /tmp
rm -rvf .X11-unix #手动删除因为VNC非正常退出未删除的文件
vncserver :3 #重启服务
</code></pre><h2 id="RHEL7设置开机自动连接网络"><a href="#RHEL7设置开机自动连接网络" class="headerlink" title="RHEL7设置开机自动连接网络"></a>RHEL7设置开机自动连接网络</h2><p>前几天在服务器上新装了一个RHEL7的虚拟机，不知道是不是镜像的原因，虚拟机默认设置是开机后网络连接处于断开状态，查了一下只需要修改一个配置参数即可。  </p>
<p>进入“/etc/sysconfig/network-scripts”目录，编辑“ifcfg-en”开头的文件：  </p>
<p><img src="https://i.loli.net/2018/11/18/5bf14690c4c96.png" alt="01.png"><br>在文件中找到“ONBOOT”选项，将原来的“no”改为“yes”即可。  </p>
<p><img src="https://i.loli.net/2018/11/18/5bf146b60bc36.png" alt="02.png"></p>
<h1 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h1><h2 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h2><p>CentOS 6:</p>
<blockquote>
</blockquote>
<pre><code>date -R #查看时区
cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #修改时区
</code></pre><p>CentOS 7:</p>
<blockquote>
</blockquote>
<pre><code>timedatectl set-timezone Asia/Shanghai
</code></pre>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>运维</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化运维笔记——vsphere</title>
    <url>/2018/07/11/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94vsphere/</url>
    <content><![CDATA[<h1 id="设置虚拟机随主机自动启动"><a href="#设置虚拟机随主机自动启动" class="headerlink" title="设置虚拟机随主机自动启动"></a>设置虚拟机随主机自动启动</h1><h2 id="0、选择虚拟机所在主机"><a href="#0、选择虚拟机所在主机" class="headerlink" title="0、选择虚拟机所在主机"></a>0、选择虚拟机所在主机</h2><p>单击选择虚拟机所在的主机，在后侧选项卡中选择“配置”<br><img src="https://i.loli.net/2018/07/11/5b45e78a91f56.png" alt="snipaste_20180711_190241.png"></p>
<h2 id="1、设置属性"><a href="#1、设置属性" class="headerlink" title="1、设置属性"></a>1、设置属性</h2><p>单击右上角的属性<br><img src="https://i.loli.net/2018/07/11/5b45e78a8af69.png" alt="snipaste_20180711_184912.png"></p>
<h2 id="2、设置虚拟机自动启动"><a href="#2、设置虚拟机自动启动" class="headerlink" title="2、设置虚拟机自动启动"></a>2、设置虚拟机自动启动</h2><p>勾选“允许虚拟机与系统一起自动启动和停止”，然后在“启动顺序”中将需要设置自动启动的虚拟机上移到自动启动一栏下，如果有需要，可根据情况设置启动延迟，最后点击确定即可。<br><img src="https://i.loli.net/2018/07/11/5b45e78a90520.png" alt="snipaste_20180711_185154.png"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>运维</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo建站记录</title>
    <url>/2018/03/03/hexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="建站过程"><a href="#建站过程" class="headerlink" title="建站过程"></a>建站过程</h1><p>在遇到各种各样问题之后，终于搭建完成了这个博客。</p>
<blockquote>
<p>其实回过头看看也并不是很麻烦，只是遇到了许多问题，有些是因为设备环境的问题，比如在测试“ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>“这条命令时，一直提示”bad address“错误，让人很费解，重装环境重新来过还是报错，只好最后换了一台电脑就没有出现这个错误。当然经验证这个并不会影响整个博客的搭建，只要密钥复制的正确这些都不碍事。</p>
<p>还有一个问题是因为教程的问题，在修改主配置文件的“deploy”部署时，教程写的是https地址，我也是多次尝试也没成功，最后百度到原因写ssh地址就可以解决。当然也不能一概而论，若没有错误还是推荐使用https地址。</p>
</blockquote>
<p>一个个的小地方就让我走了不少的弯路。最后终于找到一个比较详细准确的教程，在此分享给大家，在这也感谢作者<a href="http://fanzhenyu.me/categories/Hexo/" target="_blank" rel="noopener">Line</a>, 无意侵犯作者原作，只是想让像我这样的小白少走些弯路。作者博客中有五篇关于hexo使用的教程，个人觉得比较适合小白看。</p>
<p>这就是这次建站的一些小心得，水平有限有什么说的不对的地方也感谢各位不吝赐教。</p>
<h1 id="后期添加："><a href="#后期添加：" class="headerlink" title="后期添加："></a>后期添加：</h1><h2 id="添加网易云音乐插件"><a href="#添加网易云音乐插件" class="headerlink" title="添加网易云音乐插件"></a>添加网易云音乐插件</h2><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2018/03/10/5aa3e1773eb4d.png"><br>在别人的博客看到了这样一个音乐插件，实现很简单，打开<a href="http://music.163.com/#/outchain/0/2134628828/" target="_blank" rel="noopener">网易云音乐网页版</a>，选择自己想要分享的歌单，然后点击生成外链播放器即可，插件分为两种形式：iframe插件和flash插件，可根据情况选择。</p>
</blockquote>
</blockquote>
<h2 id="添加particles-js背景动画"><a href="#添加particles-js背景动画" class="headerlink" title="添加particles.js背景动画"></a>添加particles.js背景动画</h2><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2018/03/11/5aa49a5ee0df1.jpg" alt="particles.js.jpg"><br>particles.js是一个粒子效果的js插件，在<a href="https://github.com/VincentGarreau/particles.js/" target="_blank" rel="noopener">Github</a>里可以找到这个项目的源码，但是百度了一下配置方法大多是在html中实现，反正我是小白，不知道怎么修改。回归正题，怎么在Hexo中实现particles.js效果呢？<br><br><strong>1.</strong>首先在<strong>\themes\next\layout\_layout.swig</strong>的<strong>&lt; /body &gt;</strong>标签上面添加</p>
</blockquote>
</blockquote>
<pre><code>{% if theme.canvas_nest %}
	 <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
	{% endif %}
</code></pre><blockquote>
<blockquote>
<p><strong>2.</strong>在<strong>\themes\next\_config.yml</strong>中添加以下字段开启此功能：</p>
</blockquote>
</blockquote>
<pre><code># background settings
# add canvas-nest effect
# see detail from https://github.com/hustcc/canvas-nest.js
canvas_nest: true
</code></pre><blockquote>
<blockquote>
<p><strong>3.</strong>这样动态效果就添加成功了，你会发现博客默认的白色背景遮挡了大部分区域使得只有边缘能看见动态效果，这时候只要修改一下背景颜色即可。在<strong>\themes\next\source\css\_schemes\Pisces_layout.styl</strong>中，把<strong>.content-wrap</strong>中的<strong>background</strong>修改为<strong>none</strong>，注意我这里使用的是<strong>Pisces</strong>主题，如果你使用的是别的主题，在相应路径下修改即可。这样如果用手机打开体验会比较差，我们单独设置一下手机，把<strong>.content-wrap</strong>的<strong>+mobile()</strong>中的<strong>background</strong>修改为<strong>white</strong>，这样手机端的体验就好很多，却又不影响电脑端的炫酷动画。</p>
</blockquote>
</blockquote>
<h2 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h2><blockquote>
<blockquote>
<p>写出来的文章如果直接在首页全篇显示就比较别扭了，为了提高浏览体验，这时候就需要设置一下文章摘要了，我这里主要介绍三种方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>1.</strong>在文章中使用<font color="blue"><strong>&lt; !–more–&gt;</strong></font></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>2.</strong>在文章中的<font color="blue"><strong>front-matter</strong></font>中添加<font color="blue"><strong>description</strong></font>，并提供文章摘录。如图：<br><img src="https://i.loli.net/2018/03/11/5aa4d99ca9490.png" alt="description.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>3.</strong>在主题配置文件中设置自动摘要</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
</blockquote>
<pre><code>auto_excerpt:
enable: true
length: 150 #默认摘要为150字，可根据需要更改
</code></pre></blockquote>
<h2 id="needmoreshare2分享按钮"><a href="#needmoreshare2分享按钮" class="headerlink" title="needmoreshare2分享按钮"></a>needmoreshare2分享按钮</h2><p>今天才知道jiathis已经于2018年4月30日关闭了旗下的分享业务，所以今天改成了needmoreshare2，在nest的配置文件中预先已经加入了此功能，只需要简单的启用修改一下就可以用了。<br><img src="https://i.loli.net/2018/09/04/5b8e8af589e63.png" alt="snipaste_20180904_213720.png"></p>
<blockquote>
<p><strong>postbottom:</strong>文章底部分享按钮<br><strong>float:</strong>浮动按钮<br><strong>iconStyle:</strong>按钮的样式</p>
<blockquote>
<p><em>default:</em><img src="https://i.loli.net/2018/09/04/5b8e8d300f176.png" alt="snipaste_20180904_214818.png"><br><em>box:</em><img src="https://i.loli.net/2018/09/04/5b8e8d2fd6d3c.png" alt="snipaste_20180904_214810.png"></p>
</blockquote>
</blockquote>
<h2 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h2><p>打开网址：</p>
<blockquote>
</blockquote>
<pre><code>http://7u2ss1.com1.z0.glb.clouddn.com/love.js
</code></pre><p>复制网址中的代码，在<strong>/themes/next/source/js/src</strong>路径下，新建<strong>love.js</strong>并将刚刚复制的代码复制进去。然后编辑<strong>\themes\next\layout_layout.swig</strong>文件，在末尾加上如下代码：</p>
<blockquote>
</blockquote>
<pre><code>&lt;!-- 页面点击小红心 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;
</code></pre><p>如图：<br><img src="https://i.loli.net/2018/09/04/5b8e915b185bb.png" alt="snipaste_20180904_220551.png"></p>
<h2 id="修改文章底部标签符号"><a href="#修改文章底部标签符号" class="headerlink" title="修改文章底部标签符号"></a>修改文章底部标签符号</h2><p>默认的标签符号是一个“#”，个人觉得并不是很好看，所以决定修改一下。<br>修改模板<strong>/themes/next/layout/_macro/post.swig</strong>，搜索rel=”tag”&gt;#，将 # 换成<i class="fa fa-tag"></i>，注意是只替换“#”。<br><img src="https://i.loli.net/2018/09/04/5b8e93265c828.png" alt="snipaste_20180904_221216.png"></p>
<h2 id="侧边栏旋转头像"><a href="#侧边栏旋转头像" class="headerlink" title="侧边栏旋转头像"></a>侧边栏旋转头像</h2><p>首先先把头像打开，在主题配置文件中，将如下图中的avatar前的#去掉，然后将自己的头像放到<strong>themes\next\source\images</strong>路径下，并将配置文件中默认的avatar.gif修改为头像的文件名。<br><img src="https://i.loli.net/2018/09/05/5b8fe67d02c33.png" alt="snipaste_20180905_222132.png"><br>然后就是设置头像旋转了，打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：</p>
<blockquote>
</blockquote>
<pre><code>.site-author-image {
display: block;
margin: 0 auto;
padding: $site-author-image-padding;
max-width: $site-author-image-width;
height: $site-author-image-height;
border: $site-author-image-border-width solid $site-author-image-border-color;

/* 头像圆形 */
border-radius: 80px;
-webkit-border-radius: 80px;
-moz-border-radius: 80px;
box-shadow: inset 0 -1px 0 #333sf;

/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 
(1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/


/* 鼠标经过头像旋转360度 */
-webkit-transition: -webkit-transform 1.0s ease-out;
-moz-transition: -moz-transform 1.0s ease-out;
transition: transform 1.0s ease-out;
}

img:hover {
/* 鼠标经过停止头像旋转 
-webkit-animation-play-state:paused;
animation-play-state:paused;*/

/* 鼠标经过头像旋转360度 */
-webkit-transform: rotateZ(360deg);
-moz-transform: rotateZ(360deg);
transform: rotateZ(360deg);
}

/* Z 轴旋转动画 */
@-webkit-keyframes play {
0% {
-webkit-transform: rotateZ(0deg);
}
100% {
-webkit-transform: rotateZ(-360deg);
}
}
@-moz-keyframes play {
0% {
-moz-transform: rotateZ(0deg);
}
100% {
-moz-transform: rotateZ(-360deg);
}
}
@keyframes play {
0% {
transform: rotateZ(0deg);
}
100% {
transform: rotateZ(-360deg);
}
}
</code></pre><h2 id="底部全站字数统计"><a href="#底部全站字数统计" class="headerlink" title="底部全站字数统计"></a>底部全站字数统计</h2><p>如图：<br><img src="https://i.loli.net/2018/09/06/5b91112daf59a.png" alt="snipaste_20180906_193500.png"><br>在根目录下，执行：</p>
<blockquote>
</blockquote>
<pre><code>$ npm install hexo-wordcount --save
</code></pre><p>然后在/themes/next/layout/_partials/footer.swig末尾加上：</p>
<blockquote>
</blockquote>
<pre><code>&lt;div class=&quot;theme-info&quot;&gt;
  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;
  &lt;span class=&quot;post-count&quot;&gt;博客全站共{{ totalcount(site) }}字&lt;/span&gt;
&lt;/div&gt;
</code></pre><h2 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h2><p>刚才设置了全站的总字数统计，接下来设置一下单篇文章的字数统计，如图：<br><img src="https://i.loli.net/2018/09/06/5b9113bbadca9.png" alt="snipaste_20180906_194648.png"><br>首先在根目录下安装hexo-wordcount,执行：</p>
<blockquote>
</blockquote>
<pre><code>$ npm install hexo-wordcount --save
</code></pre><p>然后在主题配置文件中，将post_wordcount的选项改为true：<br><img src="https://i.loli.net/2018/09/06/5b91141ef222f.png" alt="snipaste_20180906_194831.png"></p>
<h2 id="网站顶部加载进度条"><a href="#网站顶部加载进度条" class="headerlink" title="网站顶部加载进度条"></a>网站顶部加载进度条</h2><p>在主题配置文件中，搜索pace，改为true启用功能：<br><img src="https://i.loli.net/2018/09/06/5b9118d692026.png" alt="snipaste_20180906_200843.png"><br>有多种表示加载进度的样式，可根据自己喜好选择。</p>
<h2 id="添加来必力评论系统"><a href="#添加来必力评论系统" class="headerlink" title="添加来必力评论系统"></a>添加来必力评论系统</h2><p>新建这个博客的时候我用的是gitment，但是使用效果并不是很理想，今天开始使用来必力了，但愿这个能命久一点。<br>首先到<a href="https://livere.com/insight/myCode" target="_blank" rel="noopener">https://livere.com/insight/myCode</a>注册并获取安装代码，在代码里找到自己的id，也就是下图中这个位置：<br><img src="https://i.loli.net/2018/09/06/5b911deff3ba5.png" alt="snipaste_20180906_202604.png"><br>然后在主题配置中找到<strong>livere_uid</strong>，将你的id复制上就ok了：<br><img src="https://i.loli.net/2018/09/06/5b91201514b13.png" alt="snipaste_20180906_203922.png"></p>
<h2 id="valine评论系统"><a href="#valine评论系统" class="headerlink" title="valine评论系统"></a>valine评论系统</h2><p>首先在<a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a>注册账号并创建一个应用，很简单这里不做赘述，需要主要的是注册的时候填写的邮箱最好不要用私人域名邮箱，我在第一次注册时填写的是自己的域名邮箱导致接收不到验证邮件，后来使用163邮箱就ok了。  </p>
<p>然后修改主题配置文件，找到valine字段，将在LeanCloud中创建应用的<em>appid</em>和<em>appkey</em>复制到配置文件中，并将<em>enable: false</em>修改为<em>true</em>：<br><img src="https://i.loli.net/2019/01/28/5c4ede7c0c674.png" alt="04.png"><br>配置完成后的样式：<br><img src="https://i.loli.net/2019/01/28/5c4ede7c9790a.png" alt="05.png"></p>
<h2 id="侧边栏返回顶部按钮"><a href="#侧边栏返回顶部按钮" class="headerlink" title="侧边栏返回顶部按钮"></a>侧边栏返回顶部按钮</h2><p>之前默认使用的是右下角的返回顶部按钮，后来发现侧边栏的这个返回顶部按钮还带有阅读进度。<br>在<em>next/_config.yml</em>里找到<em>b2t</em>这个地方进行如下配置：</p>
<blockquote>
</blockquote>
<pre><code># Back to top in sidebar (only for Pisces | Gemini).
b2t: true
# Scroll percent label in b2t button.
scrollpercent: true
</code></pre><h2 id="添加视频"><a href="#添加视频" class="headerlink" title="添加视频"></a>添加视频</h2><blockquote>
</blockquote>
<pre><code>Idina Menze和Caleb Hyles激情对唱Let It Go：
&lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;
</code></pre><h2 id="修改nexT主题中Pisces的宽度"><a href="#修改nexT主题中Pisces的宽度" class="headerlink" title="修改nexT主题中Pisces的宽度"></a>修改nexT主题中Pisces的宽度</h2><p>突然感觉主题默认宽度有点窄，遂改之。编辑<strong>themes\next\source\css_variables\custom.styl</strong>文件，添加如下内容：</p>
<blockquote>
</blockquote>
<pre><code>$main-desktop = 1200px 
$content-desktop = 900px
</code></pre><p>修改后的效果：<br><img src="https://i.loli.net/2019/07/18/5d2fcf3e065ef90509.png" alt="06.png"></p>
<h1 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h1><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档|Hexo</a><br><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT</a></p>
</blockquote>
<h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><blockquote>
<p><a href="https://walesexcitedmei.github.io/2018/08/30/HEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC/" target="_blank" rel="noopener">walesexcitedmei.github.io</a></p>
</blockquote>
<h1 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h1><p>在使用hexo博客的过程中，遇到了如下一些错误：</p>
<h2 id="123-125-引起的报错"><a href="#123-125-引起的报错" class="headerlink" title="&#123; &#125;引起的报错"></a>&#123; &#125;引起的报错</h2><p>今天写了一篇博客后按流程进行部署的时候，发现在生成静态页面的时候出现了如下的错误：<br><img src="https://i.loli.net/2018/03/25/5ab780018abe1.png" alt="snipaste_20180325_163706.png"></p>
<p><img src="https://i.loli.net/2018/03/25/5ab780018a55d.png" alt="snipaste_20180325_163648.png"></p>
<p>查了一下说什么的都有，每个方法也都试了一遍，最后发现是因为文章中直接引用了”&#123; &#125;”的原因，解决办法是将”&#123; &#125;”通过&amp;#123  &amp;#125后面加上分号”;”进行转换，就可以正常部署了。<br>这里也有一些常见的<a href="https://blog.csdn.net/chwshuang/article/details/52350551" target="_blank" rel="noopener">特殊字符</a>,可以根据需要转换。<br><img src="https://i.loli.net/2018/03/25/5ab786e34f254.png" alt="特殊字符.png"></p>
<h2 id="标题无法正常解析"><a href="#标题无法正常解析" class="headerlink" title="标题无法正常解析"></a>标题无法正常解析</h2><p>在浏览别人的博客的时候发现Hexo有自动解析目录的功能，是依靠markdown的标题实现的，在加了一个<strong>“#标题”</strong>这样时却发现博客无法解析到这是一个标题，查了一下原因是正规的标题写法是在”#”和标题之间加一个空格。</p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>一开始刚刚接触markdown的时候一直用html的&#60;br/&#62;换行，这种换行方式貌似在换行的同时增加了行间距，无意间发现一个更好也更简单的换行方式，就是在要换行的位置敲两个空格，就可以换行。</p>
<h2 id="FATAL-Cannot-read-property-‘replace’-of-null"><a href="#FATAL-Cannot-read-property-‘replace’-of-null" class="headerlink" title="FATAL Cannot read property ‘replace’ of null"></a>FATAL Cannot read property ‘replace’ of null</h2><p>今天在修改站点配置文件进行操作时报出“FATAL Cannot read property ‘replace’ of null”的错误：<br><img src="https://i.loli.net/2018/09/03/5b8d3def88e87.png" alt="snipaste_20180903_214210.png"><br>上网查了一下原因是url地址不能为空，按照注释要求改为相应地址即可。</p>
<h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>之前每次使用<strong>hexo d</strong>上传一次文章都需要重新设置自定义域名，也是很苦恼，今天终于找到了原因。<br>在GitHub代码库中有一个CNAME文件，存放着我们修改的自定义域名：<br><img src="https://i.loli.net/2019/01/26/5c4c3d323f6f8.png" alt="02.png"><br>而我在本地并没有这个文件，所以每次在执行hexo d上传了本地的文件后，GitHub中的CNAME就被覆盖掉了，所以需要在设置中设置自定义域名，其实也就是创建这个CNAME文件的过程。<br>问题找到了，解决就简单了，在<strong>source</strong>文件夹中创建CNAME文件即可：<br><img src="https://i.loli.net/2019/01/26/5c4c3e692aa7e.png" alt="01.png"><br><img src="https://i.loli.net/2019/01/26/5c4c3e68e3c40.png" alt="03.png"></p>
<h2 id="hexo-generate生成index-html为0kb空白文件"><a href="#hexo-generate生成index-html为0kb空白文件" class="headerlink" title="hexo generate生成index.html为0kb空白文件"></a>hexo generate生成index.html为0kb空白文件</h2><p>最近更换了电脑，所以将本地博客文件迁移到了新电脑，使用新电脑更新博客，但是在deploy到github之后访问页面是空白页面。经过一些列折腾后突然发现generate后的html等静态文件都是0kb，上网查了一下是node的版本过高的原因，卸载本地的版本，在node.js官网下载最新版本安装后再次deploy，解决！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>在ESXI镜像中集成第三方驱动</title>
    <url>/2019/12/04/%E5%9C%A8ESXI%E9%95%9C%E5%83%8F%E4%B8%AD%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>在使用VMware官方的ESXI6.0镜像在浪潮服务器安装时，安装程序发现不了RAID，服务器的具体型号是NF5270M5，在网上搜索了一下发现是驱动的问题，折腾了一上午终于搞定了，简单记录一下过程。</p>
<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><ul>
<li>ESXi-Customizer-v2.7.2</li>
<li>RAID驱动</li>
<li>ESXI6.0镜像</li>
</ul>
<p>1.<strong>ESXi-Customizer</strong>，是一个专门用来向ESXI封装驱动的工具，下载地址可自行百度，也可以从我的百度云下载：<a href="https://pan.baidu.com/s/18328xWRZYN--UC27NwIRhA" target="_blank" rel="noopener">提取码：riel</a>。下载之后运行.exe文件解压出来就可以了，然后有一点需要注意的是win10无法运行（亲测win7是可以的），会报如下图所示的错误：<br><img src="https://i.loli.net/2019/12/04/mZ3H6b4suJgCvcl.png" alt="04.png"><br>解决方法很简单，用编辑器打开ESXi-Customizer.cmd，删除下面这行：</p>
<blockquote>
</blockquote>
<pre><code>if &quot;!WinVer!&quot; LSS &quot;5.1&quot; call :earlyFatal Unsupported Windows Version: !WinVer!. At least Windows XP is required &amp; exit /b 1
</code></pre><p>再运行就正常了：<br><img src="https://i.loli.net/2019/12/04/pXlmDvcGjfSwdNP.png" alt="03.png"></p>
<p>2.下载驱动程序，下载驱动我们首先需要确定硬件的型号信息，开机进入RAID控制器查看RAID卡型号，然后到<a href="http://www.inspur.com/eportal/ui?pageId=2317460&amp;type=0" target="_blank" rel="noopener">浪潮官网</a>下载对应驱动。  </p>
<p>3.最后还需要准备一个ESXI镜像。</p>
<h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><p>1.解压下载的驱动程序文件，得到.vib文件。<br>2.运行ESXi-Customizer，第一项选择原始ESXI镜像，第二项选择驱动文件，第三项选择新镜像存放的位置，然后将“Enable…”取消勾选，点击RUN开始封装。<br><img src="https://i.loli.net/2019/12/04/KLkoDY72IzNjf8T.png" alt="05.png"></p>
<p>3.将封装好的镜像文件写入U盘，ok！</p>
<h1 id="添加网卡驱动-20201009更"><a href="#添加网卡驱动-20201009更" class="headerlink" title="添加网卡驱动(20201009更)"></a>添加网卡驱动(20201009更)</h1><h2 id="确认网卡型号等信息"><a href="#确认网卡型号等信息" class="headerlink" title="确认网卡型号等信息"></a>确认网卡型号等信息</h2><p>添加驱动首先要知道我们的硬件设备型号或其它等定位到具体驱动的信息，硬件设备的型号，大部分服务器在服务器带外管理中就可查看到硬件的详细型号信息。<br>也可以通过我们安装的ESXI来查找，安装好ESXI后，我们可以在配置-高级设置-配置直通中查看相应设备的VID和DID：<br><img src="https://i.loli.net/2020/10/16/R68ixJcVbhqyDrG.png" alt="02.png"><br>当然肯定还会有其它方式来查看到硬件型号信息，如果有更好的方式欢迎留言分享。</p>
<h2 id="查找驱动"><a href="#查找驱动" class="headerlink" title="查找驱动"></a>查找驱动</h2><p>在VMware的官方网站上查找我们的硬件驱动，打开VMware兼容性列表的官方：<a href="http://www.vmware.com/resources/compatibility/search.php" target="_blank" rel="noopener">http://www.vmware.com/resources/compatibility/search.php</a>，选择IO Devices<br><img src="https://i.loli.net/2020/10/16/kMl59tgWnimoCbY.png" alt="01.png"><br>可以通过左边的ESXI版本、供应商、设备类型来找到该网卡的，但是更为便捷的方式是在右侧输入产品的VID（供应商ID）和DID(设备ID)还快速定位到该网卡。  </p>
<p><img src="https://i.loli.net/2020/10/16/51Y7Mce9hjOdrxK.png" alt="03.png"><br>输入ID后搜索并下载相应型号设备的相应版本驱动即可。<br><img src="https://i.loli.net/2020/10/16/ECTzjg7QYuOUtaZ.png" alt="04.png"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.51cto.com/huanwenli/1749298" target="_blank" rel="noopener">https://blog.51cto.com/huanwenli/1749298</a><br><a href="https://vibsdepot.v-front.de/wiki/index.php/Welcome" target="_blank" rel="noopener">https://vibsdepot.v-front.de/wiki/index.php/Welcome</a><br><a href="https://vmware.lenovo.com/content/custom_iso/" target="_blank" rel="noopener">https://vmware.lenovo.com/content/custom_iso/</a></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>ESXI</tag>
        <tag>iso</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化运维笔记——服务器</title>
    <url>/2018/07/11/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="服务器通电自启"><a href="#服务器通电自启" class="headerlink" title="服务器通电自启"></a>服务器通电自启</h1><p>实验室有三台浪潮的服务器，默认关闭了通电自启的功能，因为不使用，也一直没去在意它，今天没事给它把通电自启动打开了，省的以后麻烦，在此记录一下，下图内容拍自浪潮服务器：<br>1、开机时按Delete键进入BIOS<br><img src="https://i.loli.net/2018/07/11/5b45ff414107c.jpg" alt="001.jpg"><br>2、选择Chipset-PCH<br><img src="https://i.loli.net/2018/07/11/5b45ff4151548.jpg" alt="002.jpg"><br>3、将Restore AC Power Loss修改为Power Off<br><img src="https://i.loli.net/2018/07/11/5b45ff414cd73.jpg" alt="003.jpg"><br>这里解释一下各个选项的意思：</p>
<blockquote>
<p><em>Restore AC Power Loss</em>:如果发生断电，恢复供电后系统如何反应<br><em>Power Off</em>:接通电源后保持关机状态<br><em>Power On</em>:接通电源后开机<br><em>Last State</em>:恢复到断电前的状态</p>
</blockquote>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>运维</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机的堆叠配置</title>
    <url>/2020/08/20/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%A0%86%E5%8F%A0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="交换机堆叠技术"><a href="#交换机堆叠技术" class="headerlink" title="交换机堆叠技术"></a>交换机堆叠技术</h1><p>交换机堆叠，通俗讲就是将多台交换机“合体”，堆叠后的交换机从逻辑上可视作一台交换机。目前各大网络厂商分别拥有各自的交换机堆叠技术，比如华为的iStack（Intelligent Stack）和CSS、华三的IRF（Intelligent Resilient Framework，智能弹性架构）以及思科的StackWise等等。</p>
<h1 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h1><h2 id="华为iStack"><a href="#华为iStack" class="headerlink" title="华为iStack"></a>华为iStack</h2><p>推荐在配置堆叠前先不要连接堆叠线<br><strong>SW-A-MASTER</strong></p>
<blockquote>
</blockquote>
<p>stack  #进入堆叠管理视图<br>stack member 1 domain 1  #设置堆叠成员的成员ID和domain ID<br>stack member 1 priority 200  #设置堆叠优先级,值越大优先级越高<br>interface stack-port 1/1  #配置堆叠端口<br>port member-group interface 40GE 1/0/1<br>commit<br>save<br>reboot  </p>
<p><strong>SW-B-SLAVE</strong></p>
<blockquote>
</blockquote>
<p>stack<br>stack member 1 renumber 2 inherit-config<br>保存并重启<br>stack member 2 domain 1<br>stack member 1 priority 100 #因还未重启,所以使用当前member1配置<br>interface stack-port 2/1<br>port member-group interface 40GE 1/0/1<br>commit<br>save</p>
<p>连接堆叠线，堆叠线连接后优先级低的设备会自动重启，重启后查看堆叠是否成功</p>
<blockquote>
</blockquote>
<p>display stack</p>
<ul>
<li>因为修改堆叠成员ID时指定了inherit-config参数，所以SW-B重启后会继承member 1的堆叠配置；如果不指定inherit-config参数，那么SW-B重启后不会继承member 1的堆叠配置，需要使用member 2重新进行堆叠配置。  </li>
</ul>
<h2 id="华三IRF"><a href="#华三IRF" class="headerlink" title="华三IRF"></a>华三IRF</h2><p>推荐在配置堆叠前先不要连接堆叠线<br><strong>SW-A-MASTER</strong></p>
<blockquote>
</blockquote>
<p>irf member 1 priority 10<br>int range FortyGigE 1/0/53 FortyGigE 1/0/54<br>shutdown<br>irf-port 1/2<br>port group int FortyGigE 1/0/53<br>port group int FortyGigE 1/0/54<br>irf-port-configuration active<br>int range FortyGigE 1/0/53 FortyGigE 1/0/54<br>undo shutdown<br>save</p>
<p><strong>SW-B-SLAVE</strong></p>
<blockquote>
</blockquote>
<p>irf member 1 renumber 2<br>reboot<br>int range FortyGigE 2/0/53 FortyGigE 2/0/54<br>shutdown<br>irf-port 2/1  #两台交换机的索引不能相同<br>port group int FortyGigE 2/0/53<br>port group int FortyGigE 2/0/54<br>irf-port-configuration active<br>int range FortyGigE 2/0/53 FortyGigE 2/0/54<br>undo shutdown<br>save</p>
<p>连接堆叠线，堆叠线连接后优先级低的设备会自动重启，重启后查看堆叠是否成功</p>
<blockquote>
</blockquote>
<p>display irf<br><img src="https://i.loli.net/2020/08/22/hjtXGAnYZoQKiCE.png" alt="irf.png"></p>
<ul>
<li>华三交换机两台交换机的索引号不能一致，如实例中SW-A的irf-port如果是1/1,那SW-B的irf就不能是2/1。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>交换机堆叠</tag>
        <tag>iStack</tag>
        <tag>IRF</tag>
        <tag>StackWise</tag>
      </tags>
  </entry>
  <entry>
    <title>红帽系Linux安装Oracle 19C数据库</title>
    <url>/2021/01/19/%E7%BA%A2%E5%B8%BD%E7%B3%BBLinux%E5%AE%89%E8%A3%85Oracle-19C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>本文使用的系统及软件版本为：  </p>
<ul>
<li>Redhat 7.7  </li>
<li>Oracle 19C  </li>
</ul>
<p>操作系统及Oracle数据库下载地址为：  </p>
<ul>
<li><a href="https://www.kclouder.cn/download/" target="_blank" rel="noopener">Redhat ISO</a></li>
<li><a href="https://www.oracle.com/database/technologies/oracle-database-software-downloads.html" target="_blank" rel="noopener">Oracle</a></li>
</ul>
<blockquote>
<p>如使用Redhat安装需先修改系统自带的yum源，详细步骤可参考之前的文章<a href="https://cyneliu.github.io/2021/01/15/RHEL%E4%BD%BF%E7%94%A8CentOS%E7%9A%84yum%E6%BA%90/">《RHEL使用CentOS的yum源》</a>;如无特别需要可直接使用CentOS进行安装；</p>
</blockquote>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>修改完yum源后，</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/xuzhaoyang/p/11264557.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuzhaoyang/p/11264557.html</a><br><a href="http://blog.itpub.net/35489/viewspace-733880/" target="_blank" rel="noopener">http://blog.itpub.net/35489/viewspace-733880/</a><br><a href="https://blog.51cto.com/3241766/2165798" target="_blank" rel="noopener">https://blog.51cto.com/3241766/2165798</a>  </p>
]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
</search>
