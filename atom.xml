<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyne&#39;s Blog</title>
  
  <subtitle>越努力，越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cyneliu.github.io/"/>
  <updated>2018-11-20T08:51:36.361Z</updated>
  <id>https://cyneliu.github.io/</id>
  
  <author>
    <name>Cyne Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Win2012在VMware环境下部署DHCP服务器的问题</title>
    <link href="https://cyneliu.github.io/2018/11/20/%E5%85%B3%E4%BA%8EWin2012%E5%9C%A8VMware%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cyneliu.github.io/2018/11/20/关于Win2012在VMware环境下部署DHCP服务器的问题/</id>
    <published>2018-11-20T08:35:46.000Z</published>
    <updated>2018-11-20T08:51:36.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端无法获取来自DHCP地址池的正确ip"><a href="#客户端无法获取来自DHCP地址池的正确ip" class="headerlink" title="客户端无法获取来自DHCP地址池的正确ip"></a>客户端无法获取来自DHCP地址池的正确ip</h1><p>昨天在VMware WorkStation的Server 2012安装完DHCP服务之后，使用另一台虚拟机测试时怎么都获取不到正确的ip，给到的是一个不同于DHCP地址池的其它子网的ip地址，两个小时愣是没找出原因。  </p><p>今天早上终于找到了原因，在这里记录一下。</p><h1 id="原因简述"><a href="#原因简述" class="headerlink" title="原因简述"></a>原因简述</h1><p>VMware中的VMnet虚拟网卡默认开启了本地DHCP服务，虚拟机在使用dhcp自动获取ip时是从VMnet的本地dhcp拿到的ip地址，因为每个人的VMnet网卡设置的网段不一样，获取的ip地址就是VMnet设置的网段，比如我的VMnet子网地址是192.168.138.0，我拿到的ip地址就是这个网段内的地址。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><img src="https://i.loli.net/2018/11/20/5bf3caebf40da.png" alt="01.png"><br>打开虚拟网络编辑器，选择你正在使用的虚拟网卡，比如我使用的是仅主机模式，对应的就是我的VMnet1网卡。更改设置，将“使用本地DHCP服务将IP分配给虚拟机”取消勾选就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;客户端无法获取来自DHCP地址池的正确ip&quot;&gt;&lt;a href=&quot;#客户端无法获取来自DHCP地址池的正确ip&quot; class=&quot;headerlink&quot; title=&quot;客户端无法获取来自DHCP地址池的正确ip&quot;&gt;&lt;/a&gt;客户端无法获取来自DHCP地址池的正确ip&lt;/
      
    
    </summary>
    
      <category term="服务器" scheme="https://cyneliu.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Windows Server" scheme="https://cyneliu.github.io/tags/Windows-Server/"/>
    
      <category term="DHCP" scheme="https://cyneliu.github.io/tags/DHCP/"/>
    
      <category term="VMware" scheme="https://cyneliu.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>科学上网工具 - WireGuard</title>
    <link href="https://cyneliu.github.io/2018/11/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B7%A5%E5%85%B7-WireGuard/"/>
    <id>https://cyneliu.github.io/2018/11/14/科学上网工具-WireGuard/</id>
    <published>2018-11-14T12:22:33.000Z</published>
    <updated>2018-11-14T12:57:37.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WireGuard是什么？"><a href="#WireGuard是什么？" class="headerlink" title="WireGuard是什么？"></a>WireGuard是什么？</h1><p>WireGuard是一个构建快速、现代、安全的VPN的协议和工具套件，它具有以下优点：</p><blockquote></blockquote><p>使用最先进的加密技术，防范攻击（RSA，SHA广被诟病都将被淘汰）<br>性能远超OpenVPN<br>效率极高，WireGuard协议作为Linux内核模块运行<br>通用用途，支持嵌入式和非嵌入式设备<br>跨平台，初期只在Linux平台发布，现已支持所有平台<br>易用，用过OpenVPN等工具集的人都明白这其中的痛苦<br>工作在3层（链路层），支持漫游，地址变更对用户无感知，使用更简单，切换更平滑<br>使用UDP传输数据，轻量、高效、节能、节省带宽（适用于 IOT 领域）<br>基于GPLv2Linux Kernel 基于 GPLv2）免费开源  </p><p>Linus Torvalds对WireGuard的评价：</p><blockquote><p>Can I just once again state my love for it and hope it gets merged soon? Maybe the code isn’t perfect, but I’ve skimmed it, and compared to the horrors that are OpenVPN and IPSec, it’s a work of art.</p></blockquote><h1 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h1><h2 id="脚本要求"><a href="#脚本要求" class="headerlink" title="脚本要求"></a>脚本要求</h2><blockquote><p>仅适用于centos7<br>vps架构必须为KVM<br>centos7的内核大部分为3.10，不能正确安装，必须升级（已经集成在脚本中）</p></blockquote><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>1、下载并执行脚本：</p><blockquote></blockquote><pre><code>wget https://raw.githubusercontent.com/yobabyshark/wireguard/master/wireguard_install.sh &amp;&amp; chmod +x wireguard_install.sh &amp;&amp; ./wireguard_install.sh</code></pre><p><img src="https://i.loli.net/2018/11/14/5bec1723904fd.png" alt="01.png"></p><p>2、输入“1”升级内核，按照提示重启。  </p><p>3、重启完成后，再次执行脚本：</p><blockquote></blockquote><pre><code>./wireguard_install.sh</code></pre><p>4、输入“2”安装WireGuard。  </p><p>5、使用ftp工具连接vps，将<strong>/etc/wireguard</strong>目录下的client.conf下载到本地。</p><p>6、下载安装TunSafe，这是一个windows端的第三方客户端，因为官方windows版本的还没开发完成，先用这个软件代替，TunSafe已经开源，可以放心使用。<br>官网下载：<a href="https://tunsafe.com/download" target="_blank" rel="noopener">TunSafe</a></p><p>7、打开TunSafe，单击file，选择import file，将下载的client.conf导入到软件中。  </p><p>8、导入后会自动进行连接，进入全局代理模式，也就是所有流量都会被代理。</p><h1 id="其它平台客户端"><a href="#其它平台客户端" class="headerlink" title="其它平台客户端"></a>其它平台客户端</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>1、下载WireGuard安卓客户端：  </p><blockquote><p>Android客户端：<a href="https://f-droid.org/repo/com.wireguard.android_439.apk" target="_blank" rel="noopener">点此下载</a></p></blockquote><p>2、打开app，点击加号导入client.conf文件。</p><blockquote><p>这里可能会提示错误，原因是没有文件操作权限，去权限管理里给软件勾上存储权限即可。</p></blockquote><h1 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h1><p>Youtube视频地址：<a href="https://youtu.be/A1tdPsdBATw" target="_blank" rel="noopener">点击观看</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WireGuard是什么？&quot;&gt;&lt;a href=&quot;#WireGuard是什么？&quot; class=&quot;headerlink&quot; title=&quot;WireGuard是什么？&quot;&gt;&lt;/a&gt;WireGuard是什么？&lt;/h1&gt;&lt;p&gt;WireGuard是一个构建快速、现代、安全的VPN
      
    
    </summary>
    
      <category term="VPS" scheme="https://cyneliu.github.io/categories/VPS/"/>
    
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="VPS" scheme="https://cyneliu.github.io/tags/VPS/"/>
    
      <category term="WireGuard" scheme="https://cyneliu.github.io/tags/WireGuard/"/>
    
  </entry>
  
  <entry>
    <title>简单识别Linux vps架构(xen,openvz,kvm)</title>
    <link href="https://cyneliu.github.io/2018/11/14/%E7%AE%80%E5%8D%95%E8%AF%86%E5%88%ABLinux-vps%E6%9E%B6%E6%9E%84-xen-openvz-kvm/"/>
    <id>https://cyneliu.github.io/2018/11/14/简单识别Linux-vps架构-xen-openvz-kvm/</id>
    <published>2018-11-14T12:10:11.000Z</published>
    <updated>2018-11-14T12:16:49.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装virt-what"><a href="#安装virt-what" class="headerlink" title="安装virt-what"></a>安装virt-what</h1><blockquote></blockquote><pre><code>yum -y install virt-what</code></pre><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><blockquote></blockquote><pre><code>virt-what</code></pre><p>如图，这台vps是基于xen架构。<br><img src="https://i.loli.net/2018/11/14/5bec12288d430.png" alt="01.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装virt-what&quot;&gt;&lt;a href=&quot;#安装virt-what&quot; class=&quot;headerlink&quot; title=&quot;安装virt-what&quot;&gt;&lt;/a&gt;安装virt-what&lt;/h1&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="VPS" scheme="https://cyneliu.github.io/categories/VPS/"/>
    
    
      <category term="VPS" scheme="https://cyneliu.github.io/tags/VPS/"/>
    
      <category term="linux" scheme="https://cyneliu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈几种快充技术</title>
    <link href="https://cyneliu.github.io/2018/11/07/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8D%E5%BF%AB%E5%85%85%E6%8A%80%E6%9C%AF/"/>
    <id>https://cyneliu.github.io/2018/11/07/浅谈几种快充技术/</id>
    <published>2018-11-07T11:00:56.000Z</published>
    <updated>2018-11-07T11:50:05.314Z</updated>
    
    <content type="html"><![CDATA[<p>原来的充电宝丢了，今天又在某宝上溜达买了一个，溜达的时候发现了好多的新名词，就索性查了一下，整理一下写在这里了。</p><h1 id="PD快充协议"><a href="#PD快充协议" class="headerlink" title="PD快充协议"></a>PD快充协议</h1><p>PD充电协议是USB-IF组织公布的功率传输协议，它可以使目前默认最大功率5V/2A的type-c接口提高到100W，同时谷歌宣布Android7.0以上的手机搭载的快充协议必须支持PD协议，意在统一快充市场。  </p><p>USB-PowerDelivery（USBPD）是目前主流的快充协议之一。是由USB-IF组织制定的一种快速充电规范。USBPD透过USB电缆和连接器增加电力输送，扩展USB应用中的电缆总线供电能力。该规范可实现更高的电压和电流，输送的功率最高可达100瓦，并可以自由的改变电力的输送方向。  </p><p>USBPD和Type-C的关系。经常会有人把USBPD和Type-C放在一起谈，甚至就把Type-C充电器叫做PD充电器。USBPD和Type-C其实是两码事，USBPD是一种快速充电协议，而Type-C则是一种新的接口规范。Type-C接口默认最大支持5V/3A，但在实现了USBPD协议以后，能够使输出功率最大支持到前文提到的100W。所以现在许多实用Type-C接口的设备都会支持USBPD协议。</p><p>USBPD的发展前景。USBPD现在已经发展到了USBPD3.0版本。在谷歌的推动下目USBPD已经收编了高通的QC快充协议，并获得了中国工信部的支持。</p><h1 id="QC-1-0-2-0-3-0"><a href="#QC-1-0-2-0-3-0" class="headerlink" title="QC 1.0/2.0/3.0"></a>QC 1.0/2.0/3.0</h1><p>Qualcomm Quick Charge 3.0（下文简称QC 3.0）快充技术不知不觉已经是Qualcomm第三代快充技术，前几年快充技术还没百家齐放的时候，QC门派的关注度还是蛮高的。前几年QC 1.0和QC 2.0仍然比较受手机厂商和消费者欢迎。尤其是QC 2.0技术，如今很多手机厂商的快充技术其实都是基于QC 2.0基础上延伸出来的，例如下文将会提到的Moto涡轮快充和vivo双引擎闪充。  </p><blockquote></blockquote><p><strong>QC 1.0</strong>：最高支持5V/2A充电功率。</p><blockquote><p><strong>QC 2.0</strong>：兼容5V/9V/12V/20V四档充电电压。  </p></blockquote><p><strong>QC 3.0</strong>：以200mV增量为一档，提供从3.6V到20V电压的灵活选择，让手机厂商能够根据自身需求调整最佳电压，达到预期电流，提供充电效率同时降低功耗和发热。目前市面上标配QC 3.0快充头并支持该协议手机有LG G5、小米手机5等。</p><h1 id="MTK：PumpExpress-Plus"><a href="#MTK：PumpExpress-Plus" class="headerlink" title="MTK：PumpExpress Plus"></a>MTK：PumpExpress Plus</h1><p>说完高通的，再来看看联发科的快充技术。  </p><p>联发科MTP Pump Express Plus快充技术，原理与高通QC快充基本相同，都是在恒定电流的同时，通过提升充电电压来获得更大的充电功率。最新的Pump Express 3.0宣称能够在20分钟内为智能手机充满70%电量，同时相比PumpExpress Plus功耗减少50%，间接降低发热。  </p><p>PumpExpress允许充电器根据电流决定充电所需的初始电压，通过内置的PMIC电源管理集成电路发出脉冲电流指令给充电器，调整输出电压，逐渐增加到最大充电电流。相比QC 3.0的200mV为一档增量的做法，PumpExpress 3.0电压微调幅度仅为10mV，理论最高可提供5A充电电流。  </p><h1 id="手机厂商快充协议"><a href="#手机厂商快充协议" class="headerlink" title="手机厂商快充协议"></a>手机厂商快充协议</h1><blockquote></blockquote><p>华为：FCP（Fast Charger Protocol）<br>三星：AFC<br>一加：DASH极速闪充<br>vivo:双引擎闪充<br>OPPO：VOOC闪充技术<br>Moto：涡轮快充技术<br>魅族：mCharge 3.0  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原来的充电宝丢了，今天又在某宝上溜达买了一个，溜达的时候发现了好多的新名词，就索性查了一下，整理一下写在这里了。&lt;/p&gt;
&lt;h1 id=&quot;PD快充协议&quot;&gt;&lt;a href=&quot;#PD快充协议&quot; class=&quot;headerlink&quot; title=&quot;PD快充协议&quot;&gt;&lt;/a&gt;PD快充
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="快充" scheme="https://cyneliu.github.io/tags/%E5%BF%AB%E5%85%85/"/>
    
  </entry>
  
  <entry>
    <title>Apache Web服务器的安装与配置</title>
    <link href="https://cyneliu.github.io/2018/10/30/Apache-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://cyneliu.github.io/2018/10/30/Apache-Web服务器的安装与配置/</id>
    <published>2018-10-30T09:10:05.000Z</published>
    <updated>2018-10-30T09:26:47.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Apache2"><a href="#安装Apache2" class="headerlink" title="安装Apache2"></a>安装Apache2</h1><p>执行：</p><blockquote></blockquote><pre><code>sudo apt-get install apache2</code></pre><p>Apache默认会在“/var”下建立一个名为“www”的目录，即Web目录，所有能通过浏览器访问的Web文件都放到这个目录。</p><h1 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h1><p>安装PHP：</p><blockquote></blockquote><pre><code>sudo apt-get install libapache2-mod-php5 php5</code></pre><p>安装扩展包：</p><blockquote></blockquote><pre><code>sudo apt-get install php5-gd php5-mysql</code></pre><p>重新启动Apache，加载PHP模块:</p><blockquote></blockquote><pre><code>sudo /etc/init.d/apache2 restart</code></pre><h1 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h1><p>执行：</p><blockquote></blockquote><pre><code>sudo apt-get install mysql-server</code></pre><p>根据提示信息设置密码。</p><h1 id="安装配置phpMyAdmin"><a href="#安装配置phpMyAdmin" class="headerlink" title="安装配置phpMyAdmin"></a>安装配置phpMyAdmin</h1><p>安装Mysql数据库管理软件：</p><blockquote></blockquote><pre><code>sudo apt-get install phpmyadmin</code></pre><p>选择Web server：apache2或lighttpd：<br><img src="http://112.80.35.35:40010/site_media/media/course/45822350-0767-4686-b15a-74a093b03768/network/%E5%9B%BE%E7%89%87_nvEIrXy.png" alt="01.png"><br>之后还需要根据提示输入Mysql的root账户连接密码并设置phpMyAdmin的登录密码。  </p><p>将phpMyAdmin与Apache2建立连接。例如：www目录在“/var/www”下，phpMyAdmin在“/usr/share/phpmyadmin”目录下，则用如下命令建立连接：</p><blockquote></blockquote><pre><code>sudo ln -s /usr/share/phpmyadmin /var/www/html</code></pre><p>在浏览器地址栏中输入<a href="http://localhost/phpmyadmin即可访问phpMyAdmin的登录页面。" target="_blank" rel="noopener">http://localhost/phpmyadmin即可访问phpMyAdmin的登录页面。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装Apache2&quot;&gt;&lt;a href=&quot;#安装Apache2&quot; class=&quot;headerlink&quot; title=&quot;安装Apache2&quot;&gt;&lt;/a&gt;安装Apache2&lt;/h1&gt;&lt;p&gt;执行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;c
      
    
    </summary>
    
      <category term="服务器应用" scheme="https://cyneliu.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Apache" scheme="https://cyneliu.github.io/tags/Apache/"/>
    
      <category term="Web服务器" scheme="https://cyneliu.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的简单安装</title>
    <link href="https://cyneliu.github.io/2018/10/30/Nginx%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/"/>
    <id>https://cyneliu.github.io/2018/10/30/Nginx的简单安装/</id>
    <published>2018-10-30T07:49:45.000Z</published>
    <updated>2018-10-30T08:48:16.638Z</updated>
    
    <content type="html"><![CDATA[<p>过几天参加比赛要用到nginx的安装部署，写一个简单的安装方式，方便赛前温习。</p><h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><p>更新apt源：</p><blockquote></blockquote><pre><code>sudo apt-get update</code></pre><p>安装nginx：</p><blockquote></blockquote><pre><code>sudo apt-get install nginx</code></pre><p>使用这种方法，apt-get会自动安装好nginx和依赖组件。  </p><p>执行如下命令查看nginx进程是否启动：</p><blockquote></blockquote><pre><code>ps -ef | grep nginx</code></pre><p>打开浏览器，在地址栏输入localhost，就会出现如下的欢迎页面，表示nginx安装成功。<br><img src="http://112.80.35.35:40010/site_media/media/course/096bc012-db2f-4c2b-a983-bbf7056af08e/network/%E5%9B%BE%E7%89%87_MVR9Prv.png" alt="01.png"></p><h1 id="Nginx安装路径"><a href="#Nginx安装路径" class="headerlink" title="Nginx安装路径"></a>Nginx安装路径</h1><blockquote></blockquote><pre><code>whereis nginx</code></pre><h1 id="搭建简单静态服务器"><a href="#搭建简单静态服务器" class="headerlink" title="搭建简单静态服务器"></a>搭建简单静态服务器</h1><p>在nginx安装目录下找到nginx.conf文件，打开并编辑，在http节点下增加如下内容：<br><img src="http://112.80.35.35:40010/site_media/media/course/096bc012-db2f-4c2b-a983-bbf7056af08e/network/%E5%9B%BE%E7%89%87_DEfprYK.png" alt="02.png"><br>root /home/openlab这里填写你的静态文件存储根目录。  </p><p>找到nginx程序所在的目录，执行nginx -s reload命令，重新加载Nginx配置文件。  </p><p>root /home/openlab这里填写你的静态文件存储根目录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过几天参加比赛要用到nginx的安装部署，写一个简单的安装方式，方便赛前温习。&lt;/p&gt;
&lt;h1 id=&quot;安装Nginx&quot;&gt;&lt;a href=&quot;#安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;安装Nginx&quot;&gt;&lt;/a&gt;安装Nginx&lt;/h1&gt;&lt;p&gt;更新a
      
    
    </summary>
    
      <category term="服务器应用" scheme="https://cyneliu.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Web服务器" scheme="https://cyneliu.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="https://cyneliu.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Windows环境利用FRP实现内网穿透</title>
    <link href="https://cyneliu.github.io/2018/10/20/Windows%E7%8E%AF%E5%A2%83%E5%88%A9%E7%94%A8FRP%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://cyneliu.github.io/2018/10/20/Windows环境利用FRP实现内网穿透/</id>
    <published>2018-10-20T08:56:19.000Z</published>
    <updated>2018-10-20T10:49:34.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>FRP (Fast Reverse Proxy) 是一个可用于内网穿透的高性能的反向代理应用，支持TCP,UDP,HTTP,HTTPS协议。  </p><p>项目地址：<br><a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。  </p><p>比如我们平时用的翻墙工具就属于正向代理的一种应用。<br><img src="https://i.loli.net/2018/10/20/5bcaf373cd030.png" alt="01.png"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。<br><img src="https://i.loli.net/2018/10/20/5bcaf373ef44d.png" alt="02.png"></p><h1 id="安装部署frp"><a href="#安装部署frp" class="headerlink" title="安装部署frp"></a>安装部署frp</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.拥有公网ip的设备</p><blockquote><p>作为反向代理服务器，外网访问内网设备时通过此设备进行访问。</p></blockquote><p>2.域名（非必须）</p><blockquote><p>域名的作用仅仅是为了方便记忆，有了域名在访问时就不需要输入那些难以记忆的数字进行访问了。</p></blockquote><h2 id="下载安装程序"><a href="#下载安装程序" class="headerlink" title="下载安装程序"></a>下载安装程序</h2><p>到<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">GitHub</a>下载frp程序，如果是64位系统下载“amd64”结尾的zip包，如果是32位系统就下载“386”结尾的zip包。  </p><p>下载完成后分别在客户端和服务端选择一个合适的位置直接解压出来就可以了。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="放行端口"><a href="#放行端口" class="headerlink" title="放行端口"></a>放行端口</h3><p>因为博主使用的是阿里云的学生机，默认是没有放行其它端口的，所以在配置frp之前需要配置一下入方向的安全组规则：<br><img src="https://i.loli.net/2018/10/20/5bcaf78e8b887.png" alt="03.png"></p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>在上面过程中解压出来的文件包含有frps.ini和frps_full.ini两个配置文件，frps_full.ini是全配置，里面所有的配置都有，玩法很多，感兴趣的可以研究一下。将下面配置代码复制到frps.ini后保存：</p><blockquote></blockquote><pre><code>[common]bind_port = 7000 ;要绑定的端口dashboard_user = admin ;控制台的用户名dashboard_pwd = password ;控制台的密码dashboard_port = 7500 ;控制台的端口</code></pre><p>在配置文件所在位置按住shift右键打开cmd或power shell，执行命令：<br>cmd:</p><blockquote></blockquote><pre><code>frps -c frps.ini</code></pre><p>power shell:</p><blockquote></blockquote><pre><code>.\frps.exe -c frps.ini</code></pre><h2 id="客户端-内网设备"><a href="#客户端-内网设备" class="headerlink" title="客户端(内网设备)"></a>客户端(内网设备)</h2><h3 id="编辑配置文件-1"><a href="#编辑配置文件-1" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>将如下代码复制到frpc.ini中：</p><blockquote></blockquote><pre><code>[common]server_addr = 1.2.3.4 ;服务器的 IPserver_port = 7000 ;服务器上设置的服务绑定端口[RDP] ;这个是反向代理的名称，可以随意设置type = tcp ;RDP 是 TCP 协议的local_ip = 127.0.0.1 ;本机IP,可以直接使用127.0.0.1local_port = 3389 ;远程桌面的默认端口remote_port = 7001 ;外网访问的端口</code></pre><p>在配置文件所在位置按住shift右键打开cmd或power shell，执行命令：<br>cmd:</p><blockquote></blockquote><pre><code>frpc -c frpc.ini</code></pre><p>power shell:</p><blockquote></blockquote><pre><code>.\frpc.exe -c frpc.ini</code></pre><h3 id="开启远程桌面（非必须）"><a href="#开启远程桌面（非必须）" class="headerlink" title="开启远程桌面（非必须）"></a>开启远程桌面（非必须）</h3><p>如果你配置frp是为了使用远程桌面，而恰巧你的内网设备又是win7或win10等桌面版系统，那么你还需要右击“此电脑”，选择“系统”——“远程设置”——“允许远程连接至此电脑”。而如果是server版本直接忽略此步骤即可。  </p><p>至此，你已经可以使用你的ip加端口号的形式访问你的相应服务了。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>设置自己的域名解析，添加一条A类记录指向你的公网ip。<br><img src="https://i.loli.net/2018/10/20/5bcb0775422ac.png" alt="04.png"></p><h3 id="配置frpc-ini"><a href="#配置frpc-ini" class="headerlink" title="配置frpc.ini"></a>配置frpc.ini</h3><p>在刚才复制的配置之后添加如下内容即可：</p><blockquote></blockquote><pre><code>custom_domains = xxx.yourdomain.xxx</code></pre><p>这样，你就可以使用域名+端口的形式访问你的服务了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h1&gt;&lt;h2 id=&quot;frp&quot;&gt;&lt;a href=&quot;#frp&quot; class=&quot;headerlink&quot; title=&quot;frp&quot;&gt;&lt;/a&gt;fr
      
    
    </summary>
    
      <category term="软件工具" scheme="https://cyneliu.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="frp" scheme="https://cyneliu.github.io/tags/frp/"/>
    
      <category term="内网穿透" scheme="https://cyneliu.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="反向代理" scheme="https://cyneliu.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="Windows" scheme="https://cyneliu.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>SDN实验（二）——Open vSwitch</title>
    <link href="https://cyneliu.github.io/2018/10/16/SDN%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Open-vSwitch/"/>
    <id>https://cyneliu.github.io/2018/10/16/SDN实验（二）——Open-vSwitch/</id>
    <published>2018-10-16T07:20:10.000Z</published>
    <updated>2018-10-16T10:02:06.691Z</updated>
    
    <content type="html"><![CDATA[<p>Open vSwitch是由Nicira Networks主导，运行在虚拟化平台（例如KVM，Xen）上的虚拟交换机。Open vSwitch基于C语言开发，遵循Apache 2.0许可证，能同时支持多种标准的管理接口和协议（比如NetFlow、sFlow、SPAN、RSPAN、CLI、LACP、802.1ag等）。Open vSwitch通过OpenFlow协议由统一的控制器管理，从而实现对接入的虚拟机（或设备）的网络联通。  </p><p>整体组网结构如下图：<br><img src="https://i.loli.net/2018/10/16/5bc592232631f.png" alt="01.png"><br>Open vSwitch内部架构图：<br><img src="https://i.loli.net/2018/10/16/5bc592a15b2de.png" alt="02.png"></p><blockquote><p><strong>ovs-vswtichd：</strong>主要模块，实现vswitch的守候进程daemon，包括一个支持流交换的Linux内核模块。<br><strong>ovsdb-server：</strong>轻量级数据库服务器，保存配置信息，ovs-vswitchd通过这个数据库获取配置信息。<br><strong>ovs-dpctl：</strong>用来配置vswitch内核模块的一个工具。<br><strong>ovs-vsctl：</strong>主要是获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。<br><strong>ovs-appctl：</strong>一个向ovs-vswtichd的守护进程发送命令的的程序。<br><strong>datapath：</strong>内核模块，根据流表匹配结果做相应处理。<br><strong>ovs-ofctl：</strong>查询和控制OpenFlow虚拟交换机的流表。</p></blockquote><h1 id="Open-vSwitch的安装"><a href="#Open-vSwitch的安装" class="headerlink" title="Open vSwitch的安装"></a>Open vSwitch的安装</h1><h1 id="Open-vSwitch网桥管理"><a href="#Open-vSwitch网桥管理" class="headerlink" title="Open vSwitch网桥管理"></a>Open vSwitch网桥管理</h1><p>在网络中，交换机和桥概念类似，Open vSwitch是一个虚拟交换软件，也就是说，Open vSwitch实现了网桥的功能。学习Open vSwitch的第一步要弄清楚网桥的概念。网桥是连接两个局域网的设备，工作在数据链路层，根据MAC地址来转发帧。在Open vSwitch中创建一个网桥后，此时网络功能不受影响，但是会产生一个虚拟网卡，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个网桥以后，还需要为这个网桥增加端口（port），一个端口就是一个物理网卡，当网卡加入到这个网桥之后，其工作方式就和普通交换机的一个端口的工作方式类似了。以下是一个网桥的具体信息：</p><blockquote></blockquote><pre><code>root@localhost:~# ovs-vsctl showbc12c8d2-6900-42dd-9c1c-30e8ecb99a1bBridge &quot;br0&quot;    Port &quot;eth0&quot;        Interface &quot;eth0&quot;    Port &quot;br0&quot;        Interface &quot;br0&quot;            type: internalovs_version: &quot;1.4.0+build0&quot;</code></pre><p>上述信息显示了一个名为br0的桥（交换机），这个交换机有两个接口，一个是eth0，一个是br0。  </p><p>上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口实现了桥的功能。Open vSwitch的内核模块实现了多个“数据路径”，每个都可以有多个vports。每个数据路径也通过关联流表（flow table）来设置操作，而这些流表中的流都是用户空间在报文头和元数据的基础上映射的关键信息，一般的操作都是将数据包转发到另一个vport。当一个数据包到达一个vport，内核模块所做的处理是提取其流的关键信息并在流表中查找这些关键信息，当有一个匹配的流时它执行对应的操作，如果没有匹配，它会将数据包送到用户空间的处理队列中，作为处理的一部分，用户空间可能会设置一个流用于以后碰到相同类型的数据包可以在内核中执行操作。</p><h2 id="ovs-vsctl关于网桥管理的常用命令"><a href="#ovs-vsctl关于网桥管理的常用命令" class="headerlink" title="ovs-vsctl关于网桥管理的常用命令"></a>ovs-vsctl关于网桥管理的常用命令</h2><blockquote></blockquote><p><strong>init</strong>    初始化数据库（前提数据分组为空）<br><strong>show</strong>    打印数据库信息摘要<br><strong>add-br BRIDGE</strong>    添加新的网桥<br><strong>del-br BRIDGE</strong>    删除网桥<br><strong>list-br</strong>    打印网桥摘要信息<br><strong>list-ports BRIDGE</strong>    打印网桥中所有port摘要信息<br><strong>add-port BRIDGE PORT</strong>    向网桥中添加端口<br><strong>del-port [BRIDGE] PORT</strong>    删除网桥上的端口<br><strong>get-controller BRIDGE</strong>    获取网桥的控制器信息<br><strong>del-controller BRIDGE</strong>    删除网桥的控制器信息<br><strong>set-controller BRIDGE TARGET</strong>    向网桥添加控制器</p><h1 id="Open-vSwitch流表管理"><a href="#Open-vSwitch流表管理" class="headerlink" title="Open vSwitch流表管理"></a>Open vSwitch流表管理</h1><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议连接Open vSwitch来创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。ovs-ofctl关于流表管理的常用命令如下表所示。<br><img src="https://i.loli.net/2018/10/16/5bc5b553dc0a6.png" alt="03.png"><br>对于add-flow、add-flows和mod-flows这3个命令，还需要指定要执行的动作actions=[target],[target]…，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br><img src="https://i.loli.net/2018/10/16/5bc5b5bebfed1.png" alt="04.png"><br>在OpenFlow白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或空格分开，一些常用的字段列举如下表所示。<br><img src="https://i.loli.net/2018/10/16/5bc5b664441f1.png" alt="05.png"></p><h1 id="Open-vSwitchQoS设置"><a href="#Open-vSwitchQoS设置" class="headerlink" title="Open vSwitchQoS设置"></a>Open vSwitchQoS设置</h1><h1 id="Open-vSwitch端口映射"><a href="#Open-vSwitch端口映射" class="headerlink" title="Open vSwitch端口映射"></a>Open vSwitch端口映射</h1><h1 id="Open-vSwitch流量监控"><a href="#Open-vSwitch流量监控" class="headerlink" title="Open vSwitch流量监控"></a>Open vSwitch流量监控</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Open vSwitch是由Nicira Networks主导，运行在虚拟化平台（例如KVM，Xen）上的虚拟交换机。Open vSwitch基于C语言开发，遵循Apache 2.0许可证，能同时支持多种标准的管理接口和协议（比如NetFlow、sFlow、SPAN、RSP
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Open vSwitch" scheme="https://cyneliu.github.io/tags/Open-vSwitch/"/>
    
  </entry>
  
  <entry>
    <title>SDN实验（一）——常用开源工具</title>
    <link href="https://cyneliu.github.io/2018/10/15/SDN%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://cyneliu.github.io/2018/10/15/SDN实验（一）——常用开源工具/</id>
    <published>2018-10-15T08:38:43.000Z</published>
    <updated>2018-10-15T11:01:00.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><p>Wireshark这款网络数据包分析工具，在传统网络中就有很广泛的应用，这里就不再多说了，主要记录一下笔者之前没有发现的功能或使用方法。  </p><h2 id="OpenFlow数据包"><a href="#OpenFlow数据包" class="headerlink" title="OpenFlow数据包"></a>OpenFlow数据包</h2><p>OpenFlow数据包主要包含五层，依次是：  </p><blockquote><p><strong>Frame：</strong>物理层数据帧概况。<br><strong>Ethernet II：</strong>数据链路层以太网帧头部信息。<br><strong>Internet Protocol Version 4：</strong>互联网IP包头信息。<br><strong>transmission control protocol：</strong>传输层数据段头部信息，此处是TCP。<br><strong>OpenFlow：</strong>位于TCP协议之上，负责解析应用层。  </p></blockquote><h2 id="保存捕获的数据"><a href="#保存捕获的数据" class="headerlink" title="保存捕获的数据"></a>保存捕获的数据</h2><p>wireshark除了有“save”和“save as”的保存方式外，还提供特殊保存的方法（Export Specified）：</p><blockquote><p><strong>All packets:</strong>保存所有已抓取的数据包。<br><strong>Selected packets only:</strong>保存当前鼠标选中的数据包。<br><strong>Marked packets only:</strong>保存当前标记的数据包。标记数据包的方法是在数据包列表中选中目标数据包，然后右击选择“mark packet toggle”。<br><strong>First to last marked:</strong>则将两个标记数据包之间所有的数据包导出。<br><strong>Range:</strong>并输入数据包的编号范围，则将编号连续的数据包导出。<br><strong>Remove ignored packets:</strong>则放弃部分数据包并导出其他所有数据包。放弃数据包的方法是，在数据包列表中选中数据包，右击，选择“ignore packet toggle”。</p></blockquote><h1 id="性能测试工具iPerf和Netperf"><a href="#性能测试工具iPerf和Netperf" class="headerlink" title="性能测试工具iPerf和Netperf"></a>性能测试工具iPerf和Netperf</h1><h2 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h2><p>1、网络吞吐量：单位时间内通过某个网络（信道或接口）的数据量，吞吐量受网络的带宽或者网络的额定速率限制，单位通常表示为bit/s或bps。  </p><p>2、网络延时：一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。影响网络延时的主要因素是路由的跳数和网络的流量。交换机延时（Latency）是指从交换机接收到数据包到开始向目的端口复制数据包之间的时间间隔。有许多因素会影响交换机延时大小，比如转发技术等等。  </p><p>3、抖动：用于描述包在网络中的传输延时的变化，抖动越小，说明网络质量越稳定越好。抖动是评价一个网络性能的最重要的因素。  </p><p>4、丢包率：理想状态下是发送了多少数据包就能接收到多少数据包，但是由于信号衰减、网络质量等诸多因素的影响并不能达到理想状态，而丢包率就是指测试中所丢失的数据包数量占所发送的数据包的比率。</p><h2 id="iPerf"><a href="#iPerf" class="headerlink" title="iPerf"></a>iPerf</h2><p>iPerf 是一种网络性能测试工具，可以运行于Linux、BSD、Unix及Windows等操作系统。 iPerf具有多种参数和特性，支持协议、定时、缓冲区等参数的配置调整，能够测试TCP/UDP最大带宽、延迟抖动、数据包丢失等统计信息，可以根据需求采用不同的参数从而达到不同的测试目的。iPerf基于Server/Client的工作模式，如下图所示：  </p><p><img src="https://i.loli.net/2018/10/15/5bc45614c9c99.png" alt="01.png"><br>客户端向服务端发送一定数量的数据，服务端统计并记录带宽、延时抖动等信息。客户端将数据全部发送后，服务端会回复一个数据包给客户端，将测试数据反馈给客户端。不过，如果网络较为拥塞或者误码率较高，客户端无法收到服务端回复的数据包，则只能显示本地记录的部分测试结果，所以服务端和客户端的测试结果可能有所不同。</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote></blockquote><pre><code>iperf [-s|-c host] [options]</code></pre><h4 id="客户端-服务端通用参数"><a href="#客户端-服务端通用参数" class="headerlink" title="客户端/服务端通用参数"></a>客户端/服务端通用参数</h4><blockquote></blockquote><pre><code>-f/—format  [kmKM]分别表示以Kbits, Mbits, KBytes, MBytes显示报告，默认以Mbits为单位-i/—interval  以秒为单位显示报告间隔-l/—len  读写的缓冲区大小，默认8KB-m/—print_mss  打印最大的TCP数据段大小 (MTU - TCP/IP header)-o/—output    将报告和错误信息输出到指定文件-p/—port    指定服务器端使用的端口或客户端所连接的端口-u/—udp    使用udp协议-w/—window    指定TCP窗口（socket缓冲区）大小，默认是8KB-B/—bind    绑定一个主机地址或接口-C/—compatibility    兼容旧版本（当server端和client端版本不一样时使用）-M/—mss    设置TCP最大数据段大小（MTU - 40 bytes）-N/—nodelay    设置无延迟TCP，禁用 Nagle’s Algorithm-V/—IPv6Version    设置传输Ipv6数据包</code></pre><h4 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h4><blockquote></blockquote><pre><code>-s/—server    服务器模式下运行-U/— single_udp    单线程UDP模式下运行-D/— daemon    以守护进程模式运行服务器</code></pre><h4 id="客户端参数"><a href="#客户端参数" class="headerlink" title="客户端参数"></a>客户端参数</h4><blockquote></blockquote><pre><code>-b/— bandwidth    对于UDP，使用bits/sec （默认 1 Mbit/sec, 亦即 -u）传送带宽-c/— client    运行为客户端，连接到“主机”-d/— dualtest    同步进行双向测试-n/— num    传输的字节量-r/— tradeoff    分别进行双向测试-t/— time    传输持续时间 （默认10 secs）-F/— fileinput    从文件中读取要传输的数据-I/— stdin    从标准输入（stdin）中读取要传输的数据-L/— listenport    双向测试接受端口-P/— parallel    并行客户线程数量-T/— ttl    多点传送的生存时间（默认1）</code></pre><h2 id="Netperf"><a href="#Netperf" class="headerlink" title="Netperf"></a>Netperf</h2><p>Netperf是一种网络性能测量工具，主要用于测试TCP或UDP和Berkeley套接字接口的批量数据传输（bulk data transfer）和请求/应答（request/reponse）性能。Netperf工具以Client/Server方式工作，如下图所示：  </p><p><img src="https://i.loli.net/2018/10/15/5bc458630db61.png" alt="02.png"><br>服务端是netServer，用来侦听来自客户端的连接，客户端是netperf，用来向服务发起网络测试。在客户端与服务端之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果。在控制连接建立并传递了测试配置信息以后，客户端与服务端之间会再建立一个测试连接，用于来回传递特殊的流量，以测试网络的性能。当netServer在服务端启动后，就可在客户端运行netperf来测试网络的性能。netperf通过命令行参数来控制测试的类型和具体的测试选项，根据作用范围的不同，netperf的命令行参数可以分为两大类：全局命令行参数和测试相关的局部参数，两者之间使用—分隔。</p><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote></blockquote><pre><code>netperf [global options] —[test-specific options]</code></pre><h4 id="global-options"><a href="#global-options" class="headerlink" title="global options"></a>global options</h4><blockquote></blockquote><pre><code>-H host    指定远端运行netserver的server IP地址-l testlen    指定测试的时间长度（秒）-t testname    指定进行的测试类型（TCP_STREAM，UDP_STREAM，TCP_RR，TCP_CRR，UDP_RR）</code></pre><h4 id="test-specific-options"><a href="#test-specific-options" class="headerlink" title="test-specific options"></a>test-specific options</h4><blockquote></blockquote><pre><code>-s size    设置本地系统的socket发送与接收缓冲大小-S size    设置远端系统的socket发送与接收缓冲大小-m size    设置本地系统发送测试分组的大小-M size    设置远端系统接收测试分组的大小-D    对本地与远端系统的socket设置TCP_NODELAY选项-r req,resp    设置request和reponse分组的大小</code></pre><h1 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h1><p>Scapy是一个基于Python编写的交互式数据包处理程序，使用Python解释器作为命令面板。可以用来发送、嗅探、解析和伪造网络数据包，常常被用于网络攻击和测试。Scapy可以实现扫描、路由跟踪、探测、单元测试、攻击和发现网络等传统功能，也可以代替hping、arpspoof、arp-sk、arping、p0f，实现了部分Namp、Tcpdump和tshark的功能。它能够伪造或者解码大量的网络协议数据包，能够发送、捕捉、匹配请求和回复包等等。它可以很容易地处理一些典型操作，比如端口扫描，tracerouting，探测，单元测试，攻击或网络发现（可替代hping，NMAP，arpspoof，ARP-SK，arping，tcpdump，tethereal，P0F等）。最重要的他还有很多更优秀的特性——发送无效数据帧、注入修改的802.11数据帧、在WEP上解码加密通道（VOIP）、ARP缓存攻击（VLAN）等，这也是其他工具无法处理完成的。  </p><p>Scapy有其他网络工具无法匹敌的优势，在大多数工具无法完成的任务中也有出色表现，比如发送无效帧、添加自定义的802.11帧、多技术结合等。其实，Scapy的理念非常简单，主要负责定义、发送和接收报文。用户利用Scapy定义一系列报文，接着发送这些报文，然后会收到回应，Scapy将收到的回应与请求匹配，返回到存放报文对（请求，回应）的列表和没有匹配报文的列表。  </p><p>Scapy不仅可以进行交互式数据包处理，还可以作为Python模块在Python程序中使用。需要注意的是，无论是交互式数据处理还是在Python代码中使用，都需要基于root权限。  </p><p>Scapy既然是第三方库，系统上默认是没有安装的。在Ubuntu下，我们可以直接使用命令：</p><blockquote></blockquote><pre><code>sudo apt-get install scapy</code></pre><p>进行安装，安装完成以后，只需要在终端下执行sudo scapy就可以进入Scapy的命令行模式。  </p><p>Scapy常用功能:</p><blockquote><p>1、conf：查看配置信息<br>2、lsc()：查看支持的指令集<br>3、ls()：查看实现的网络协议。ls()中携带的参数可以是任何的一个具体的包，常用的有ARP、Ether、ICMP、IP、UDP、TCP，也支持SNMP、DHCP、STP等。<br>4、IP模块的使用:</p><blockquote><p>我们可以像在Python中一样实例化一个IP对象:</p><blockquote><p>data = IP()<br>data<br>    <ip><br>也可以传入需要自定义的参数:</ip></p></blockquote><blockquote><p>data = IP(dst=”172.16.2.79”)<br>data<br>    <ip dst="172.16.2.79"><br>查看 IP 模块对象的所有信息:</ip></p></blockquote><blockquote><p>data = IP()<br>data.show() </p></blockquote></blockquote></blockquote><pre><code>###[ IP ]### version= 4 ihl= None tos= 0x0 len= None id= 1 flags= frag= 0 ttl= 64 proto= ip chksum= None src= 127.0.0.1 dst= 127.0.0.1 \options\</code></pre><blockquote><p>5、发送和接收报文：<br>可以将上面的 IP 对象封装成一个数据包发送出去。</p><blockquote><p>send：在第三层发送数据包，但没有接收功能。</p><blockquote><p>send(data, iface=”eth0”)<br>    .<br>    Sent 1 packets.<br>sendp：在第二层发送数据包，同样没有接收功能。<br>sr：在第三层发送数据包，有接收功能。<br>sr1：在第三层发送数据包，有接收功能，但只接收第一个包。<br>srp：在第二层发送数据包，有接收功能。<br>srp1：在第二层发送数据包，有接收功能，但只接收第一个包。</p></blockquote></blockquote></blockquote><h1 id="HTTP请求测试工具Postman"><a href="#HTTP请求测试工具Postman" class="headerlink" title="HTTP请求测试工具Postman"></a>HTTP请求测试工具Postman</h1><p>Postman是Google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件。其主要功能包括：<br>模拟各种HTTP requests：</p><blockquote><p>从常用的GET、POST到RESTful的PUT、DELETE等等。甚至还可以发送文件、送出额外的header。</p></blockquote><p>Collection功能（测试集合）:</p><blockquote><p>Collection是requests的集合，在做完一个测试的时候，你可以把这次的 request 存到特定的 Collection 里面，如此一来，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API。而且 Collection还可以Import或是Share出来，让团队里面的所有人共享你建立起来的Collection。</p></blockquote><p>人性化的Response整理:</p><blockquote><p>一般在用其他工具来测试的时候，response的内容通常都是纯文字的raw，但如果是JSON，就是塞成一整行的JSON。这会造成阅读的障碍，而Postman可以针对response内容的格式自动美化。JSON、XML或是HTML都会整理成我们可以阅读的格式。</p></blockquote><p>内置测试脚本语言:</p><blockquote><p>Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果。</p></blockquote><p>设定变量与环境</p><blockquote><p>Postman可以自由设定变量与环境，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我们可能会有多种环境，development、staging或local，而这几种环境中的request URL也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Wireshark&quot;&gt;&lt;a href=&quot;#Wireshark&quot; class=&quot;headerlink&quot; title=&quot;Wireshark&quot;&gt;&lt;/a&gt;Wireshark&lt;/h1&gt;&lt;p&gt;Wireshark这款网络数据包分析工具，在传统网络中就有很广泛的应用，这里就不再多
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>一键安装 Caddy+PHP7+Sqlite3 环境</title>
    <link href="https://cyneliu.github.io/2018/10/13/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85-Caddy-PHP7-Sqlite3-%E7%8E%AF%E5%A2%83/"/>
    <id>https://cyneliu.github.io/2018/10/13/一键安装-Caddy-PHP7-Sqlite3-环境/</id>
    <published>2018-10-13T10:42:18.000Z</published>
    <updated>2018-10-16T14:22:39.788Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多人都有自己搭建网站的需求，但个人网站一般都是个人博客之类的，并不需要很高的服务器配置，这时候就可以考虑使用一个配置比较低的vps来放置自己的个人网站，那么下面这个脚本包你可能刚好会用得到。  </p><p>这个脚本支持Centos 7+ Debian 8+，最小支持内存为64M，可以一键安装 typecho、wordpress、zblog、kodexplorer、laverna、一键整站备份等操作，不仅如此还可以安装v2ray、rinetdbbr来科学上网和加速。</p><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>配置过程很简单，首先将自己的域名解析到vps的ip地址上。然后执行如下命令：</p><blockquote></blockquote><pre><code>wget -N --no-check-certificate git.io/c.sh &amp;&amp; chmod +x c.sh &amp;&amp; bash c.sh</code></pre><p>安装完成后可以根据需要上传自己的网站或者选择一键安装：<br><strong>一键安装typecho博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -t</code></pre><p><strong>一键安装wordpress博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -w</code></pre><p><strong>一键安装zblog博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -z</code></pre><p><strong>一键安装 kodexplorer 可道云</strong></p><blockquote></blockquote><pre><code>bash c.sh -k</code></pre><p><strong>一键安装 laverna 印象笔记</strong></p><blockquote></blockquote><pre><code>bash c.sh -l</code></pre><p><strong>一键整站备份（一键打包/www目录 含数据库）</strong></p><blockquote></blockquote><pre><code>bash c.sh -a</code></pre><p><strong>一键安装 v2ray 翻墙</strong></p><blockquote></blockquote><pre><code>bash c.sh -v</code></pre><p><strong>一键安装 rinetd bbr 端口加速</strong></p><blockquote></blockquote><pre><code>bash c.sh -b</code></pre><p><strong>一键卸载命令：</strong></p><p><em>卸载 caddy</em></p><blockquote></blockquote><pre><code>bash c.sh -unc</code></pre><p><em>卸载 php+sqlite</em></p><blockquote></blockquote><pre><code>bash c.sh -unp</code></pre><p><em>卸载 v2ray</em></p><blockquote></blockquote><pre><code>bash c.sh -unv</code></pre><p><em>卸载 rinetdbbr</em></p><blockquote></blockquote><pre><code>bash c.sh -unb</code></pre><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3" target="_blank" rel="noopener">https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信很多人都有自己搭建网站的需求，但个人网站一般都是个人博客之类的，并不需要很高的服务器配置，这时候就可以考虑使用一个配置比较低的vps来放置自己的个人网站，那么下面这个脚本包你可能刚好会用得到。  &lt;/p&gt;
&lt;p&gt;这个脚本支持Centos 7+ Debian 8+，最小支
      
    
    </summary>
    
      <category term="脚本" scheme="https://cyneliu.github.io/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
      <category term="脚本" scheme="https://cyneliu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="vps" scheme="https://cyneliu.github.io/tags/vps/"/>
    
      <category term="网站" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Cisco设备密码重置</title>
    <link href="https://cyneliu.github.io/2018/10/11/Cisco%E8%AE%BE%E5%A4%87%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/"/>
    <id>https://cyneliu.github.io/2018/10/11/Cisco设备密码重置/</id>
    <published>2018-10-11T13:47:03.000Z</published>
    <updated>2018-10-16T14:14:09.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p>1 重启路由器，按ctrl+break/pause或ctrl+c/b,进入remmon模式  </p><blockquote><p>笔记本电脑可能没有pause键，可以运行：osk使用屏幕键盘进行操作  </p></blockquote><p>2 confreg 0x2142　修改寄存器的值  </p><p>3 reset　重启  </p><p>4 copy start run　把nvram内的文件转到内存中  </p><p>5 config-register 0x2102  </p><p>6 修改密码  </p><p>7 copy run start  </p><p>8 reload  </p><blockquote></blockquote><p><strong>0x2142:</strong>路由器启动不读取NVRAM，出厂配置启动<br><strong>0x2102:</strong>路由器启动读取NVRAM，正常配置启动<br><strong>0x2101:</strong>路由器启动不读取新指定的IOS，以出厂IOS启动，通常为base版本，支持功能有限</p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>1 重启，按面板上的mode键3-5秒  </p><p>2 进入switch：模式  </p><p>3 输入：flash_init 初始化flash文件系统  </p><p>4 dir flash:查看flash内文件，其中包含配置文件为config.text  </p><p>5 rename flash:config.text flash:config.old 把原来的文件重命名，随意起名字  </p><p>6 boot重启  </p><p>7 rename flash:config.old flash:config.text   </p><p>8 copy flash:config.text system:running-config  </p><p>9 修改密码  </p><p>10 copy run start 保存配置  </p><p>11 reload/reset/boot 重启  </p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>密码必须要进行修改，不能不设置，如果不需要密码可在修改密码之后进入配置模式删除密码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路由器&quot;&gt;&lt;a href=&quot;#路由器&quot; class=&quot;headerlink&quot; title=&quot;路由器&quot;&gt;&lt;/a&gt;路由器&lt;/h1&gt;&lt;p&gt;1 重启路由器，按ctrl+break/pause或ctrl+c/b,进入remmon模式  &lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="Cisco" scheme="https://cyneliu.github.io/categories/Cisco/"/>
    
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
      <category term="Cisco" scheme="https://cyneliu.github.io/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>linux系统配置检测工具——Superbench</title>
    <link href="https://cyneliu.github.io/2018/10/10/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Superbench/"/>
    <id>https://cyneliu.github.io/2018/10/10/linux系统配置检测工具——Superbench/</id>
    <published>2018-10-10T09:34:56.000Z</published>
    <updated>2018-10-16T14:14:50.507Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经就暗暗吐槽Linux没有一条可以查看配置信息的命令，只能一项一项的查看，体验不是很好。今天无意中发现了一个叫做<strong>Superbench</strong>的脚本，试着用了一下，非常方便，在这里推荐一下。  </p><p>这个脚本主要有以下几个特点：</p><blockquote><p>采用颜色显示，便于区分查找  </p><p>磁盘I/O测试分别使用小文件、中等文件、大文件进行测试，最终计算平均值。  </p><p>网速测试通过多个节点进行测试，其中CM,CU,CT分别代表移动、联通和电信。</p><blockquote><p>ps:<br>中国移动：CMCC ，全称ChinaMobile Communication Company<br>中国联通：CUCC，全称China unicom Communications Corporation<br>中国电信：CTC，全称China Telecommunications Corporation  </p></blockquote></blockquote><h1 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h1><p>执行如下命令:</p><blockquote></blockquote><pre><code>wget -qO- git.io/superbench.sh | bash</code></pre><p>稍等一会就会打印出详细的配置信息：  </p><p><img src="https://i.loli.net/2018/10/10/5bbdccb7a8783.png" alt="01.png"><br><img src="https://i.loli.net/2018/10/10/5bbdccb7aa383.png" alt="02.png"><br>同时我们看到最后还附带了一个分享链接用于分享我们的配置信息，在浏览器打开是这个样子的：  </p><p><img src="https://i.loli.net/2018/10/10/5bbdccb7b6cd2.png" alt="03.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我曾经就暗暗吐槽Linux没有一条可以查看配置信息的命令，只能一项一项的查看，体验不是很好。今天无意中发现了一个叫做&lt;strong&gt;Superbench&lt;/strong&gt;的脚本，试着用了一下，非常方便，在这里推荐一下。  &lt;/p&gt;
&lt;p&gt;这个脚本主要有以下几个特点：&lt;/p&gt;
      
    
    </summary>
    
      <category term="脚本" scheme="https://cyneliu.github.io/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
      <category term="脚本" scheme="https://cyneliu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="配置检测" scheme="https://cyneliu.github.io/tags/%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的命令行网盘</title>
    <link href="https://cyneliu.github.io/2018/10/09/Linux%E4%B8%8B%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BD%91%E7%9B%98/"/>
    <id>https://cyneliu.github.io/2018/10/09/Linux下的命令行网盘/</id>
    <published>2018-10-09T10:17:56.000Z</published>
    <updated>2018-10-16T14:15:21.523Z</updated>
    
    <content type="html"><![CDATA[<p>之前浏览别人博客的时候发现了一个非常好用的文件上传分享工具，而且是在Linux下的，今天试着用了一下，用起来方便快捷，感觉很不错。  </p><p>这款工具的名字叫做<strong>transfer.sh</strong>，transfer.sh的使用也非常简单，可以使用curl的upload-file来上传文件。我这里测试用的是我的一台用作ssr的centos：  </p><p><img src="https://i.loli.net/2018/10/09/5bbc835018e45.png" alt="01.png"></p><p>上图中我是要把当前目录下的“bbr.sh”文件上传分享出去，并且重命名为“bbr2.sh”。那么我们只需要执行如下命令即可：</p><blockquote></blockquote><pre><code>curl --upload-file ./bbr.sh https://transfer.sh/bbr2.sh</code></pre><p>上传完毕后就会返回一个分享链接，也就是“<a href="https://transfer.sh/9edgU/bbr2.sh”，把这个链接发给别人就可以下载了。" target="_blank" rel="noopener">https://transfer.sh/9edgU/bbr2.sh”，把这个链接发给别人就可以下载了。</a>  </p><p><img src="https://i.loli.net/2018/10/09/5bbc8491c4b3b.png" alt="02.png"></p><p>除此之外，transfer.sh还提供其它多种方式，比如一次性上传多个文件等，感兴趣的可以访问官网。  </p><p><strong><em>官网：</em></strong><br><a href="https://transfer.sh/" target="_blank" rel="noopener">https://transfer.sh/</a><br><strong><em>Github:</em></strong><br><a href="https://github.com/dutchcoders/transfer.sh/" target="_blank" rel="noopener">https://github.com/dutchcoders/transfer.sh/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前浏览别人博客的时候发现了一个非常好用的文件上传分享工具，而且是在Linux下的，今天试着用了一下，用起来方便快捷，感觉很不错。  &lt;/p&gt;
&lt;p&gt;这款工具的名字叫做&lt;strong&gt;transfer.sh&lt;/strong&gt;，transfer.sh的使用也非常简单，可以使用
      
    
    </summary>
    
      <category term="脚本" scheme="https://cyneliu.github.io/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>6.使用OpenDaylight界面下发流表</title>
    <link href="https://cyneliu.github.io/2018/09/16/6-%E4%BD%BF%E7%94%A8OpenDaylight%E7%95%8C%E9%9D%A2%E4%B8%8B%E5%8F%91%E6%B5%81%E8%A1%A8/"/>
    <id>https://cyneliu.github.io/2018/09/16/6-使用OpenDaylight界面下发流表/</id>
    <published>2018-09-16T12:11:24.000Z</published>
    <updated>2018-10-16T14:12:41.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>YANG UI是OpenDaylight中一款基于DLUX的应用，旨在简化、激励应用的开发与测试。YANG UI通过动态封装、调用YANG模型和相关REST APIs，生成并展示一个简单的UI界面。开发人员可以通过API请求获取交换机信息，并且以JSON格式展示。YANG UI主要面向上层应用开发，为应用开发人员提供了很多相关工具，有效的节约了开发人员的时间。  </p><p>OpenFlow1.0协议处理数据包的流程相对简单，因为1.0版本只支持单流表。交换机接收到数据包后解析数据包，数据包解析后就开始匹配，从table 0 开始匹配，如果匹配成功则对该数据包执行相应的动作，更新相应的计数器。如果没有找到匹配项则将数据包交给控制器。  </p><p>OpenFlow1.3协议支持多流表匹配，即一个交换机只会有多个流表，因此数据包处理过程相对复杂。首先解析进入设备的报文，然后从table 0开始匹配，按照优先级高低依次匹配该流表中的流表项，一个报文在一个流表中只会匹配上一条流表项。通常根据报文的类型，报文头的字段例如源MAC地址、目的MAC地址、源IP地址、目的IP地址等进行匹配，大部分匹配还支持掩码进行更精确、灵活的匹配。也可以通过报文的入端口或元数据信息来进行报文的匹配，一个流表项中可以同时存在多个匹配项，一个报文需要同时匹配流表项中所有匹配项才能匹配该流表项。报文匹配按照现有的报文字段进行，比如前一个流表通过apply actions改变了该报文的某个字段，则下一个表项按修改后的字段进行匹配。如果匹配成功，则按照指令集里的动作更新动作集，或更新报文/匹配集字段，或更新元数据和计数器。根据指令是否继续前往下一个流表，不继续则终止匹配流程执行动作集，如果指令要求继续前往下一个流表则继续匹配，下一个流表的ID需要比当前流表ID大。当报文匹配失败了，如果存在无匹配流表项（table miss）就按照该表项执行指令，一般是将报文转发给控制器、丢弃或转发给其他流表。如果没有table miss表项则默认丢弃该报文。  </p><p>在Open vSwitch中，流表项作为ovs-ofctl的参数，采用“字段=值”的格式。如果有多个字段，可以用逗号分开，一些常见字段如下：<br><img src="https://i.loli.net/2018/09/16/5b9e4929f0d63.png" alt="1.png"></p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/16/5b9e494803043.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>登录交换机，检查网络连通性。当显示“is_connected：ture”时，表示交换机与控制器连接成功，可以正常进行实验。若不显示“is_connected：ture”时，表示交换机与控制器连接不成功，执行:</p><blockquote></blockquote><pre><code>ovs-vsctl del-controller br-swovs-vsctl set-controller br-sw tcp:30.0.1.3:6633 </code></pre><p>命令手动重连，稍等一会后，重新查看连接状态。</p><h1 id="基于OpenFlow1-0协议下发流表"><a href="#基于OpenFlow1-0协议下发流表" class="headerlink" title="基于OpenFlow1.0协议下发流表"></a>基于OpenFlow1.0协议下发流表</h1><p>步骤1 切换到交换机，执行以下命令设置OpenFlow协议版本为1.0。  </p><blockquote></blockquote><pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow10</code></pre><p>步骤2 选择控制器，单击浏览器图标，打开浏览器。  </p><p>步骤3 访问OpenDaylight Web页面，url是<a href="http://127.0.0.1:8080/index.html" target="_blank" rel="noopener">http://127.0.0.1:8080/index.html</a> ，用户名和密码是admin/admin，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a2625fb7.png" alt="2.png"><br>步骤4 单击左侧的“Nodes”查看节点信息。其中尤其需要关注Node Id，下发流表的时候会用到Node Id，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a653f1bb.png" alt="3.png"><br>步骤5 单击上图中的“Node Connectors”列的数据即“9”，可以查看具体节点连接信息，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4ac29c305.png" alt="4.png"><br>步骤6 选择左侧的“Yang UI”，单击“Expand all”展开所有目录，查看各种模块，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4af0e3b80.png" alt="5.png"><br>步骤7 展开“opendaylight-inventory rev.2013-08-19”，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b115e5c9.png" alt="6.png"><br>步骤8 补全node id、table id和flow id的值。  </p><p>其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.0协议只支持单流表，所以这里的table id设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b3798ac7.png" alt="7.png"><br>步骤9 单击flow list后面的“+”，展开流表相关的参数。填写第一个框id，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b59027ad.png" alt="8.png"><br>步骤10 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为“0x0800”(说明：由于使用IP地址进行匹配，所以需要设置以太网协议类型。),如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b789668c.png" alt="9.png"><br>步骤11 填写匹配参数，在“layer-3-match”后面的下拉框中选择“ipv4-match”，使用IP匹配。  </p><p>步骤12 展开“layer-3-match”，填写源IP地址和目的IP地址，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bc1b5579.png" alt="10.png"><br>其中源地址填写主机1的IP地址，目的地址填写主机2的IP地址。  </p><p>步骤13 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bec99e16.png" alt="11.png"><br>步骤14 展开“apply-actions”，单击“action list”后面的“+”，在action后面的下拉框中选择“drop-action-case”，action order和instruction order都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c0f7a101.png" alt="12.png"><br>步骤15 设置“priority”为27，“idle-timeout”为0，“hard-timeout”为0，“cookie”为100000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c2f54bc4.png" alt="13.png"><br>说明：priority设置的比已有流表项的高，而idle-timeout和hardtimeout都设置为0则代表该流表项永远不会过期，除非被删除。  </p><p>步骤16 向右滚动Actions栏，在路径后面有动作类型GET、PUT、POST、DELETE，下发流表则选择PUT动作，然后单击“Send”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c5b47302.png" alt="14.png"><br>步骤17 如果下发成功会出现下面的提示，如果下发不成功则会弹出相应的错误信息。<br><img src="https://i.loli.net/2018/09/16/5b9e4c9033d8d.png" alt="15.png"><br>步骤18 切换到交换机，执行如下命令查看流表，确保刚刚下发的流表已经下发到交换机。如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cc42a811.png" alt="16.png"><br>步骤19 登录主机1，执行如下命令向主机2、主机3发送数据包，测试主机间的连通性。</p><blockquote></blockquote><pre><code># scapy&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cfe4003b.png" alt="17.png"><br>由上图可知，主机1与主机2之间不通，主机1与主机3通，新下发的流表项生效。  </p><p>说明：如果主机之间通则能够收到answer，如果主机之间不通那么就无法收到answer，当主机之间不通时scapy就会一直发送数据包，如果需要停止可以使用Ctrl+c。  </p><p>步骤20 切换到交换机，执行以下命令删除刚刚下发的流表项，并查看流表确保成功删除。  </p><blockquote></blockquote><pre><code>ovs-ofctl del-flows br-sw dl_type=0x0800,nw_src=10.0.0.3,nw_dst=10.0.0.4ovs-ofctl dump-flows br-sw</code></pre><p>步骤21 切换到主机1执行如下命令，测试主机1和主机2是否连通。</p><blockquote></blockquote><pre><code>result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4d486b69c.png" alt="18.png"><br>由上图可知，主机1与主机2之间就通了。</p><h1 id="基于OpenFlow1-3协议下发流表"><a href="#基于OpenFlow1-3协议下发流表" class="headerlink" title="基于OpenFlow1.3协议下发流表"></a>基于OpenFlow1.3协议下发流表</h1><p>步骤1 登录交换机，设置OpenFlow协议版本为1.3。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow13</code></pre><p>步骤2 与OpenFlow1.0下发流表的过程解基本一致。展开opendaylight-inventory rev.2013-08-19，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”。  </p><p>步骤3 补全Actions栏中的路径，其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.3协议支持多级流表，所以这里的table id设置为2。  </p><p>步骤4 单击flow list后面的“+”，流表相关的参数就会展开。设置id为1，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e592464e82.png" alt="19.png"><br>步骤5 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e594c3f115.png" alt="20.png"><br>步骤6 在“layer-3-match”后面的下拉框中选择“ipv4-match”。  </p><p>步骤7 展开“layer-3-match”，填写源IP地址和目的IP地址。以主机1的IP为源IP，以主机3的IP为目的IP，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5979b8763.png" alt="21.png"><br>步骤8 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e599fdaa67.png" alt="22.png"><br>步骤9 展开“apply-actions”，单击“action list”后面的“+”，在“action”后面的下拉框中选择“drop-action-case”，“action order”和“instruction order”都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59c4a3dca.png" alt="23.png"><br>步骤10 设置“priority”为25，“idle-timeout”为0，“hard-timeout”为0，“cookie”为10000000，“table_id”为2，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59eb63de3.png" alt="24.png"><br>步骤11 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。PUT成功就会弹出“Request sent successfully”，否则弹出错误信息。  </p><p>步骤12 切换到主机1，执行如下命令，向主机3发送数据包，测试主机1和主机3的连通性。</p><blockquote></blockquote><pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5a28ba934.png" alt="25.png"><br>由上图可知，主机1与主机3之间是连通的，新下发的流表没有发挥作用。原因是数据包在table 0中能够匹配到相应流表就不会被转发到table2，想要table2的流表项发挥作用就需要向table0增加一条流表，将源IP为10.0.0.3，目的IP为10.0.0.2的数据包转发到table2中处理。  </p><p>步骤13 选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{i}”。node id参见之前查询到的Node Id、table id设为0、flow id设为1。  </p><p>步骤14 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800。  </p><p>步骤15 匹配参数保持不变，以主机1的IP为源IP，以主机3的IP为目的IP。  </p><p>步骤16 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“go-to-table-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5a73537cd.png" alt="26.png"><br>步骤17 展开“go-to-table”，table_id填写为2，即将符合匹配条件的数据包根据table2中的流表项处理。instruction order依旧设为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5aa888c72.png" alt="27.png"><br>步骤18 设“priority”置为23，“idle-timeout”为0，“hard-timeout”为0，“cookie”为1000000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5ad13fe66.png" alt="28.png"><br>步骤19 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。  </p><p>步骤20 切换到交换机，执行以下命令查看新下发的流表项。</p><blockquote></blockquote><pre><code>ovs-ofctl -O OpenFlow13 dump-flows b</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b076d691.png" alt="29.png"><br>步骤21 切换到主机1，执行如下命令发送数据包，测试主机之间的连通性。</p><blockquote></blockquote><pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b4ae09ab.png" alt="30.png"><br>由上图可知，主机1与主机3之间不通，而主机1与主机2之间通，流表发挥作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;YANG UI是OpenDaylight中一款基于DLUX的应用，旨在简化、激励应用的开发与测试。YANG UI通过动态封装
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>5.OpenFlow实现示例之中继器HUB</title>
    <link href="https://cyneliu.github.io/2018/09/15/5-OpenFlow%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%AD%E7%BB%A7%E5%99%A8HUB/"/>
    <id>https://cyneliu.github.io/2018/09/15/5-OpenFlow实现示例之中继器HUB/</id>
    <published>2018-09-15T13:09:29.000Z</published>
    <updated>2018-10-16T14:12:07.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow的流表项主要由3部分组成，分别是用于数据分组匹配的分组头域（Head Field），用于保存与条目相关统计信息的计数器（Counter），还有匹配表项后需要对数据分组执行的动作表（Action）。分组头域是数据分组匹配流表项时参照的依据，作用上类似于传统交换机进行二层交换时匹配数据分组的MAC地址，路由器进行三层路由时匹配的IP地址。流表项中的计数器用来统计相关“流”的一些信息，例如查找次数、收发分组数、生存时间等。另外，OpenFlow针对每张表、每个流表项、每个端口、每个队列也都会维护它们相应的计数器。动作表指定了OpenFlow交换机处理相应“流”的行为。相比于传统网络设备对数据分组只能进行较为单一的转发操作，流表项根据指定动作字段来指导OF交换机如何处理“流”。动作表可以包含0个或多个动作，交换机会按照这些动作的先后顺序依次执行，如果其中不包含转发（Forward）动作的话，数据分组就会被丢弃掉，如果包含转发动作，数据分组会得到相应的转发处理，但是OpenFlow v1.0无法保证不同的数据分组的转发顺序。动作可以分为两种类型：必选动作（Required Action）和可选动作（Optional Action）。必选动作是默认支持的，而交换机需要通知控制器它支持的可选动作。另外，当流表项中存在OpenFlow交换机不支持的动作时将向控制器返回错误消息。在SDN网络中，控制器下发流表主要有两种模式，分别是reactive模式和proactive模式。  </p><p>传统交换机参照MAC地址转发，路由器参照IP地址转发，通过定制ASIC芯片可以实现高速工作。而OpenFlow将网络协议栈扁平化，协议栈各层次对于转发设备而言不再具有明确的界限，各个网络字段都可作为流表中的匹配域，通过通配符掩码实现任意字段的组合。相比于传统网络，这种做法无疑大大提高了网络灵活性，但付出的代价是硬件设备为了适应这种通配的匹配方式，一般来说需要采用TCAM（Ternary Content Addressable Memory）来设计流表，但是TCAM的成本要高出很多，这就极大地限制了流表的规模，也就限制了SDN的规模。如果按照很多客户的要求，动辄要几十KB甚至上百KB的流表要求，至少需要20Mbit的TCAM，远远超过目前市场上容量最大的交换芯片的TCAM大小。为了克服TCAM表较小的问题，SDN先驱们提出采用reactive的方式来编写TCAM。<br><img src="https://i.loli.net/2018/09/15/5b9d05573ed46.png" alt="1.png"><br>在reactive模式下，OpenFlow交换机接收到未知数据包时，会向控制器发送一条packet_in消息询问控制器如何处理该数据包。控制器接收到packet_in消息后，计算路径并发送一条flow_mod消息指示交换机如何处理该数据包。并且，当老化定时器超时后就可以删除与该数据包相关的流表项。如此一来，OpenFlow交换机无需维护全部流表，只有当未知数据包到达交换机时才会触发reactive模式，可以有效的节省TCAM的空间。但是reactive模式缺点就是交换机无法即时地处理未知数据包，需要依赖控制器的决策，虽然在一定程度上解决了TCAM较小带来的问题，但是也让SDN控制器成为系统扩展的瓶颈，随着网络规模的不断扩大，SDN控制器无法处理大规模的网络流量，SDN控制器的性能就会限制网络规模的扩展。  </p><p>OpenFlow交换机和OpenFlow控制器之间的通道建立后，由OpenFlow控制器向OpenFlow交换机预先发送流表项方式称之为proactive模式。proactive模式的设置不是必须在控制器与交换机建立连接后立刻下发流表，可以在连接建立后的任意时间下发流表。proactive模式的主要特点是“主动”，控制器主动下发流表给交换机，随后交换机可以直接根据流表进行转发。proactive模式下控制器的压力会大大减轻，不过TCAM造成的局限性也尤为明显。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9d0af0ac5d1.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，检查网络连通性。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p><p>步骤2 登录主机，查看主机IP。  </p><p>登录交换机，查看交换机mac地址。  </p><blockquote></blockquote><pre><code>ifconfig |more</code></pre><p>根据实验拓扑图、交换机和主机的mac地址，可以判断出交换机eth1连接host1，eth2连接host2，eth3连接host3。</p><h1 id="proactive模式"><a href="#proactive模式" class="headerlink" title="proactive模式"></a>proactive模式</h1><p>步骤1 Open Daylight控制器与交换机建立连接后，会自动下发初始流表。登录交换机使用下列命令查看初始流表。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p>如果没有的话重启一下交换机。<br><img src="https://i.loli.net/2018/09/15/5b9d129607bf4.png" alt="2.png"><br>步骤2 登录控制器，在下方的“Application Finder”中搜索“postman”，并打开自带的Postman工具，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d151e53f54.png" alt="3.png"><br>步骤3 获取交换机的id信息。打开Basic Auth页签，Username字段填写admin，Password字段填写admin完成认证。  </p><p>提交方式为GET，URL地址栏中输入<a href="http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。</a>  </p><p>步骤4 单击Send按钮，获取交换机id信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d156896885.png" alt="4.png"><br>步骤5 下发一条流表。</p><blockquote><p>选择提交方式“PUT”。  </p></blockquote><blockquote><p>URL地址栏输入如下形式的地址：http://{controller-ip}:8080/restconf/config/opendaylight-inventory:nodes/node/{node-id}/table/{table-id}/flow/{flow-id}。  </p></blockquote><blockquote><p>其中，{controller-ip}为控制器的ip地址，node-id为上面获取到的交换机id信息，table-id这里为0，flow-id根据下发不同流表变化，可自定义。本实验URL地址栏输入如下地址：<a href="http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。</a>  </p></blockquote><blockquote><p>填写Headers信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d16d59439b.png" alt="5.png"><br>单击Body，Bady格式选择raw—&gt;XML(application/xml)。Body内容如下所示：  </p></blockquote><blockquote><p>匹配条件为ANY，actions为ALL，即将交换机收到的所有数据包转发到除入端口外的所有端口，从而实现中继器HUB的功能。</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;priority&gt;35&lt;/priority&gt;    &lt;flow-name&gt;SDN&lt;/flow-name&gt;    &lt;idle-timeout&gt;0&lt;/idle-timeout&gt;    &lt;hard-timeout&gt;0&lt;/hard-timeout&gt;    &lt;match&gt;ANY&lt;/match&gt;    &lt;id&gt;14&lt;/id&gt;    &lt;table_id&gt;0&lt;/table_id&gt;    &lt;instructions&gt;        &lt;instruction&gt;            &lt;order&gt;0&lt;/order&gt;            &lt;apply-actions&gt;                &lt;action&gt;                       &lt;output-action&gt;                          &lt;output-node-connector&gt;ALL&lt;/output-node-connector&gt;                       &lt;/output-action&gt;                       &lt;order&gt;0&lt;/order&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;        &lt;/instruction&gt;    &lt;/instructions&gt;&lt;/flow&gt;</code></pre><p>步骤6 单击Send按钮发送请求，STATUS显示请求发送成功，流表下发成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d18177ec0e.png" alt="6.png"><br>步骤7 登录交换机查看下发的流表，执行以下命令：</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d184ac4929.png" alt="7.png"><br>步骤8 登录主机host1，对主机host2进行ping操作，host2的IP为10.0.0.10，执行以下命令：</p><blockquote></blockquote><pre><code>ping 10.0.0.10</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18930750e.png" alt="8.png"><br>步骤9 登录交换机用tcpdump捕获广播到host2和host3数据包。host2对应的端口是eth2，host3对应的端口是eth3，分别捕获这两个端口上的数据包。  </p><p>（备注：选择不在host3、host2上抓包的原因是：由于当h1 ping h2时，数据包从交换机所有端口output出去后，openstack中的Linux-bridge会根据转发表过滤掉所有目的地址与端口不一致的数据包，因此host3上无法捕获host1与host2之间的数据包。）</p><blockquote></blockquote><pre><code>tcpdump -i eth2</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18d0ab61c.png" alt="9.png"></p><blockquote></blockquote><pre><code>tcpdump -i eth3</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d19734c90f.png" alt="10.png"></p><h1 id="reactive模式"><a href="#reactive模式" class="headerlink" title="reactive模式"></a>reactive模式</h1><p>reactive模式需要依赖SDN控制器的反应，实现较为复杂，在此仅进行方案介绍，不做实验操作，有兴趣的同学可自行拓展学习。  </p><p>步骤1 reactive模式的触发机制就是交换机将接收到数据包转发给控制器，交换机转发数据包给控制器的情况有两种：一个是交换机接收到未知数据包；另一个就是流表action要求交换机将数据包转发给控制器。因此设置reactive模式的第一步是下发一条流表，priority设置为最高65535，匹配条件为ANY，actions是将数据包output到controller。<br><img src="https://i.loli.net/2018/09/15/5b9d1a21ac061.png" alt="11.png"><br>流表项设置好后，当host1发送数据包时，交换机接收到数据包后会发送packet_in消息给控制器。  </p><p>步骤2 控制器接收到packet_in消息后对消息中的内容进行判断，计算分析后发送packet_out消息给交换机，告知交换机如何处理该数据包。本实验中控制器会要求交换机将数据包转发到除入端口外的所有端口，从而实验中继器的功能。<br><img src="https://i.loli.net/2018/09/15/5b9d1a4af035d.png" alt="12.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;OpenFlow的流表项主要由3部分组成，分别是用于数据分组匹配的分组头域（Head Field），用于保存与条目相关统计信
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>4.基于RESTCONF的流表管理</title>
    <link href="https://cyneliu.github.io/2018/09/14/4-%E5%9F%BA%E4%BA%8ERESTCONF%E7%9A%84%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/14/4-基于RESTCONF的流表管理/</id>
    <published>2018-09-14T14:36:06.000Z</published>
    <updated>2018-10-16T14:12:17.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>所谓流表，其实可被视作是SDN对网络设备的数据转发功能的一种抽象。在传统网络设备中，交换机和路由器的数据转发需要依赖设备中保存的二层MAC地址转发表或者三层的IP地址路由表，SDN交换机中使用的流表也是如此，不过在它的表项中整合了网络中各个层次的网络配置信息，从而在进行数据转发时可以使用更丰富的规则。  </p><p>在使用RESTCONF下发流表时，需要学习的是请求消息的BODY的结构。实例如下：</p><blockquote></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;     &lt;table_id&gt;0&lt;/table_id&gt;    &lt;id&gt;100&lt;/id&gt;     &lt;strict&gt;false&lt;/strict&gt;   &lt;priority&gt;1&lt;/priority&gt;     &lt;instructions&gt;         &lt;instruction&gt;             &lt;order&gt;0&lt;/order&gt;             &lt;apply-actions&gt;                 &lt;action&gt;                     &lt;order&gt;0&lt;/order&gt;                     &lt;output-action&gt;&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;                    &lt;/output-action&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;        &lt;/instruction&gt;    &lt;/instructions&gt;    &lt;match&gt;    &lt;/match&gt;&lt;/flow&gt;</code></pre><p>BODY中定义了流表名称（flowname）、flow所在的table（table_id）、flow的id（id）、是否严格匹配（strict）、优先级和匹配字段（match fields）、优先级（priority）、指令（instructions）、超时（timeouts）、cookie等值。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc7011f.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机查看网络连通性。由于OpenDaylight组件过于庞大，所以启动比较慢，容易导致控制器与交换机连接不成功的现象，间接导致主机无法获取IP。所以使用OpenDaylight控制器时，需要先检查网络连通性，查看交换机与控制器连接情况。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p><p>步骤6 登录交换机，执行如下命令连接控制器。</p><blockquote></blockquote><pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640</code></pre><p>原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。</p><h1 id="删除ODL自动下发的流表"><a href="#删除ODL自动下发的流表" class="headerlink" title="删除ODL自动下发的流表"></a>删除ODL自动下发的流表</h1><p>在实验过程中需要验证两个不能通信的主机，通过REST北向接口下发流表，使得两个主机能够通信，所以需要删除原先的默认通信流表。  </p><p>步骤1 登录交换机，执行如下命令删除流表，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl del-flows -O OpenFlow13 br-sw</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc315a1.png" alt="1.png"><br>步骤2 执行ovs-ofctl dump-flows -O OpenFlow13 br-sw查看是否删除成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf7eee833f.png" alt="2.png"><br>步骤3 登录其中的一个主机，查看主机间网络网络连通情况，此时主机间无法进行通信，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf80fce130.png" alt="3.png"></p><h1 id="下发通信流表"><a href="#下发通信流表" class="headerlink" title="下发通信流表"></a>下发通信流表</h1><p>步骤1 登录控制器，打开浏览器，输入URL：<strong>http://[controller_ip]:8181/index.html</strong>，输入有户名：admin，密码：admin，单击登录。登录后，单击Nodes菜单，获取交换机node id，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf86025757.png" alt="4.png"><br>步骤2 单击Applications Menu/Development/Postman打开postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa287541e.png" alt="5.png"><br>步骤3 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/100。  </p><p>[controller-ip]为当前控制器的数据层的ip，[node-id]即步骤1中获得的node id请求类型选择PUT。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。选择BODY的类型raw -&gt;XML（application/xml），如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa5754286.png" alt="6.png"><br>步骤4 输入Body内容如下：</p><blockquote></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;    &lt;table_id&gt;0&lt;/table_id&gt;    &lt;id&gt;100&lt;/id&gt;    &lt;installHw&gt;false&lt;/installHw&gt;    &lt;strict&gt;false&lt;/strict&gt;  &lt;priority&gt;1&lt;/priority&gt;    &lt;instructions&gt;       &lt;instruction&gt;           &lt;order&gt;0&lt;/order&gt;           &lt;apply-actions&gt;               &lt;action&gt;                   &lt;order&gt;0&lt;/order&gt;                   &lt;output-action&gt;&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;                   &lt;/output-action&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;            &lt;/instruction&gt;    &lt;/instructions&gt;    &lt;match&gt;    &lt;/match&gt;&lt;/flow&gt;注意：严格区分大小写</code></pre><p>步骤5 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb40e9192.png" alt="7.png"><br>步骤6 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/。[controller-ip] 为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id请求类型选择GET。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb65ceea0.png" alt="8.png"><br>步骤7 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb85a72bb.png" alt="9.png"><br>可以看到，此流表为之前通过REST北向接口下发的流表。  </p><p>步骤8 登录其中的一个主机，查看主机间网络网络情况，此时主机间能够进行通信。</p><h1 id="使用Postman删除流表"><a href="#使用Postman删除流表" class="headerlink" title="使用Postman删除流表"></a>使用Postman删除流表</h1><p>步骤1 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/[flow-id]。  </p><p>[controller-ip]为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id，[flow-id]为之前下发流表的id，可以到【四、下发通信流表】的BODY中查看。请求类型选择DELETE.访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。点击Send，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf41812.png" alt="10.png"><br>步骤2登录交换机，切换至root用户。执行命令ovs-ofctl dump-flows -O OpenFlow13 br-sw，可验证流表已删除，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf2cb35.png" alt="11.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;所谓流表，其实可被视作是SDN对网络设备的数据转发功能的一种抽象。在传统网络设备中，交换机和路由器的数据转发需要依赖设备中保
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>3.Open vSwitch流表管理</title>
    <link href="https://cyneliu.github.io/2018/09/14/3-Open-vSwitch%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/14/3-Open-vSwitch流表管理/</id>
    <published>2018-09-14T13:10:47.000Z</published>
    <updated>2018-10-16T14:11:42.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议去连接Open vSwitch，创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。  </p><p>在OpenFlow的白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或者多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。  </p><p>当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。<br>在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或者空格分开。一些常用的字段列举如下：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd40468.png" alt="1.png"><br>ovs-ofctl关于流表管理的常用命令：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd3a959.png" alt="2.png"><br>对于add−flow，add−flows和mod−flows这三个命令，还需要指定要执行的动作：actions=[target][,target…]，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br>常见的操作有：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd4cb85.png" alt="3.png"></p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9bb4dd4d9be.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，执行以下命令，查看镜像中原有的网桥，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbf7b25c05.png" alt="4.png"><br>步骤5 执行以下命令，删除当前网桥，并进行确认，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl del-br br-swovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbfb869e58.png" alt="5.png"></p><h1 id="流表管理"><a href="#流表管理" class="headerlink" title="流表管理"></a>流表管理</h1><p>步骤1 执行以下命令，添加网桥，并查看虚拟交换机的基本信息，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl add-br br0ovs-ofctl show br0</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbffd27c45.png" alt="6.png"><br>由上图可知，可以查看到交换机dpid、流表数量、性能参数、动作参数、MAC地址等信息。  </p><p>步骤2 执行以下命令，查看虚拟交换机上各端口的状态，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br0</code></pre><p>由上图可知，输出的结果中包含了各端口上收到的数据包数，字节数，丢包数，错误数据包数等。  </p><p>步骤3 执行以下命令，添加一条流表项，设置流表项生命周期为1000s，优先级为17，入端口为3，动作是output:2。</p><blockquote></blockquote><pre><code>ovs-ofctl add-flow br0 idle_timeout=1000,priority=17,in_port=3,actions=output:2说明：这条流表项的作用是将端口3接收到的数据包从端口2输出。</code></pre><p>步骤4 执行以下命令，查看交换机上所有流表信息，如下图所示。</p><blockquote><pre><code>ovs-ofctl dump-flows br0</code></pre></blockquote><p>步骤5 执行以下命令，删除入端口为3的的流表项，删除后，再次查看流表信息，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl del-flows br0 in_port=3ovs-ofctl dump-flows br0</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bc08844d29.png" alt="7.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置Open
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>秒懂MBR和GPT分区表</title>
    <link href="https://cyneliu.github.io/2018/09/13/%E7%A7%92%E6%87%82MBR%E5%92%8CGPT%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>https://cyneliu.github.io/2018/09/13/秒懂MBR和GPT分区表/</id>
    <published>2018-09-13T11:58:17.000Z</published>
    <updated>2018-09-13T12:39:54.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的Apple分区图。<br>MBR的全称是Master Boot Record（主引导记录），MBR早在1983年IBM PC DOS 2.0中就已经提出。之所以叫“主引导记录”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。主引导扇区是硬盘的第一扇区。它由三个部分组成，主引导记录MBR、硬盘分区表DPT和硬盘有效标志。在总共512字节的主引导扇区里MBR占446个字节，偏移地址（0000H–0088H），它负责从活动分区中装载，并运行系统引导程序；第二部分是Partition table区（DPT分区表），占64个字节；第三部分是Magic number，占2个字节。 </p><h1 id="MBR分区表系统"><a href="#MBR分区表系统" class="headerlink" title="MBR分区表系统"></a>MBR分区表系统</h1><p>所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。  </p><p>分区表偏移地址为01BEH–01FDH，每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4，分别对应MBR的四个主分区。Magic number也就是结束标志字，偏移地址01FE–01FF的2个字节，固定为55AA，如果该标志错误系统就不能启动。   </p><p>MBR最大支持2.2TB磁盘，它无法处理大于2.2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区。 </p><h1 id="GPT分区表系统"><a href="#GPT分区表系统" class="headerlink" title="GPT分区表系统"></a>GPT分区表系统</h1><p>GPT的全称是Globally Unique Identifier Partition Table，意即GUID分区表，它的推出是和UEFI BIOS相辅相成的，鉴于MBR的磁盘容量和分区数量已经不能满足硬件发展的需求，GPT首要的任务就是突破了2.2T分区的限制，最大支持18EB的分区。 </p><p>而在分区数量上，GPT会为每一个分区分配一个全局唯一的标识符，理论上GPT支持无限个磁盘分区，不过在Windows系统上由于系统的限制，最多只能支持128个磁盘分区，基本可以满足所有用户的存储需求。在每一个分区上，这个标识符是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符。   </p><p>而在安全性方面，GPT分区表也进行了全方位改进。在早期的MBR磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT还为这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏，GPT会发觉这些破坏，并从磁盘上的其他地方进行恢复。  </p><p>小结：所以对于新平台用户（Intel 6系以后/AMD 900系列以后和A系列）来说，都强烈推荐使用GPT分区表格式，目前包括Windows Vista、7、8、8.1、10已经都支持读取和使用GPT分区表。而对于使用Windows 8、8.1、10的用户，换用GPT后开机启动速度也可以进一步得到显著提升。 </p><h1 id="BIOS-MBR"><a href="#BIOS-MBR" class="headerlink" title="BIOS+MBR"></a>BIOS+MBR</h1><p>这种方式是目前最常见的装机方式，所有的系统都会支持，兼容较老硬件，目前新电脑大多出厂时就使用UEFI方式启动。</p><h1 id="UEFI-GPT"><a href="#UEFI-GPT" class="headerlink" title="UEFI+GPT"></a>UEFI+GPT</h1><p>GPT与UEFI是相辅相成的，如果分区表系统是GPT，那么必须使用UEFI，传统的BIOS方式无法启动，这也就是为什么现在很多人在给新机器重装系统时无法启动的原因。  </p><p>UEFI+GPT还有一个优点就是开机速度更快，原因是开机时跳过外设检测，并且可以实现启动时原生分辨率，搭载固态硬盘开机时间很短，十秒左右。  </p><p>UEFI可用鼠标操作图形界面，不再是枯燥的蓝底白字的英文。由Intel提出，用于取代BIOS。UEFI的优越特性：可操作性、安全性、兼容性、可扩展性。  </p><p>主板为了兼容MBR分区表，一般会提供Legacy BIOS和UEFI BIOS启动模式选项，可以把UEFI设置成Legacy模式（传统模式）、打开CSM兼容模块，让其支持传统MBR启动，此时效果同BIOS+MBR。如果要使用UEFI模式安装Windows，就必须开启UEFI启动模式。</p><h1 id="系统支持性"><a href="#系统支持性" class="headerlink" title="系统支持性"></a>系统支持性</h1><p>目前64bit Windows Vista、7、8、8.1、10都已经支持GPT分区表，而Windows 8、8.1、10都已经原生支持UEFI，安装这些系统的时候：只要硬盘设置为GPT分区表，主板设置为UEFI启动后，就可以直接开始安装操作系统了。 而对于Windows Vista、7系统，就需要手动添加UEFI支持：我们可以找一份Windows 8或者10安装镜像，从安装文件中提取Bootmgfw.efi文件，重命名为BOOTX64.EFI，拷贝到win7安装文件的\EFI\Boot\下，如果没有BOOT文件夹新建一个即可。 </p><h1 id="修改为传统方式启动"><a href="#修改为传统方式启动" class="headerlink" title="修改为传统方式启动"></a>修改为传统方式启动</h1><p>如果实在是搞不明白或者像之前的我一样不太懂的话，可以使用分区助手将GPT改为MBR，如图：<br><img src="https://i.loli.net/2018/09/13/5b9a589d17e85.jpg" alt="1.jpg"><br>选中磁盘，在左侧菜单中选择“转换到MBR磁盘”：<br><img src="https://i.loli.net/2018/09/13/5b9a589cddfb3.jpg" alt="2.jpg"><br>转换成功：<br><img src="https://i.loli.net/2018/09/13/5b9a589d066d8.jpg" alt="3.jpg"><br>转换完成进行分区后，不要忘了把装系统的分区转换成活动分区：<br><img src="https://i.loli.net/2018/09/13/5b9a589d099b4.jpg" alt="4.jpg"><br>最后还是建议大家花几分钟时间了解一下UEFI的方式，这必定是未来的一个趋势，并不推荐采用上图将GPT修改为MBR的方式重装系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分区表&quot;&gt;&lt;a href=&quot;#分区表&quot; class=&quot;headerlink&quot; title=&quot;分区表&quot;&gt;&lt;/a&gt;分区表&lt;/h1&gt;&lt;p&gt;全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的
      
    
    </summary>
    
      <category term="装机" scheme="https://cyneliu.github.io/categories/%E8%A3%85%E6%9C%BA/"/>
    
    
      <category term="装机" scheme="https://cyneliu.github.io/tags/%E8%A3%85%E6%9C%BA/"/>
    
      <category term="硬件" scheme="https://cyneliu.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2.OVSDB的网桥和端口管理</title>
    <link href="https://cyneliu.github.io/2018/09/13/2-OVSDB%E7%9A%84%E7%BD%91%E6%A1%A5%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/13/2-OVSDB的网桥和端口管理/</id>
    <published>2018-09-13T07:21:32.000Z</published>
    <updated>2018-10-16T14:11:22.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFlow和OVSDB两种南向协议方式与Open vSwitch交换机进行交互，其中通过OpenFlow来引导数据包流的转发，通过OVSDB可以进行端口和隧道的增加、更新以及删除，这些隧道和端口提供流转发的管道。因此，OVSDB在Open vSwitch作为一个重要的事实标准，OpenDaylight系统如何高效地支持OVSDB也变得非常重要。OpenDaylight的OVSDB子项目实现了OVSDB管理协议，该协议允许控制器进行虚拟交换机的南向配置。OVSDB协议包含一个OVSDB库和各种插件用法，该协议使用JSON/RPC调用的方式来操作内置OVSDB的物理或虚拟交换机。<br>OVSDB子项目主要包含Northbound模块、plugin模块和OVSDB Library模块，其中北向Northbound模块可供外部APP调用，南向OVSDB Library通过OVSDB协议与外部通信，进行OVSDB的管理，具体系统架构如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a10f6d7c34.png" alt="1.png"><br>Library模块主要包含message、notation、impl、jsonrpc和schema等程序包,其中jsonrpc主要提供兼容rpc1.0的解码器，能够从TCP流解码JSON消息；notation主要包含OVSDB MAP、ResultSet等定义以及Json串行化；schema提供OVSDB数据库模式的表示。</p><p>Plugin模块主要包含api、impl、internal和error等程序包，其中api程序包主要提供OVSDB的连接、增删改查等服务，impl包中的类是其接口的实现。  </p><p>Northbound模块主要包含五大类,分别是DatabaseResource、NodeResource、OvsdbNorthboundV2、OvsdbNorthboundV3、RowResource、TableResource。以类OvsdbNorthboundV2为例进行说明，该类提供OVSDB北向 REST API接口，用于创建、读取、更新和删除任一OVSDB表中的记录。创建OVSDB Row时，body请求体中的JSON格式与OVSDB JSON-PRC消息相同。northbound及其功能描述如下表所示。<br><img src="https://i.loli.net/2018/09/13/5b9a123b86027.png" alt="2.png"><br>用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。而Postman不仅可以调试简单的css、html、脚本等简单的网页基本信息，还可以发送GET、POST、PUT、DENLETE等几乎所有类型的HTTP请求。Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9b47e2af14d.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录OpenDaylight控制器，确保服务已经启动成功，由于OpenDaylight组件过于庞大，所以启动比较慢，需等待一段时间，使用命令：</p><blockquote></blockquote><pre><code>netstat -an|grep 6633 #netstat -an:查看端口对应的应用</code></pre><p>查看端口是否处于监听状态：<br><img src="https://i.loli.net/2018/09/14/5b9b46db45a61.png" alt="3.png"><br>步骤2 在保证控制6633端口处于监听状态后，登录交换机，查看交换机与控制器连接情况。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9b4746ca6a9.png" alt="4.png"><br>上图中controller下方显示“is_connected:true”则表明连接成功。<br>步骤3 登录控制器，查看控制器IP，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4798e189e.png" alt="5.png"><br>步骤4 登录交换机，连接控制器。原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。执行如下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640</code></pre><p>连接成功后在manager下面会有“is_conneted:true”：<br><img src="https://i.loli.net/2018/09/14/5b9b47e2a28df.png" alt="6.png"></p><h1 id="创建网桥"><a href="#创建网桥" class="headerlink" title="创建网桥"></a>创建网桥</h1><p>步骤1 登录控制器，单击Applications Menu—&gt;Development—&gt;Postman打开Postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4e42b73f7.png" alt="7.png"><br>步骤2 在创建网桥前，需要先获取交换机节点信息，输入URL <strong>http://[controller ip]:8282/ovsdb/nb/v3/node</strong>。  </p><p>请求类型选择GET，单击Send按钮发送GET请求。访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择Basic Auth。输入用户名和密码，用户名和密码都是admin。Body中返回的就是交换机节点信息，此处获取到的节点信息在后面会用到，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4ebbb7028.png" alt="8.png"><br>步骤3 发送POST请求创建网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”</a>  </p><p>就是前面获取到的交换机节点信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba28a8e540.png" alt="9.png"><br>单击Headers，输入用户名和密码生成HTTP认证头部，POST请求还需要添加头部指明Body格式，如图所示，手动输入Content-Type且值为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba3126bc5f.png" alt="10.png"><br>步骤4 单击Body，Body格式选择raw—&gt;JSON(application/json)。Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。  </p><p>Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。单击Send按钮发送请求。</p><blockquote></blockquote><pre><code>{   &quot;row&quot;: {    &quot;Bridge&quot;: {      &quot;name&quot;: &quot;br0&quot;,        &quot;datapath_type&quot;: &quot;OpenFlow13&quot;        }    }}</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba36f496f1.png" alt="11.png"><br>步骤5 登录交换机，确认网桥创建成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba3d7290b1.png" alt="12.png"></p><h1 id="获取网桥uuid"><a href="#获取网桥uuid" class="headerlink" title="获取网桥uuid"></a>获取网桥uuid</h1><p>步骤1 URL保持不变，依旧是<a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows</a> ，将请求类型改为GET。输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba676a461c.png" alt="13.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并返回网桥信息，下图中两个uuid分别是br0和br-sw的。单击uuid所在行左侧的数字可以展开/收起网桥的详细信息，方便查看，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6a5aefc1.png" alt="14.png"></p><h1 id="创建端口"><a href="#创建端口" class="headerlink" title="创建端口"></a>创建端口</h1><p>步骤1 发送POST请求创建端口，输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。</a><br>单击Basic Auth，输入用户名和密码生成HTTP认证头部，并且添加Content-Type为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6e473f28.png" alt="15.png"><br>步骤2 将请求类型改为POST，输入Body内容如下所示，其中parent_uuid是网桥的uuid，这里所用的是br0的uuid，那么端口就会添加到br0网桥上。</p><blockquote></blockquote><pre><code>{   &quot;parent_uuid&quot;: &quot;2dd82e5e-922d-43c8-80d9-7917161acfd2&quot;,    &quot;row&quot;: {      &quot;Port&quot;: {        &quot;name&quot;: &quot;port0&quot;          }    }}</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba72ac6722.png" alt="16.png"><br>单击Send按钮发送请求，STATUS显示请求发送成功，端口已经创建，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba762e1b34.png" alt="17.png"><br>步骤3 登录交换机，确认交换机端口是否创建成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba79b19c6c.png" alt="18.png"></p><h1 id="获取端口uuid"><a href="#获取端口uuid" class="headerlink" title="获取端口uuid"></a>获取端口uuid</h1><p>步骤1 发送GET请求获取端口的uuid。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows</a> 。在Basic Auth页面输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7d5c4665.png" alt="19.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并且展示出获取到的端口信息。因为获取的是所有网桥的端口所以比较多，如下图所示，标注出来的是port0的uuid。获取到的信息完全展开比较多，可以直接在页面中搜索端口名称“port0”，然后往上翻找该端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7feaebe3.png" alt="20.png"></p><h1 id="删除端口"><a href="#删除端口" class="headerlink" title="删除端口"></a>删除端口</h1><p>步骤1 发送DELETE请求删除端口。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8</a> ”就是port0端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8431f4b2.png" alt="21.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8655ebe0.png" alt="22.png"><br>步骤3 登录交换机，确认port0端口删除成功。</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba89fe7601.png" alt="23.png"></p><h1 id="删除网桥"><a href="#删除网桥" class="headerlink" title="删除网桥"></a>删除网桥</h1><p>步骤1 发送DELETE请求删除网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”</a> 就是br0网桥的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8ddef7ab.png" alt="24.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba9024cca5.png" alt="25.png"><br>步骤3 登录交换机，确认网桥br0删除成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba934ab15e.png" alt="26.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFl
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>1.OpenFlow建立连接交互流程</title>
    <link href="https://cyneliu.github.io/2018/09/13/1-OpenFlow%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B/"/>
    <id>https://cyneliu.github.io/2018/09/13/1-OpenFlow建立连接交互流程/</id>
    <published>2018-09-13T05:30:58.000Z</published>
    <updated>2018-10-16T14:11:20.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenFlow协议简介"><a href="#OpenFlow协议简介" class="headerlink" title="OpenFlow协议简介"></a>OpenFlow协议简介</h1><p>2006年，斯坦福大学Clean Slate计划资助的Ethane项目开始部署，致力于企业网架构的创新，OpenFlow协议的雏形就诞生于这个项目。2008年，Nick McKeown教授的一篇重要论文“OpenFlow：Enabling Innovation in Campus Networks”使得OpenFlow正式进入人们的视野，继而成为了标准化组织ONF（Open Network Foundation，开放网络基金会）主推的南向接口协议。经过多年的发展，OpenFlow现已成为SDN的主流南向接口协议之一。目前，OpenFlow协议还在不断地演进中，本实验采用OpenFlow v1.3协议，并对控制器与OpenFlow交换机之间的交互过程进行深入分析。<br>OpenFlow主要有3种类型的消息，分别是Controller-to-Switch、Asynchronous和Symmetric，其中每个类型又包含多个子类型。Controller-to-Switch消息由控制器发起，用于管理、查看交换机的状态。Asynchronous消息由交换机发起，向控制器汇报交换机的事件和改变。Symmetric消息由控制器或交换机任一方发起，无需请求直接发起消息。详细信息如下表所示：<br><img src="https://i.loli.net/2018/09/13/5b99fc6a1c7b0.png" alt="1.png"></p><h1 id="OpenFlow连接建立交互流程"><a href="#OpenFlow连接建立交互流程" class="headerlink" title="OpenFlow连接建立交互流程"></a>OpenFlow连接建立交互流程</h1><p><img src="https://i.loli.net/2018/09/13/5b99fd98251f8.png" alt="2.png"><br>在OpenFlow1.3协议的情况下，控制器与OpenFlow交换机的消息完整交互流程如下：<br>1、 控制器与OpenFlow交换机通过TCP“三次握手”，建立有效的连接。其中，控制器一端的端口号为6633。<br>2、 控制器与OpenFlow交换机之间相互发送Hello消息，用于协商双方的OpenFlow版本号。在双方支持的最高版本号不一致的情况下，协商的结果将以较低的OpenFlow版本为准。如果双方协商不一致，还会产生Error消息。<br>3、 控制器向OpenFlow交换机发送Features Request消息，请求OpenFlow交换机上传自己的详细参数。OpenFlow交换机收到请求后，向控制器发送Features Reply消息，详细汇报自身参数，包括支持的buffer数目、流表数以及Actions等。<br>4、 控制器通过Set Config消息下发配置参数，然后通过Get config Request消息请求OpenFlow交换机上传修改后的配置信息。OpenFlow交换机通过Get config Reply消息向控制器发送当前的配置信息。<br>5、 控制器与OpenFlow交换机之间发送Packet_out、Packet_in消息，通过Packet_out中内置的LLDP包，进行网络拓扑的探测。<br>6、 控制器与OpenFlow交换机之间通过发送Multipart Request、Mutipart Reply消息，控制器能获取OpenFlow交换机的状态信息，包括流的信息、端口信息等。<br>7、 控制器与OpenFlow交换机之间通过发送Echo Request、Echo Reply消息，保证二者之间存在有效连接，避免失联。  </p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/13/5b9a0b09e2b9b.png" alt="3.png"></p><h1 id="捕获数据包"><a href="#捕获数据包" class="headerlink" title="捕获数据包"></a>捕获数据包</h1><p>步骤1 登录Floodlight控制器，启动抓包工具Wireshark，捕获控制器与交换机建立连接过程中的数据包，通过分析这些数据包了解控制器与交换机基于OpenFlow协议进行交互的流程。执行以下命令：</p><blockquote></blockquote><pre><code>sudo wireshark</code></pre><p>步骤2 双击eth0网卡，查看eth0网卡上数据包收发情况，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ba6a9fb7.png" alt="4.png"><br>步骤3 登录Mininet虚拟机，启动Mininet。通过“—controller”参数设置Mininet连接远程控制器，并指定控制器的IP和端口号。</p><blockquote></blockquote><pre><code>sudo mn --controller=remote,ip=30.0.1.3,port=6633 --switch=ovsk,protocols=OpenFlow13</code></pre><p><img src="https://i.loli.net/2018/09/13/5b9a0bf62d0be.png" alt="5.png"><br>步骤4 登录Floodlight控制器，停止Wireshark，观察数据包列表，可以看出控制器与交换机的基本交互流程。<br><img src="https://i.loli.net/2018/09/13/5b9a0c1ddbc4e.png" alt="6.png"></p><h1 id="OpenFlow1-3交互流程分析"><a href="#OpenFlow1-3交互流程分析" class="headerlink" title="OpenFlow1.3交互流程分析"></a>OpenFlow1.3交互流程分析</h1><p>步骤1 交换机连接控制器的6633端口，经过3次握手后双方建立TCP连接。查看捕获到的数据包，分析交换机与控制器建立TCP连接的流程。分析TCP连接建立过程，需要先了解TCP的状态位，主要包括SYN、FIN、ACK、PSH、RST和URG。SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。可以看出交换机与控制器经历一次连接重置后，成功完成三次握手，建立TCP连接，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c63cdbf7.png" alt="7.png"><br>步骤2 当控制器与交换机建立TCP连接后，由其中某一方发起Hello消息，双方协调协OpenFlow议版本号。控制器和交换机都会向对方发送一条Hello消息，消息中附上自己支持的OpenFlow的最高版本。接收到对方Hello消息后，判断自己能否支持对方发送的版本，能支持则版本协商成功，不能支持则回复一条OFPT_ERROR消息。查看Hello消息详情，本实验中由于交换机和控制器都能支持OpenFlow1.3版本，所以版本协商为1.3，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c8900db0.png" alt="8.png"><br>步骤3 OpenFlow版本协商完成后，控制器发送一条features_request消息获取交换机的特性信息，包括交换机的ID（DPID）、缓冲区数量、端口及端口属性等等。相应的，交换机回复features_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0cb6bf243.png" alt="9.png"><br>查看数据包详情，ofpt_feature_request消息只有包头，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ce6d0540.png" alt="10.png"><br>ofpt_feature_reply数据包详情如下，交换机的DPID是数据通道独一无二的标识符，低48位是一个MAC地址，高16位是自定义的。本实验中交换机缓冲区数量（n_buffers）为256，交换机支持的流表数量（n_tables）为254，交换机所支持的功能，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d1008f0a.png" alt="11.png"><br>步骤4 OpenFlow1.0协议中feature_reply消息还包含交换机端口信息，OpenFlow 1.3协议将‘stats’框架更名为‘multipart’框架，并且将端口描述移植到multipart消息中。其中OPPT_PORT_DESC类型的multipart消息就是用于获取交换机端口信息的。<br><img src="https://i.loli.net/2018/09/13/5b9a0d34705f8.png" alt="12.png"><br>查看OPPT_PORT_DESC类型multipart_reply消息，消息中列出了交换机的端口以及每个端口的详细信息，包括端口名称和mac地址等，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d5f30b72.png" alt="13.png"><br>步骤5 OFPMP_DESC类型的multipart_reply消息包含了交换机的其他信息，包括交换机厂商名称、交换机名称以及交换机版本等。本实验中使用的是Mininet仿真软件中自带的开源交换机Open vSwitch(2.0.2)，而Open vSwitch是由Nicira Networks主导开发的，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d8d31133.png" alt="14.png"><br>步骤6 在连接过程中，控制器不断的发送echo_request消息给交换机，确认交换机与控制器之间的连接状态。相应的，交换机会回复echo_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0db731025.png" alt="15.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenFlow协议简介&quot;&gt;&lt;a href=&quot;#OpenFlow协议简介&quot; class=&quot;headerlink&quot; title=&quot;OpenFlow协议简介&quot;&gt;&lt;/a&gt;OpenFlow协议简介&lt;/h1&gt;&lt;p&gt;2006年，斯坦福大学Clean Slate计划资助的Eth
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
