<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyne&#39;s Blog</title>
  
  <subtitle>越努力，越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cyneliu.github.io/"/>
  <updated>2018-09-16T13:32:12.111Z</updated>
  <id>https://cyneliu.github.io/</id>
  
  <author>
    <name>Cyne Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>6.使用OpenDaylight界面下发流表</title>
    <link href="https://cyneliu.github.io/2018/09/16/6-%E4%BD%BF%E7%94%A8OpenDaylight%E7%95%8C%E9%9D%A2%E4%B8%8B%E5%8F%91%E6%B5%81%E8%A1%A8/"/>
    <id>https://cyneliu.github.io/2018/09/16/6-使用OpenDaylight界面下发流表/</id>
    <published>2018-09-16T12:11:24.000Z</published>
    <updated>2018-09-16T13:32:12.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>YANG UI是OpenDaylight中一款基于DLUX的应用，旨在简化、激励应用的开发与测试。YANG UI通过动态封装、调用YANG模型和相关REST APIs，生成并展示一个简单的UI界面。开发人员可以通过API请求获取交换机信息，并且以JSON格式展示。YANG UI主要面向上层应用开发，为应用开发人员提供了很多相关工具，有效的节约了开发人员的时间。  </p><p>OpenFlow1.0协议处理数据包的流程相对简单，因为1.0版本只支持单流表。交换机接收到数据包后解析数据包，数据包解析后就开始匹配，从table 0 开始匹配，如果匹配成功则对该数据包执行相应的动作，更新相应的计数器。如果没有找到匹配项则将数据包交给控制器。  </p><p>OpenFlow1.3协议支持多流表匹配，即一个交换机只会有多个流表，因此数据包处理过程相对复杂。首先解析进入设备的报文，然后从table 0开始匹配，按照优先级高低依次匹配该流表中的流表项，一个报文在一个流表中只会匹配上一条流表项。通常根据报文的类型，报文头的字段例如源MAC地址、目的MAC地址、源IP地址、目的IP地址等进行匹配，大部分匹配还支持掩码进行更精确、灵活的匹配。也可以通过报文的入端口或元数据信息来进行报文的匹配，一个流表项中可以同时存在多个匹配项，一个报文需要同时匹配流表项中所有匹配项才能匹配该流表项。报文匹配按照现有的报文字段进行，比如前一个流表通过apply actions改变了该报文的某个字段，则下一个表项按修改后的字段进行匹配。如果匹配成功，则按照指令集里的动作更新动作集，或更新报文/匹配集字段，或更新元数据和计数器。根据指令是否继续前往下一个流表，不继续则终止匹配流程执行动作集，如果指令要求继续前往下一个流表则继续匹配，下一个流表的ID需要比当前流表ID大。当报文匹配失败了，如果存在无匹配流表项（table miss）就按照该表项执行指令，一般是将报文转发给控制器、丢弃或转发给其他流表。如果没有table miss表项则默认丢弃该报文。  </p><p>在Open vSwitch中，流表项作为ovs-ofctl的参数，采用“字段=值”的格式。如果有多个字段，可以用逗号分开，一些常见字段如下：<br><img src="https://i.loli.net/2018/09/16/5b9e4929f0d63.png" alt="1.png"></p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/16/5b9e494803043.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>登录交换机，检查网络连通性。当显示“is_connected：ture”时，表示交换机与控制器连接成功，可以正常进行实验。若不显示“is_connected：ture”时，表示交换机与控制器连接不成功，执行:</p><blockquote></blockquote><pre><code>ovs-vsctl del-controller br-swovs-vsctl set-controller br-sw tcp:30.0.1.3:6633 </code></pre><p>命令手动重连，稍等一会后，重新查看连接状态。</p><h1 id="基于OpenFlow1-0协议下发流表"><a href="#基于OpenFlow1-0协议下发流表" class="headerlink" title="基于OpenFlow1.0协议下发流表"></a>基于OpenFlow1.0协议下发流表</h1><p>步骤1 切换到交换机，执行以下命令设置OpenFlow协议版本为1.0。  </p><blockquote></blockquote><pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow10</code></pre><p>步骤2 选择控制器，单击浏览器图标，打开浏览器。  </p><p>步骤3 访问OpenDaylight Web页面，url是<a href="http://127.0.0.1:8080/index.html" target="_blank" rel="noopener">http://127.0.0.1:8080/index.html</a> ，用户名和密码是admin/admin，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a2625fb7.png" alt="2.png"><br>步骤4 单击左侧的“Nodes”查看节点信息。其中尤其需要关注Node Id，下发流表的时候会用到Node Id，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a653f1bb.png" alt="3.png"><br>步骤5 单击上图中的“Node Connectors”列的数据即“9”，可以查看具体节点连接信息，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4ac29c305.png" alt="4.png"><br>步骤6 选择左侧的“Yang UI”，单击“Expand all”展开所有目录，查看各种模块，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4af0e3b80.png" alt="5.png"><br>步骤7 展开“opendaylight-inventory rev.2013-08-19”，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b115e5c9.png" alt="6.png"><br>步骤8 补全node id、table id和flow id的值。  </p><p>其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.0协议只支持单流表，所以这里的table id设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b3798ac7.png" alt="7.png"><br>步骤9 单击flow list后面的“+”，展开流表相关的参数。填写第一个框id，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b59027ad.png" alt="8.png"><br>步骤10 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为“0x0800”(说明：由于使用IP地址进行匹配，所以需要设置以太网协议类型。),如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b789668c.png" alt="9.png"><br>步骤11 填写匹配参数，在“layer-3-match”后面的下拉框中选择“ipv4-match”，使用IP匹配。  </p><p>步骤12 展开“layer-3-match”，填写源IP地址和目的IP地址，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bc1b5579.png" alt="10.png"><br>其中源地址填写主机1的IP地址，目的地址填写主机2的IP地址。  </p><p>步骤13 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bec99e16.png" alt="11.png"><br>步骤14 展开“apply-actions”，单击“action list”后面的“+”，在action后面的下拉框中选择“drop-action-case”，action order和instruction order都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c0f7a101.png" alt="12.png"><br>步骤15 设置“priority”为27，“idle-timeout”为0，“hard-timeout”为0，“cookie”为100000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c2f54bc4.png" alt="13.png"><br>说明：priority设置的比已有流表项的高，而idle-timeout和hardtimeout都设置为0则代表该流表项永远不会过期，除非被删除。  </p><p>步骤16 向右滚动Actions栏，在路径后面有动作类型GET、PUT、POST、DELETE，下发流表则选择PUT动作，然后单击“Send”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c5b47302.png" alt="14.png"><br>步骤17 如果下发成功会出现下面的提示，如果下发不成功则会弹出相应的错误信息。<br><img src="https://i.loli.net/2018/09/16/5b9e4c9033d8d.png" alt="15.png"><br>步骤18 切换到交换机，执行如下命令查看流表，确保刚刚下发的流表已经下发到交换机。如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cc42a811.png" alt="16.png"><br>步骤19 登录主机1，执行如下命令向主机2、主机3发送数据包，测试主机间的连通性。</p><blockquote></blockquote><pre><code># scapy&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cfe4003b.png" alt="17.png"><br>由上图可知，主机1与主机2之间不通，主机1与主机3通，新下发的流表项生效。  </p><p>说明：如果主机之间通则能够收到answer，如果主机之间不通那么就无法收到answer，当主机之间不通时scapy就会一直发送数据包，如果需要停止可以使用Ctrl+c。  </p><p>步骤20 切换到交换机，执行以下命令删除刚刚下发的流表项，并查看流表确保成功删除。  </p><blockquote></blockquote><pre><code>ovs-ofctl del-flows br-sw dl_type=0x0800,nw_src=10.0.0.3,nw_dst=10.0.0.4ovs-ofctl dump-flows br-sw</code></pre><p>步骤21 切换到主机1执行如下命令，测试主机1和主机2是否连通。</p><blockquote></blockquote><pre><code>result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4d486b69c.png" alt="18.png"><br>由上图可知，主机1与主机2之间就通了。</p><h1 id="基于OpenFlow1-3协议下发流表"><a href="#基于OpenFlow1-3协议下发流表" class="headerlink" title="基于OpenFlow1.3协议下发流表"></a>基于OpenFlow1.3协议下发流表</h1><p>步骤1 登录交换机，设置OpenFlow协议版本为1.3。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow13</code></pre><p>步骤2 与OpenFlow1.0下发流表的过程解基本一致。展开opendaylight-inventory rev.2013-08-19，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”。  </p><p>步骤3 补全Actions栏中的路径，其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.3协议支持多级流表，所以这里的table id设置为2。  </p><p>步骤4 单击flow list后面的“+”，流表相关的参数就会展开。设置id为1，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e592464e82.png" alt="19.png"><br>步骤5 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e594c3f115.png" alt="20.png"><br>步骤6 在“layer-3-match”后面的下拉框中选择“ipv4-match”。  </p><p>步骤7 展开“layer-3-match”，填写源IP地址和目的IP地址。以主机1的IP为源IP，以主机3的IP为目的IP，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5979b8763.png" alt="21.png"><br>步骤8 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e599fdaa67.png" alt="22.png"><br>步骤9 展开“apply-actions”，单击“action list”后面的“+”，在“action”后面的下拉框中选择“drop-action-case”，“action order”和“instruction order”都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59c4a3dca.png" alt="23.png"><br>步骤10 设置“priority”为25，“idle-timeout”为0，“hard-timeout”为0，“cookie”为10000000，“table_id”为2，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59eb63de3.png" alt="24.png"><br>步骤11 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。PUT成功就会弹出“Request sent successfully”，否则弹出错误信息。  </p><p>步骤12 切换到主机1，执行如下命令，向主机3发送数据包，测试主机1和主机3的连通性。</p><blockquote></blockquote><pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5a28ba934.png" alt="25.png"><br>由上图可知，主机1与主机3之间是连通的，新下发的流表没有发挥作用。原因是数据包在table 0中能够匹配到相应流表就不会被转发到table2，想要table2的流表项发挥作用就需要向table0增加一条流表，将源IP为10.0.0.3，目的IP为10.0.0.2的数据包转发到table2中处理。  </p><p>步骤13 选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{i}”。node id参见之前查询到的Node Id、table id设为0、flow id设为1。  </p><p>步骤14 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800。  </p><p>步骤15 匹配参数保持不变，以主机1的IP为源IP，以主机3的IP为目的IP。  </p><p>步骤16 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“go-to-table-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5a73537cd.png" alt="26.png"><br>步骤17 展开“go-to-table”，table_id填写为2，即将符合匹配条件的数据包根据table2中的流表项处理。instruction order依旧设为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5aa888c72.png" alt="27.png"><br>步骤18 设“priority”置为23，“idle-timeout”为0，“hard-timeout”为0，“cookie”为1000000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5ad13fe66.png" alt="28.png"><br>步骤19 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。  </p><p>步骤20 切换到交换机，执行以下命令查看新下发的流表项。</p><blockquote></blockquote><pre><code>ovs-ofctl -O OpenFlow13 dump-flows b</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b076d691.png" alt="29.png"><br>步骤21 切换到主机1，执行如下命令发送数据包，测试主机之间的连通性。</p><blockquote></blockquote><pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b4ae09ab.png" alt="30.png"><br>由上图可知，主机1与主机3之间不通，而主机1与主机2之间通，流表发挥作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;YANG UI是OpenDaylight中一款基于DLUX的应用，旨在简化、激励应用的开发与测试。YANG UI通过动态封装
      
    
    </summary>
    
      <category term="SDN,实验" scheme="https://cyneliu.github.io/categories/SDN-%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>5.OpenFlow实现示例之中继器HUB</title>
    <link href="https://cyneliu.github.io/2018/09/15/5-OpenFlow%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%AD%E7%BB%A7%E5%99%A8HUB/"/>
    <id>https://cyneliu.github.io/2018/09/15/5-OpenFlow实现示例之中继器HUB/</id>
    <published>2018-09-15T13:09:29.000Z</published>
    <updated>2018-09-15T14:42:29.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow的流表项主要由3部分组成，分别是用于数据分组匹配的分组头域（Head Field），用于保存与条目相关统计信息的计数器（Counter），还有匹配表项后需要对数据分组执行的动作表（Action）。分组头域是数据分组匹配流表项时参照的依据，作用上类似于传统交换机进行二层交换时匹配数据分组的MAC地址，路由器进行三层路由时匹配的IP地址。流表项中的计数器用来统计相关“流”的一些信息，例如查找次数、收发分组数、生存时间等。另外，OpenFlow针对每张表、每个流表项、每个端口、每个队列也都会维护它们相应的计数器。动作表指定了OpenFlow交换机处理相应“流”的行为。相比于传统网络设备对数据分组只能进行较为单一的转发操作，流表项根据指定动作字段来指导OF交换机如何处理“流”。动作表可以包含0个或多个动作，交换机会按照这些动作的先后顺序依次执行，如果其中不包含转发（Forward）动作的话，数据分组就会被丢弃掉，如果包含转发动作，数据分组会得到相应的转发处理，但是OpenFlow v1.0无法保证不同的数据分组的转发顺序。动作可以分为两种类型：必选动作（Required Action）和可选动作（Optional Action）。必选动作是默认支持的，而交换机需要通知控制器它支持的可选动作。另外，当流表项中存在OpenFlow交换机不支持的动作时将向控制器返回错误消息。在SDN网络中，控制器下发流表主要有两种模式，分别是reactive模式和proactive模式。  </p><p>传统交换机参照MAC地址转发，路由器参照IP地址转发，通过定制ASIC芯片可以实现高速工作。而OpenFlow将网络协议栈扁平化，协议栈各层次对于转发设备而言不再具有明确的界限，各个网络字段都可作为流表中的匹配域，通过通配符掩码实现任意字段的组合。相比于传统网络，这种做法无疑大大提高了网络灵活性，但付出的代价是硬件设备为了适应这种通配的匹配方式，一般来说需要采用TCAM（Ternary Content Addressable Memory）来设计流表，但是TCAM的成本要高出很多，这就极大地限制了流表的规模，也就限制了SDN的规模。如果按照很多客户的要求，动辄要几十KB甚至上百KB的流表要求，至少需要20Mbit的TCAM，远远超过目前市场上容量最大的交换芯片的TCAM大小。为了克服TCAM表较小的问题，SDN先驱们提出采用reactive的方式来编写TCAM。<br><img src="https://i.loli.net/2018/09/15/5b9d05573ed46.png" alt="1.png"><br>在reactive模式下，OpenFlow交换机接收到未知数据包时，会向控制器发送一条packet_in消息询问控制器如何处理该数据包。控制器接收到packet_in消息后，计算路径并发送一条flow_mod消息指示交换机如何处理该数据包。并且，当老化定时器超时后就可以删除与该数据包相关的流表项。如此一来，OpenFlow交换机无需维护全部流表，只有当未知数据包到达交换机时才会触发reactive模式，可以有效的节省TCAM的空间。但是reactive模式缺点就是交换机无法即时地处理未知数据包，需要依赖控制器的决策，虽然在一定程度上解决了TCAM较小带来的问题，但是也让SDN控制器成为系统扩展的瓶颈，随着网络规模的不断扩大，SDN控制器无法处理大规模的网络流量，SDN控制器的性能就会限制网络规模的扩展。  </p><p>OpenFlow交换机和OpenFlow控制器之间的通道建立后，由OpenFlow控制器向OpenFlow交换机预先发送流表项方式称之为proactive模式。proactive模式的设置不是必须在控制器与交换机建立连接后立刻下发流表，可以在连接建立后的任意时间下发流表。proactive模式的主要特点是“主动”，控制器主动下发流表给交换机，随后交换机可以直接根据流表进行转发。proactive模式下控制器的压力会大大减轻，不过TCAM造成的局限性也尤为明显。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9d0af0ac5d1.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，检查网络连通性。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p><p>步骤2 登录主机，查看主机IP。  </p><p>登录交换机，查看交换机mac地址。  </p><blockquote></blockquote><pre><code>ifconfig |more</code></pre><p>根据实验拓扑图、交换机和主机的mac地址，可以判断出交换机eth1连接host1，eth2连接host2，eth3连接host3。</p><h1 id="proactive模式"><a href="#proactive模式" class="headerlink" title="proactive模式"></a>proactive模式</h1><p>步骤1 Open Daylight控制器与交换机建立连接后，会自动下发初始流表。登录交换机使用下列命令查看初始流表。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p>如果没有的话重启一下交换机。<br><img src="https://i.loli.net/2018/09/15/5b9d129607bf4.png" alt="2.png"><br>步骤2 登录控制器，在下方的“Application Finder”中搜索“postman”，并打开自带的Postman工具，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d151e53f54.png" alt="3.png"><br>步骤3 获取交换机的id信息。打开Basic Auth页签，Username字段填写admin，Password字段填写admin完成认证。  </p><p>提交方式为GET，URL地址栏中输入<a href="http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。</a>  </p><p>步骤4 单击Send按钮，获取交换机id信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d156896885.png" alt="4.png"><br>步骤5 下发一条流表。</p><blockquote><p>选择提交方式“PUT”。  </p></blockquote><blockquote><p>URL地址栏输入如下形式的地址：http://{controller-ip}:8080/restconf/config/opendaylight-inventory:nodes/node/{node-id}/table/{table-id}/flow/{flow-id}。  </p></blockquote><blockquote><p>其中，{controller-ip}为控制器的ip地址，node-id为上面获取到的交换机id信息，table-id这里为0，flow-id根据下发不同流表变化，可自定义。本实验URL地址栏输入如下地址：<a href="http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。</a>  </p></blockquote><blockquote><p>填写Headers信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d16d59439b.png" alt="5.png"><br>单击Body，Bady格式选择raw—&gt;XML(application/xml)。Body内容如下所示：  </p></blockquote><blockquote><p>匹配条件为ANY，actions为ALL，即将交换机收到的所有数据包转发到除入端口外的所有端口，从而实现中继器HUB的功能。</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;priority&gt;35&lt;/priority&gt;    &lt;flow-name&gt;SDN&lt;/flow-name&gt;    &lt;idle-timeout&gt;0&lt;/idle-timeout&gt;    &lt;hard-timeout&gt;0&lt;/hard-timeout&gt;    &lt;match&gt;ANY&lt;/match&gt;    &lt;id&gt;14&lt;/id&gt;    &lt;table_id&gt;0&lt;/table_id&gt;    &lt;instructions&gt;        &lt;instruction&gt;            &lt;order&gt;0&lt;/order&gt;            &lt;apply-actions&gt;                &lt;action&gt;                       &lt;output-action&gt;                          &lt;output-node-connector&gt;ALL&lt;/output-node-connector&gt;                       &lt;/output-action&gt;                       &lt;order&gt;0&lt;/order&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;        &lt;/instruction&gt;    &lt;/instructions&gt;&lt;/flow&gt;</code></pre><p>步骤6 单击Send按钮发送请求，STATUS显示请求发送成功，流表下发成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d18177ec0e.png" alt="6.png"><br>步骤7 登录交换机查看下发的流表，执行以下命令：</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d184ac4929.png" alt="7.png"><br>步骤8 登录主机host1，对主机host2进行ping操作，host2的IP为10.0.0.10，执行以下命令：</p><blockquote></blockquote><pre><code>ping 10.0.0.10</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18930750e.png" alt="8.png"><br>步骤9 登录交换机用tcpdump捕获广播到host2和host3数据包。host2对应的端口是eth2，host3对应的端口是eth3，分别捕获这两个端口上的数据包。  </p><p>（备注：选择不在host3、host2上抓包的原因是：由于当h1 ping h2时，数据包从交换机所有端口output出去后，openstack中的Linux-bridge会根据转发表过滤掉所有目的地址与端口不一致的数据包，因此host3上无法捕获host1与host2之间的数据包。）</p><blockquote></blockquote><pre><code>tcpdump -i eth2</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18d0ab61c.png" alt="9.png"></p><blockquote></blockquote><pre><code>tcpdump -i eth3</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d19734c90f.png" alt="10.png"></p><h1 id="reactive模式"><a href="#reactive模式" class="headerlink" title="reactive模式"></a>reactive模式</h1><p>reactive模式需要依赖SDN控制器的反应，实现较为复杂，在此仅进行方案介绍，不做实验操作，有兴趣的同学可自行拓展学习。  </p><p>步骤1 reactive模式的触发机制就是交换机将接收到数据包转发给控制器，交换机转发数据包给控制器的情况有两种：一个是交换机接收到未知数据包；另一个就是流表action要求交换机将数据包转发给控制器。因此设置reactive模式的第一步是下发一条流表，priority设置为最高65535，匹配条件为ANY，actions是将数据包output到controller。<br><img src="https://i.loli.net/2018/09/15/5b9d1a21ac061.png" alt="11.png"><br>流表项设置好后，当host1发送数据包时，交换机接收到数据包后会发送packet_in消息给控制器。  </p><p>步骤2 控制器接收到packet_in消息后对消息中的内容进行判断，计算分析后发送packet_out消息给交换机，告知交换机如何处理该数据包。本实验中控制器会要求交换机将数据包转发到除入端口外的所有端口，从而实验中继器的功能。<br><img src="https://i.loli.net/2018/09/15/5b9d1a4af035d.png" alt="12.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;OpenFlow的流表项主要由3部分组成，分别是用于数据分组匹配的分组头域（Head Field），用于保存与条目相关统计信
      
    
    </summary>
    
      <category term="SDN,实验" scheme="https://cyneliu.github.io/categories/SDN-%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>4.基于RESTCONF的流表管理</title>
    <link href="https://cyneliu.github.io/2018/09/14/4-%E5%9F%BA%E4%BA%8ERESTCONF%E7%9A%84%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/14/4-基于RESTCONF的流表管理/</id>
    <published>2018-09-14T14:36:06.000Z</published>
    <updated>2018-09-15T13:10:25.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>所谓流表，其实可被视作是SDN对网络设备的数据转发功能的一种抽象。在传统网络设备中，交换机和路由器的数据转发需要依赖设备中保存的二层MAC地址转发表或者三层的IP地址路由表，SDN交换机中使用的流表也是如此，不过在它的表项中整合了网络中各个层次的网络配置信息，从而在进行数据转发时可以使用更丰富的规则。  </p><p>在使用RESTCONF下发流表时，需要学习的是请求消息的BODY的结构。实例如下：</p><blockquote></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;     &lt;table_id&gt;0&lt;/table_id&gt;    &lt;id&gt;100&lt;/id&gt;     &lt;strict&gt;false&lt;/strict&gt;   &lt;priority&gt;1&lt;/priority&gt;     &lt;instructions&gt;         &lt;instruction&gt;             &lt;order&gt;0&lt;/order&gt;             &lt;apply-actions&gt;                 &lt;action&gt;                     &lt;order&gt;0&lt;/order&gt;                     &lt;output-action&gt;&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;                    &lt;/output-action&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;        &lt;/instruction&gt;    &lt;/instructions&gt;    &lt;match&gt;    &lt;/match&gt;&lt;/flow&gt;</code></pre><p>BODY中定义了流表名称（flowname）、flow所在的table（table_id）、flow的id（id）、是否严格匹配（strict）、优先级和匹配字段（match fields）、优先级（priority）、指令（instructions）、超时（timeouts）、cookie等值。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc7011f.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机查看网络连通性。由于OpenDaylight组件过于庞大，所以启动比较慢，容易导致控制器与交换机连接不成功的现象，间接导致主机无法获取IP。所以使用OpenDaylight控制器时，需要先检查网络连通性，查看交换机与控制器连接情况。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p><p>步骤6 登录交换机，执行如下命令连接控制器。</p><blockquote></blockquote><pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640</code></pre><p>原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。</p><h1 id="删除ODL自动下发的流表"><a href="#删除ODL自动下发的流表" class="headerlink" title="删除ODL自动下发的流表"></a>删除ODL自动下发的流表</h1><p>在实验过程中需要验证两个不能通信的主机，通过REST北向接口下发流表，使得两个主机能够通信，所以需要删除原先的默认通信流表。  </p><p>步骤1 登录交换机，执行如下命令删除流表，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl del-flows -O OpenFlow13 br-sw</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc315a1.png" alt="1.png"><br>步骤2 执行ovs-ofctl dump-flows -O OpenFlow13 br-sw查看是否删除成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf7eee833f.png" alt="2.png"><br>步骤3 登录其中的一个主机，查看主机间网络网络连通情况，此时主机间无法进行通信，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf80fce130.png" alt="3.png"></p><h1 id="下发通信流表"><a href="#下发通信流表" class="headerlink" title="下发通信流表"></a>下发通信流表</h1><p>步骤1 登录控制器，打开浏览器，输入URL：<strong>http://[controller_ip]:8181/index.html</strong>，输入有户名：admin，密码：admin，单击登录。登录后，单击Nodes菜单，获取交换机node id，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf86025757.png" alt="4.png"><br>步骤2 单击Applications Menu/Development/Postman打开postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa287541e.png" alt="5.png"><br>步骤3 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/100。  </p><p>[controller-ip]为当前控制器的数据层的ip，[node-id]即步骤1中获得的node id请求类型选择PUT。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。选择BODY的类型raw -&gt;XML（application/xml），如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa5754286.png" alt="6.png"><br>步骤4 输入Body内容如下：</p><blockquote></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;    &lt;table_id&gt;0&lt;/table_id&gt;    &lt;id&gt;100&lt;/id&gt;    &lt;installHw&gt;false&lt;/installHw&gt;    &lt;strict&gt;false&lt;/strict&gt;  &lt;priority&gt;1&lt;/priority&gt;    &lt;instructions&gt;       &lt;instruction&gt;           &lt;order&gt;0&lt;/order&gt;           &lt;apply-actions&gt;               &lt;action&gt;                   &lt;order&gt;0&lt;/order&gt;                   &lt;output-action&gt;&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;                   &lt;/output-action&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;            &lt;/instruction&gt;    &lt;/instructions&gt;    &lt;match&gt;    &lt;/match&gt;&lt;/flow&gt;注意：严格区分大小写</code></pre><p>步骤5 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb40e9192.png" alt="7.png"><br>步骤6 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/。[controller-ip] 为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id请求类型选择GET。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb65ceea0.png" alt="8.png"><br>步骤7 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb85a72bb.png" alt="9.png"><br>可以看到，此流表为之前通过REST北向接口下发的流表。  </p><p>步骤8 登录其中的一个主机，查看主机间网络网络情况，此时主机间能够进行通信。</p><h1 id="使用Postman删除流表"><a href="#使用Postman删除流表" class="headerlink" title="使用Postman删除流表"></a>使用Postman删除流表</h1><p>步骤1 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/[flow-id]。  </p><p>[controller-ip]为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id，[flow-id]为之前下发流表的id，可以到【四、下发通信流表】的BODY中查看。请求类型选择DELETE.访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。点击Send，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf41812.png" alt="10.png"><br>步骤2登录交换机，切换至root用户。执行命令ovs-ofctl dump-flows -O OpenFlow13 br-sw，可验证流表已删除，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf2cb35.png" alt="11.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;所谓流表，其实可被视作是SDN对网络设备的数据转发功能的一种抽象。在传统网络设备中，交换机和路由器的数据转发需要依赖设备中保
      
    
    </summary>
    
      <category term="SDN,实验" scheme="https://cyneliu.github.io/categories/SDN-%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>3.Open vSwitch流表管理</title>
    <link href="https://cyneliu.github.io/2018/09/14/3-Open-vSwitch%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/14/3-Open-vSwitch流表管理/</id>
    <published>2018-09-14T13:10:47.000Z</published>
    <updated>2018-09-14T14:14:29.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议去连接Open vSwitch，创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。  </p><p>在OpenFlow的白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或者多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。  </p><p>当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。<br>在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或者空格分开。一些常用的字段列举如下：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd40468.png" alt="1.png"><br>ovs-ofctl关于流表管理的常用命令：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd3a959.png" alt="2.png"><br>对于add−flow，add−flows和mod−flows这三个命令，还需要指定要执行的动作：actions=[target][,target…]，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br>常见的操作有：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd4cb85.png" alt="3.png"></p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9bb4dd4d9be.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，执行以下命令，查看镜像中原有的网桥，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbf7b25c05.png" alt="4.png"><br>步骤5 执行以下命令，删除当前网桥，并进行确认，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl del-br br-swovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbfb869e58.png" alt="5.png"></p><h1 id="流表管理"><a href="#流表管理" class="headerlink" title="流表管理"></a>流表管理</h1><p>步骤1 执行以下命令，添加网桥，并查看虚拟交换机的基本信息，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl add-br br0ovs-ofctl show br0</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbffd27c45.png" alt="6.png"><br>由上图可知，可以查看到交换机dpid、流表数量、性能参数、动作参数、MAC地址等信息。  </p><p>步骤2 执行以下命令，查看虚拟交换机上各端口的状态，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br0</code></pre><p>由上图可知，输出的结果中包含了各端口上收到的数据包数，字节数，丢包数，错误数据包数等。  </p><p>步骤3 执行以下命令，添加一条流表项，设置流表项生命周期为1000s，优先级为17，入端口为3，动作是output:2。</p><blockquote></blockquote><pre><code>ovs-ofctl add-flow br0 idle_timeout=1000,priority=17,in_port=3,actions=output:2说明：这条流表项的作用是将端口3接收到的数据包从端口2输出。</code></pre><p>步骤4 执行以下命令，查看交换机上所有流表信息，如下图所示。</p><blockquote><pre><code>ovs-ofctl dump-flows br0</code></pre></blockquote><p>步骤5 执行以下命令，删除入端口为3的的流表项，删除后，再次查看流表信息，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl del-flows br0 in_port=3ovs-ofctl dump-flows br0</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bc08844d29.png" alt="7.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置Open
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>秒懂MBR和GPT分区表</title>
    <link href="https://cyneliu.github.io/2018/09/13/%E7%A7%92%E6%87%82MBR%E5%92%8CGPT%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>https://cyneliu.github.io/2018/09/13/秒懂MBR和GPT分区表/</id>
    <published>2018-09-13T11:58:17.000Z</published>
    <updated>2018-09-13T12:39:54.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的Apple分区图。<br>MBR的全称是Master Boot Record（主引导记录），MBR早在1983年IBM PC DOS 2.0中就已经提出。之所以叫“主引导记录”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。主引导扇区是硬盘的第一扇区。它由三个部分组成，主引导记录MBR、硬盘分区表DPT和硬盘有效标志。在总共512字节的主引导扇区里MBR占446个字节，偏移地址（0000H–0088H），它负责从活动分区中装载，并运行系统引导程序；第二部分是Partition table区（DPT分区表），占64个字节；第三部分是Magic number，占2个字节。 </p><h1 id="MBR分区表系统"><a href="#MBR分区表系统" class="headerlink" title="MBR分区表系统"></a>MBR分区表系统</h1><p>所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。  </p><p>分区表偏移地址为01BEH–01FDH，每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4，分别对应MBR的四个主分区。Magic number也就是结束标志字，偏移地址01FE–01FF的2个字节，固定为55AA，如果该标志错误系统就不能启动。   </p><p>MBR最大支持2.2TB磁盘，它无法处理大于2.2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区。 </p><h1 id="GPT分区表系统"><a href="#GPT分区表系统" class="headerlink" title="GPT分区表系统"></a>GPT分区表系统</h1><p>GPT的全称是Globally Unique Identifier Partition Table，意即GUID分区表，它的推出是和UEFI BIOS相辅相成的，鉴于MBR的磁盘容量和分区数量已经不能满足硬件发展的需求，GPT首要的任务就是突破了2.2T分区的限制，最大支持18EB的分区。 </p><p>而在分区数量上，GPT会为每一个分区分配一个全局唯一的标识符，理论上GPT支持无限个磁盘分区，不过在Windows系统上由于系统的限制，最多只能支持128个磁盘分区，基本可以满足所有用户的存储需求。在每一个分区上，这个标识符是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符。   </p><p>而在安全性方面，GPT分区表也进行了全方位改进。在早期的MBR磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT还为这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏，GPT会发觉这些破坏，并从磁盘上的其他地方进行恢复。  </p><p>小结：所以对于新平台用户（Intel 6系以后/AMD 900系列以后和A系列）来说，都强烈推荐使用GPT分区表格式，目前包括Windows Vista、7、8、8.1、10已经都支持读取和使用GPT分区表。而对于使用Windows 8、8.1、10的用户，换用GPT后开机启动速度也可以进一步得到显著提升。 </p><h1 id="BIOS-MBR"><a href="#BIOS-MBR" class="headerlink" title="BIOS+MBR"></a>BIOS+MBR</h1><p>这种方式是目前最常见的装机方式，所有的系统都会支持，兼容较老硬件，目前新电脑大多出厂时就使用UEFI方式启动。</p><h1 id="UEFI-GPT"><a href="#UEFI-GPT" class="headerlink" title="UEFI+GPT"></a>UEFI+GPT</h1><p>GPT与UEFI是相辅相成的，如果分区表系统是GPT，那么必须使用UEFI，传统的BIOS方式无法启动，这也就是为什么现在很多人在给新机器重装系统时无法启动的原因。  </p><p>UEFI+GPT还有一个优点就是开机速度更快，原因是开机时跳过外设检测，并且可以实现启动时原生分辨率，搭载固态硬盘开机时间很短，十秒左右。  </p><p>UEFI可用鼠标操作图形界面，不再是枯燥的蓝底白字的英文。由Intel提出，用于取代BIOS。UEFI的优越特性：可操作性、安全性、兼容性、可扩展性。  </p><p>主板为了兼容MBR分区表，一般会提供Legacy BIOS和UEFI BIOS启动模式选项，可以把UEFI设置成Legacy模式（传统模式）、打开CSM兼容模块，让其支持传统MBR启动，此时效果同BIOS+MBR。如果要使用UEFI模式安装Windows，就必须开启UEFI启动模式。</p><h1 id="系统支持性"><a href="#系统支持性" class="headerlink" title="系统支持性"></a>系统支持性</h1><p>目前64bit Windows Vista、7、8、8.1、10都已经支持GPT分区表，而Windows 8、8.1、10都已经原生支持UEFI，安装这些系统的时候：只要硬盘设置为GPT分区表，主板设置为UEFI启动后，就可以直接开始安装操作系统了。 而对于Windows Vista、7系统，就需要手动添加UEFI支持：我们可以找一份Windows 8或者10安装镜像，从安装文件中提取Bootmgfw.efi文件，重命名为BOOTX64.EFI，拷贝到win7安装文件的\EFI\Boot\下，如果没有BOOT文件夹新建一个即可。 </p><h1 id="修改为传统方式启动"><a href="#修改为传统方式启动" class="headerlink" title="修改为传统方式启动"></a>修改为传统方式启动</h1><p>如果实在是搞不明白或者像之前的我一样不太懂的话，可以使用分区助手将GPT改为MBR，如图：<br><img src="https://i.loli.net/2018/09/13/5b9a589d17e85.jpg" alt="1.jpg"><br>选中磁盘，在左侧菜单中选择“转换到MBR磁盘”：<br><img src="https://i.loli.net/2018/09/13/5b9a589cddfb3.jpg" alt="2.jpg"><br>转换成功：<br><img src="https://i.loli.net/2018/09/13/5b9a589d066d8.jpg" alt="3.jpg"><br>转换完成进行分区后，不要忘了把装系统的分区转换成活动分区：<br><img src="https://i.loli.net/2018/09/13/5b9a589d099b4.jpg" alt="4.jpg"><br>最后还是建议大家花几分钟时间了解一下UEFI的方式，这必定是未来的一个趋势，并不推荐采用上图将GPT修改为MBR的方式重装系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分区表&quot;&gt;&lt;a href=&quot;#分区表&quot; class=&quot;headerlink&quot; title=&quot;分区表&quot;&gt;&lt;/a&gt;分区表&lt;/h1&gt;&lt;p&gt;全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的
      
    
    </summary>
    
      <category term="装机" scheme="https://cyneliu.github.io/categories/%E8%A3%85%E6%9C%BA/"/>
    
    
      <category term="装机" scheme="https://cyneliu.github.io/tags/%E8%A3%85%E6%9C%BA/"/>
    
      <category term="硬件" scheme="https://cyneliu.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2.OVSDB的网桥和端口管理</title>
    <link href="https://cyneliu.github.io/2018/09/13/2-OVSDB%E7%9A%84%E7%BD%91%E6%A1%A5%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/13/2-OVSDB的网桥和端口管理/</id>
    <published>2018-09-13T07:21:32.000Z</published>
    <updated>2018-09-15T11:44:15.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFlow和OVSDB两种南向协议方式与Open vSwitch交换机进行交互，其中通过OpenFlow来引导数据包流的转发，通过OVSDB可以进行端口和隧道的增加、更新以及删除，这些隧道和端口提供流转发的管道。因此，OVSDB在Open vSwitch作为一个重要的事实标准，OpenDaylight系统如何高效地支持OVSDB也变得非常重要。OpenDaylight的OVSDB子项目实现了OVSDB管理协议，该协议允许控制器进行虚拟交换机的南向配置。OVSDB协议包含一个OVSDB库和各种插件用法，该协议使用JSON/RPC调用的方式来操作内置OVSDB的物理或虚拟交换机。<br>OVSDB子项目主要包含Northbound模块、plugin模块和OVSDB Library模块，其中北向Northbound模块可供外部APP调用，南向OVSDB Library通过OVSDB协议与外部通信，进行OVSDB的管理，具体系统架构如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a10f6d7c34.png" alt="1.png"><br>Library模块主要包含message、notation、impl、jsonrpc和schema等程序包,其中jsonrpc主要提供兼容rpc1.0的解码器，能够从TCP流解码JSON消息；notation主要包含OVSDB MAP、ResultSet等定义以及Json串行化；schema提供OVSDB数据库模式的表示。</p><p>Plugin模块主要包含api、impl、internal和error等程序包，其中api程序包主要提供OVSDB的连接、增删改查等服务，impl包中的类是其接口的实现。  </p><p>Northbound模块主要包含五大类,分别是DatabaseResource、NodeResource、OvsdbNorthboundV2、OvsdbNorthboundV3、RowResource、TableResource。以类OvsdbNorthboundV2为例进行说明，该类提供OVSDB北向 REST API接口，用于创建、读取、更新和删除任一OVSDB表中的记录。创建OVSDB Row时，body请求体中的JSON格式与OVSDB JSON-PRC消息相同。northbound及其功能描述如下表所示。<br><img src="https://i.loli.net/2018/09/13/5b9a123b86027.png" alt="2.png"><br>用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。而Postman不仅可以调试简单的css、html、脚本等简单的网页基本信息，还可以发送GET、POST、PUT、DENLETE等几乎所有类型的HTTP请求。Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9b47e2af14d.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录OpenDaylight控制器，确保服务已经启动成功，由于OpenDaylight组件过于庞大，所以启动比较慢，需等待一段时间，使用命令：</p><blockquote></blockquote><pre><code>netstat -an|grep 6633 #netstat -an:查看端口对应的应用</code></pre><p>查看端口是否处于监听状态：<br><img src="https://i.loli.net/2018/09/14/5b9b46db45a61.png" alt="3.png"><br>步骤2 在保证控制6633端口处于监听状态后，登录交换机，查看交换机与控制器连接情况。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9b4746ca6a9.png" alt="4.png"><br>上图中controller下方显示“is_connected:true”则表明连接成功。<br>步骤3 登录控制器，查看控制器IP，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4798e189e.png" alt="5.png"><br>步骤4 登录交换机，连接控制器。原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。执行如下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640</code></pre><p>连接成功后在manager下面会有“is_conneted:true”：<br><img src="https://i.loli.net/2018/09/14/5b9b47e2a28df.png" alt="6.png"></p><h1 id="创建网桥"><a href="#创建网桥" class="headerlink" title="创建网桥"></a>创建网桥</h1><p>步骤1 登录控制器，单击Applications Menu—&gt;Development—&gt;Postman打开Postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4e42b73f7.png" alt="7.png"><br>步骤2 在创建网桥前，需要先获取交换机节点信息，输入URL <strong>http://[controller ip]:8282/ovsdb/nb/v3/node</strong>。  </p><p>请求类型选择GET，单击Send按钮发送GET请求。访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择Basic Auth。输入用户名和密码，用户名和密码都是admin。Body中返回的就是交换机节点信息，此处获取到的节点信息在后面会用到，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4ebbb7028.png" alt="8.png"><br>步骤3 发送POST请求创建网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”</a>  </p><p>就是前面获取到的交换机节点信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba28a8e540.png" alt="9.png"><br>单击Headers，输入用户名和密码生成HTTP认证头部，POST请求还需要添加头部指明Body格式，如图所示，手动输入Content-Type且值为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba3126bc5f.png" alt="10.png"><br>步骤4 单击Body，Body格式选择raw—&gt;JSON(application/json)。Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。  </p><p>Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。单击Send按钮发送请求。</p><blockquote></blockquote><pre><code>{   &quot;row&quot;: {    &quot;Bridge&quot;: {      &quot;name&quot;: &quot;br0&quot;,        &quot;datapath_type&quot;: &quot;OpenFlow13&quot;        }    }}</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba36f496f1.png" alt="11.png"><br>步骤5 登录交换机，确认网桥创建成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba3d7290b1.png" alt="12.png"></p><h1 id="获取网桥uuid"><a href="#获取网桥uuid" class="headerlink" title="获取网桥uuid"></a>获取网桥uuid</h1><p>步骤1 URL保持不变，依旧是<a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows</a> ，将请求类型改为GET。输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba676a461c.png" alt="13.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并返回网桥信息，下图中两个uuid分别是br0和br-sw的。单击uuid所在行左侧的数字可以展开/收起网桥的详细信息，方便查看，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6a5aefc1.png" alt="14.png"></p><h1 id="创建端口"><a href="#创建端口" class="headerlink" title="创建端口"></a>创建端口</h1><p>步骤1 发送POST请求创建端口，输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。</a><br>单击Basic Auth，输入用户名和密码生成HTTP认证头部，并且添加Content-Type为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6e473f28.png" alt="15.png"><br>步骤2 将请求类型改为POST，输入Body内容如下所示，其中parent_uuid是网桥的uuid，这里所用的是br0的uuid，那么端口就会添加到br0网桥上。</p><blockquote></blockquote><pre><code>{   &quot;parent_uuid&quot;: &quot;2dd82e5e-922d-43c8-80d9-7917161acfd2&quot;,    &quot;row&quot;: {      &quot;Port&quot;: {        &quot;name&quot;: &quot;port0&quot;          }    }}</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba72ac6722.png" alt="16.png"><br>单击Send按钮发送请求，STATUS显示请求发送成功，端口已经创建，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba762e1b34.png" alt="17.png"><br>步骤3 登录交换机，确认交换机端口是否创建成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba79b19c6c.png" alt="18.png"></p><h1 id="获取端口uuid"><a href="#获取端口uuid" class="headerlink" title="获取端口uuid"></a>获取端口uuid</h1><p>步骤1 发送GET请求获取端口的uuid。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows</a> 。在Basic Auth页面输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7d5c4665.png" alt="19.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并且展示出获取到的端口信息。因为获取的是所有网桥的端口所以比较多，如下图所示，标注出来的是port0的uuid。获取到的信息完全展开比较多，可以直接在页面中搜索端口名称“port0”，然后往上翻找该端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7feaebe3.png" alt="20.png"></p><h1 id="删除端口"><a href="#删除端口" class="headerlink" title="删除端口"></a>删除端口</h1><p>步骤1 发送DELETE请求删除端口。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8</a> ”就是port0端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8431f4b2.png" alt="21.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8655ebe0.png" alt="22.png"><br>步骤3 登录交换机，确认port0端口删除成功。</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba89fe7601.png" alt="23.png"></p><h1 id="删除网桥"><a href="#删除网桥" class="headerlink" title="删除网桥"></a>删除网桥</h1><p>步骤1 发送DELETE请求删除网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”</a> 就是br0网桥的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8ddef7ab.png" alt="24.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba9024cca5.png" alt="25.png"><br>步骤3 登录交换机，确认网桥br0删除成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba934ab15e.png" alt="26.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFl
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>1.OpenFlow建立连接交互流程</title>
    <link href="https://cyneliu.github.io/2018/09/13/1-OpenFlow%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B/"/>
    <id>https://cyneliu.github.io/2018/09/13/1-OpenFlow建立连接交互流程/</id>
    <published>2018-09-13T05:30:58.000Z</published>
    <updated>2018-09-13T07:12:11.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenFlow协议简介"><a href="#OpenFlow协议简介" class="headerlink" title="OpenFlow协议简介"></a>OpenFlow协议简介</h1><p>2006年，斯坦福大学Clean Slate计划资助的Ethane项目开始部署，致力于企业网架构的创新，OpenFlow协议的雏形就诞生于这个项目。2008年，Nick McKeown教授的一篇重要论文“OpenFlow：Enabling Innovation in Campus Networks”使得OpenFlow正式进入人们的视野，继而成为了标准化组织ONF（Open Network Foundation，开放网络基金会）主推的南向接口协议。经过多年的发展，OpenFlow现已成为SDN的主流南向接口协议之一。目前，OpenFlow协议还在不断地演进中，本实验采用OpenFlow v1.3协议，并对控制器与OpenFlow交换机之间的交互过程进行深入分析。<br>OpenFlow主要有3种类型的消息，分别是Controller-to-Switch、Asynchronous和Symmetric，其中每个类型又包含多个子类型。Controller-to-Switch消息由控制器发起，用于管理、查看交换机的状态。Asynchronous消息由交换机发起，向控制器汇报交换机的事件和改变。Symmetric消息由控制器或交换机任一方发起，无需请求直接发起消息。详细信息如下表所示：<br><img src="https://i.loli.net/2018/09/13/5b99fc6a1c7b0.png" alt="1.png"></p><h1 id="OpenFlow连接建立交互流程"><a href="#OpenFlow连接建立交互流程" class="headerlink" title="OpenFlow连接建立交互流程"></a>OpenFlow连接建立交互流程</h1><p><img src="https://i.loli.net/2018/09/13/5b99fd98251f8.png" alt="2.png"><br>在OpenFlow1.3协议的情况下，控制器与OpenFlow交换机的消息完整交互流程如下：<br>1、 控制器与OpenFlow交换机通过TCP“三次握手”，建立有效的连接。其中，控制器一端的端口号为6633。<br>2、 控制器与OpenFlow交换机之间相互发送Hello消息，用于协商双方的OpenFlow版本号。在双方支持的最高版本号不一致的情况下，协商的结果将以较低的OpenFlow版本为准。如果双方协商不一致，还会产生Error消息。<br>3、 控制器向OpenFlow交换机发送Features Request消息，请求OpenFlow交换机上传自己的详细参数。OpenFlow交换机收到请求后，向控制器发送Features Reply消息，详细汇报自身参数，包括支持的buffer数目、流表数以及Actions等。<br>4、 控制器通过Set Config消息下发配置参数，然后通过Get config Request消息请求OpenFlow交换机上传修改后的配置信息。OpenFlow交换机通过Get config Reply消息向控制器发送当前的配置信息。<br>5、 控制器与OpenFlow交换机之间发送Packet_out、Packet_in消息，通过Packet_out中内置的LLDP包，进行网络拓扑的探测。<br>6、 控制器与OpenFlow交换机之间通过发送Multipart Request、Mutipart Reply消息，控制器能获取OpenFlow交换机的状态信息，包括流的信息、端口信息等。<br>7、 控制器与OpenFlow交换机之间通过发送Echo Request、Echo Reply消息，保证二者之间存在有效连接，避免失联。  </p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/13/5b9a0b09e2b9b.png" alt="3.png"></p><h1 id="捕获数据包"><a href="#捕获数据包" class="headerlink" title="捕获数据包"></a>捕获数据包</h1><p>步骤1 登录Floodlight控制器，启动抓包工具Wireshark，捕获控制器与交换机建立连接过程中的数据包，通过分析这些数据包了解控制器与交换机基于OpenFlow协议进行交互的流程。执行以下命令：</p><blockquote></blockquote><pre><code>sudo wireshark</code></pre><p>步骤2 双击eth0网卡，查看eth0网卡上数据包收发情况，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ba6a9fb7.png" alt="4.png"><br>步骤3 登录Mininet虚拟机，启动Mininet。通过“—controller”参数设置Mininet连接远程控制器，并指定控制器的IP和端口号。</p><blockquote></blockquote><pre><code>sudo mn --controller=remote,ip=30.0.1.3,port=6633 --switch=ovsk,protocols=OpenFlow13</code></pre><p><img src="https://i.loli.net/2018/09/13/5b9a0bf62d0be.png" alt="5.png"><br>步骤4 登录Floodlight控制器，停止Wireshark，观察数据包列表，可以看出控制器与交换机的基本交互流程。<br><img src="https://i.loli.net/2018/09/13/5b9a0c1ddbc4e.png" alt="6.png"></p><h1 id="OpenFlow1-3交互流程分析"><a href="#OpenFlow1-3交互流程分析" class="headerlink" title="OpenFlow1.3交互流程分析"></a>OpenFlow1.3交互流程分析</h1><p>步骤1 交换机连接控制器的6633端口，经过3次握手后双方建立TCP连接。查看捕获到的数据包，分析交换机与控制器建立TCP连接的流程。分析TCP连接建立过程，需要先了解TCP的状态位，主要包括SYN、FIN、ACK、PSH、RST和URG。SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。可以看出交换机与控制器经历一次连接重置后，成功完成三次握手，建立TCP连接，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c63cdbf7.png" alt="7.png"><br>步骤2 当控制器与交换机建立TCP连接后，由其中某一方发起Hello消息，双方协调协OpenFlow议版本号。控制器和交换机都会向对方发送一条Hello消息，消息中附上自己支持的OpenFlow的最高版本。接收到对方Hello消息后，判断自己能否支持对方发送的版本，能支持则版本协商成功，不能支持则回复一条OFPT_ERROR消息。查看Hello消息详情，本实验中由于交换机和控制器都能支持OpenFlow1.3版本，所以版本协商为1.3，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c8900db0.png" alt="8.png"><br>步骤3 OpenFlow版本协商完成后，控制器发送一条features_request消息获取交换机的特性信息，包括交换机的ID（DPID）、缓冲区数量、端口及端口属性等等。相应的，交换机回复features_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0cb6bf243.png" alt="9.png"><br>查看数据包详情，ofpt_feature_request消息只有包头，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ce6d0540.png" alt="10.png"><br>ofpt_feature_reply数据包详情如下，交换机的DPID是数据通道独一无二的标识符，低48位是一个MAC地址，高16位是自定义的。本实验中交换机缓冲区数量（n_buffers）为256，交换机支持的流表数量（n_tables）为254，交换机所支持的功能，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d1008f0a.png" alt="11.png"><br>步骤4 OpenFlow1.0协议中feature_reply消息还包含交换机端口信息，OpenFlow 1.3协议将‘stats’框架更名为‘multipart’框架，并且将端口描述移植到multipart消息中。其中OPPT_PORT_DESC类型的multipart消息就是用于获取交换机端口信息的。<br><img src="https://i.loli.net/2018/09/13/5b9a0d34705f8.png" alt="12.png"><br>查看OPPT_PORT_DESC类型multipart_reply消息，消息中列出了交换机的端口以及每个端口的详细信息，包括端口名称和mac地址等，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d5f30b72.png" alt="13.png"><br>步骤5 OFPMP_DESC类型的multipart_reply消息包含了交换机的其他信息，包括交换机厂商名称、交换机名称以及交换机版本等。本实验中使用的是Mininet仿真软件中自带的开源交换机Open vSwitch(2.0.2)，而Open vSwitch是由Nicira Networks主导开发的，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d8d31133.png" alt="14.png"><br>步骤6 在连接过程中，控制器不断的发送echo_request消息给交换机，确认交换机与控制器之间的连接状态。相应的，交换机会回复echo_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0db731025.png" alt="15.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenFlow协议简介&quot;&gt;&lt;a href=&quot;#OpenFlow协议简介&quot; class=&quot;headerlink&quot; title=&quot;OpenFlow协议简介&quot;&gt;&lt;/a&gt;OpenFlow协议简介&lt;/h1&gt;&lt;p&gt;2006年，斯坦福大学Clean Slate计划资助的Eth
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>SDN中的南向接口和北向接口</title>
    <link href="https://cyneliu.github.io/2018/09/11/SDN%E4%B8%AD%E7%9A%84%E5%8D%97%E5%90%91%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%8C%97%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <id>https://cyneliu.github.io/2018/09/11/SDN中的南向接口和北向接口/</id>
    <published>2018-09-11T08:46:53.000Z</published>
    <updated>2018-09-11T08:58:49.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SDN的意义"><a href="#SDN的意义" class="headerlink" title="SDN的意义"></a>SDN的意义</h1><p>SDN网络的最终目标是服务于多样化的业务应用创新。因此随着SDN技术的部署和推广，将会有越来越多的业务应用被研发，这类应用将能够便捷地通过SDN北向接口调用底层网络能力，按需使用网络资源。  </p><p>SDN推动业务创新已经是业界不争的事实，它可以被广泛地应用在云数据中心、宽带传输网络、移动网络等种种场景中，其中为云计算业务提供网络资源服 务就是一个非常典型的案例。众所周知，在当前的云计算业务中，服务器虚拟化、存储虚拟化都已经被广泛应用，它们将底层的物理资源进行池化共享，进而按需分配给用户使用。相比之下，传统的网络资源远远没有达到类似的灵活性，而SDN的引入则能够很好地解决这一问题。</p><h1 id="南向接口"><a href="#南向接口" class="headerlink" title="南向接口"></a>南向接口</h1><p>SDN通过标准的南向接口屏蔽了底层物理转发设备的差异，实现了资源的虚拟化，同时开放了灵活的北向接口供上层业务按需进行网络配置并调用网络资源。  </p><p>云计算领域中知名的OpenStack就是可以工作在SDN应用层的云管理平台，通过在其网络资源管理组件中增加SDN管理插件，管理者和使用者可利 用SDN北向接口便捷地调用SDN控制器对外开放的网络能力。当有云主机组网需求(例如建立用户专有的VLAN)被发出时，相关的网络策略和配置可以在 OpenStack管理平台的界面上集中制定并进而驱动SDN控制器统一地自动下发到相关的网络设备上。  </p><p>当前，最知名的南向接口莫过于ONF倡导的OpenFlow协议。作为一个开放的协议，OpenFlow突破了传统网络设备厂商对设备能力接口的壁垒，经过多年的发展，在业界的共同努力下，当前已经日臻完善，能够全面解决SDN网络中面临的各种问题。  </p><p>因此，网络资源可以和其他类型的虚拟化资源一样，以抽象的资源能力的面貌统一呈现给业务应用开发者，开发者无需针对底层网络设备的差异耗费大量开销从事额外的适配工作，这有助于业务应用的快速创新。</p><h1 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h1><p>控制层是SDN的大脑，负责对底层转发设备的集中统一控制，同时向上层业务提供网络能力调用的接口，在SDN架构中具有举足轻重的作用，SDN控制 器也是SDN关注的焦点。从技术实现上看，控制器除了南向的网络控制和北向的业务支撑外，还需要关注东西的扩展，以避免SDN集中控制导致的性能和安全瓶颈问题，SDN控制器也在南向、北向、东西向上引入了相应的核心技术，有效解决与各层通信以及控制集群横向扩展的难题。  </p><p>当前，业界有很多基于OpenFlow控制协议的开源的控制器实现，例如NOX、Onix、Floodlight等，它们都有各自的特色设计，能够实现链路发现、拓扑管理、策略制定、表项下发等支持SDN网络运行的基本操作。虽然不同的控制器在功能和性能上仍旧存在差异，但是从中已经可以总结出SDN控制器应当具备的技术特征，从这些开源系统的研发与实践中得到的经验和教训将有助于推动SDN控制器的规范化发展。  </p><p>另外，用于网络集中化控制的控制器作为SDN网络的核心，其性能和安全性非常重要，其可能存在的负载过大、单点失效等问题一直是SDN领域中亟待解决的问题。当前，业界对此也有了很多探讨，从部署架构、技术措施等多个方面提出了很多有创见的方法。  </p><p>SDN控制器对网络的控制主要是通过南向接口协议实现,包括链路发现、拓扑管理、策略制定、表项下发等，其中链路发现和拓扑管理主要是控制其利用南 向接口的上行通道对底层交换设备上报信息进行统一监控和统计;而策略制定和表项下发则是控制器利用南向接口的下行通道对网络设备进行统一控制。</p><h1 id="北向接口"><a href="#北向接口" class="headerlink" title="北向接口"></a>北向接口</h1><p>SDN北向接口是通过控制器向上层业务应用开放的接口，其目标是使得业务应用能够便利地调用底层的网络资源和能力。通过北向接口，网络业务的开发者 能以软件编程的形式调用各种网络资源;同时上层的网络资源管理系统可以通过控制器的北向接口全局把控整个网网络的资源状态，并对资源进行统一调度。因为北 向接口是直接为业务应用服务的，因此其设计需要密切联系业务应用需求，具有多样化的特征。同时，北向接口的设计是否合理、便捷，以便能被业务应用广泛调用，会直接影响到SDN控制器厂商的市场前景。  </p><p>与南向接口方面已有OpenFlow等国际标准不同，北向接口方面还缺少业界公认的标准，因此，北向接口的协议制定成为当前SDN领域竞争的焦点， 不同的参与者或者从用户角度出发，或者从运营角度出发，或者从产品能力角度出发提出了很多方案。据悉,目前至少有20种控制器,每种控制器会对外提供北向 接口用于上层应用开发和资源编排。虽然北向接口标准当前还很难达成共识，但是充分的开放性、便捷性、灵活性将是衡量接口优劣的重要标准，例如REST API就是上层业务应用的开发者比较喜欢的接口形式。部分传统的网络设备厂商在其现有设备上提供了编程接口供业务应用直接调用，也可被视作是北向接口之一，其目的是在不改变其现有设备架构的条件下提升配置管理灵活性，应对开放协议的竞争。</p><h1 id="SDN交换机"><a href="#SDN交换机" class="headerlink" title="SDN交换机"></a>SDN交换机</h1><p>SDN的核心理念之一就是将控制功能从网络设备中剥离出来，通过中央控制器实现网络可编程，从而实现资源的优化利用，提升网络管控效率。  </p><p>工作在基础设施层的SDN交换机虽然不在需要对逻辑控制进行过多考虑，但作为SDN网络中负责具体数据转发处理的设备，为了完成高速数据转发，还是 要遵循交换机工作原理。本质上看，传统设备中无论是交换机还是路由器，其工作原理都是在收到数据包时，将数据包中的某些特征域与设备自身存储的一些表项进 行比对，当发现匹配时则按照表项的要求进行相应处理。SDN交换机也是类似的原理，但是与传统设备存在差异的是，设备中的各个表项并非是由设备自身根据周 边的网络环境在本地自行生成的，而是由远程控制器统一下发的，因此各种复杂的控制逻辑(例如链路发现、地址学习、路由计算等等)都无需在SDN交换机中实现。  </p><p>SDN交换机可以忽略控制逻辑的实现，全力关注基于表项的数据处理，而数据处理的性能也就成为评价SDN交换机优劣的最关键指标，因此，很多高性能 转发技术被提出，例如基于多张表以流水线方式进行高速处理的技术。另外，考虑到SDN和传统网络的混合工作问题，支持混合模式的SDN交换机也是当前设备 层技术研发的焦点。同时，随着虚拟化技术的出现和完善，虚拟化环境将是SDN交换机的一个重要应用场景，因此SDN交换机可能会有硬件、软件等多种形态。 例如，OVS(Open vSwitch，开放虚拟交换标准)交换机就是一款基于开源软件技术实现的能够集成在服务器虚拟化Hypervisor中的交换机，具备完善的交换机功能，在虚拟化组网中起到了非常重要的作用。  </p><p>SDN交换机的出现，对传统的网络设备厂商造成了最直接的威胁，如何将新兴的网络技术与传统设备产品的优势相融合，是这些厂商正在苦苦思索的问题。 虽然SDN交换机已经对传统的网络产业链造成了巨大的冲击，但是仅凭单独的数据转发设备还不足以支撑起整个SDN的天空，未来更激烈地竞争必将会在SDN的控制层和应用层发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SDN的意义&quot;&gt;&lt;a href=&quot;#SDN的意义&quot; class=&quot;headerlink&quot; title=&quot;SDN的意义&quot;&gt;&lt;/a&gt;SDN的意义&lt;/h1&gt;&lt;p&gt;SDN网络的最终目标是服务于多样化的业务应用创新。因此随着SDN技术的部署和推广，将会有越来越多的业务应用被
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda开始菜单失踪</title>
    <link href="https://cyneliu.github.io/2018/09/10/Anaconda%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E5%A4%B1%E8%B8%AA/"/>
    <id>https://cyneliu.github.io/2018/09/10/Anaconda开始菜单失踪/</id>
    <published>2018-09-10T13:23:33.000Z</published>
    <updated>2018-09-10T13:30:02.556Z</updated>
    
    <content type="html"><![CDATA[<p>今天想打开Anaconda写python程序的时候，突然发现Anaconda在开始菜单中神秘失踪了。<br>这时候只需要打开cmd，切换到Anaconda的安装目录的Lib文件夹下，执行如下命令：</p><blockquote></blockquote><pre><code>python _nsis.py mkmenus</code></pre><p>重新生成一下开始菜单即可。<br><img src="https://i.loli.net/2018/09/10/5b9670b820c45.png" alt="snipaste_20180909_124542.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天想打开Anaconda写python程序的时候，突然发现Anaconda在开始菜单中神秘失踪了。&lt;br&gt;这时候只需要打开cmd，切换到Anaconda的安装目录的Lib文件夹下，执行如下命令：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;c
      
    
    </summary>
    
      <category term="疑难杂症" scheme="https://cyneliu.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="Anaconda" scheme="https://cyneliu.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化运维笔记——服务器</title>
    <link href="https://cyneliu.github.io/2018/07/11/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://cyneliu.github.io/2018/07/11/虚拟化运维笔记——服务器/</id>
    <published>2018-07-11T12:28:09.000Z</published>
    <updated>2018-07-11T13:09:51.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器通电自启"><a href="#服务器通电自启" class="headerlink" title="服务器通电自启"></a>服务器通电自启</h1><p>实验室有三台浪潮的服务器，默认关闭了通电自启的功能，因为不使用，也一直没去在意它，今天没事给它把通电自启动打开了，省的以后麻烦，在此记录一下，下图内容拍自浪潮服务器：<br>1、开机时按Delete键进入BIOS<br><img src="https://i.loli.net/2018/07/11/5b45ff414107c.jpg" alt="001.jpg"><br>2、选择Chipset-PCH<br><img src="https://i.loli.net/2018/07/11/5b45ff4151548.jpg" alt="002.jpg"><br>3、将Restore AC Power Loss修改为Power Off<br><img src="https://i.loli.net/2018/07/11/5b45ff414cd73.jpg" alt="003.jpg"><br>这里解释一下各个选项的意思：</p><blockquote><p><em>Restore AC Power Loss</em>:如果发生断电，恢复供电后系统如何反应<br><em>Power Off</em>:接通电源后保持关机状态<br><em>Power On</em>:接通电源后开机<br><em>Last State</em>:恢复到断电前的状态</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务器通电自启&quot;&gt;&lt;a href=&quot;#服务器通电自启&quot; class=&quot;headerlink&quot; title=&quot;服务器通电自启&quot;&gt;&lt;/a&gt;服务器通电自启&lt;/h1&gt;&lt;p&gt;实验室有三台浪潮的服务器，默认关闭了通电自启的功能，因为不使用，也一直没去在意它，今天没事给它把通电
      
    
    </summary>
    
      <category term="运维，笔记" scheme="https://cyneliu.github.io/categories/%E8%BF%90%E7%BB%B4%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="运维" scheme="https://cyneliu.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化运维笔记——vsphere</title>
    <link href="https://cyneliu.github.io/2018/07/11/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94vsphere/"/>
    <id>https://cyneliu.github.io/2018/07/11/虚拟化运维笔记——vsphere/</id>
    <published>2018-07-11T10:58:49.000Z</published>
    <updated>2018-07-11T11:25:03.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置虚拟机随主机自动启动"><a href="#设置虚拟机随主机自动启动" class="headerlink" title="设置虚拟机随主机自动启动"></a>设置虚拟机随主机自动启动</h1><h2 id="0、选择虚拟机所在主机"><a href="#0、选择虚拟机所在主机" class="headerlink" title="0、选择虚拟机所在主机"></a>0、选择虚拟机所在主机</h2><p>单击选择虚拟机所在的主机，在后侧选项卡中选择“配置”<br><img src="https://i.loli.net/2018/07/11/5b45e78a91f56.png" alt="snipaste_20180711_190241.png"></p><h2 id="1、设置属性"><a href="#1、设置属性" class="headerlink" title="1、设置属性"></a>1、设置属性</h2><p>单击右上角的属性<br><img src="https://i.loli.net/2018/07/11/5b45e78a8af69.png" alt="snipaste_20180711_184912.png"></p><h2 id="2、设置虚拟机自动启动"><a href="#2、设置虚拟机自动启动" class="headerlink" title="2、设置虚拟机自动启动"></a>2、设置虚拟机自动启动</h2><p>勾选“允许虚拟机与系统一起自动启动和停止”，然后在“启动顺序”中将需要设置自动启动的虚拟机上移到自动启动一栏下，如果有需要，可根据情况设置启动延迟，最后点击确定即可。<br><img src="https://i.loli.net/2018/07/11/5b45e78a90520.png" alt="snipaste_20180711_185154.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设置虚拟机随主机自动启动&quot;&gt;&lt;a href=&quot;#设置虚拟机随主机自动启动&quot; class=&quot;headerlink&quot; title=&quot;设置虚拟机随主机自动启动&quot;&gt;&lt;/a&gt;设置虚拟机随主机自动启动&lt;/h1&gt;&lt;h2 id=&quot;0、选择虚拟机所在主机&quot;&gt;&lt;a href=&quot;#0、
      
    
    </summary>
    
      <category term="运维，笔记" scheme="https://cyneliu.github.io/categories/%E8%BF%90%E7%BB%B4%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="运维" scheme="https://cyneliu.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>WinSCP——基于SSH的安全文件传输软件</title>
    <link href="https://cyneliu.github.io/2018/07/03/WinSCP%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ESSH%E7%9A%84%E5%AE%89%E5%85%A8%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E8%BD%AF%E4%BB%B6/"/>
    <id>https://cyneliu.github.io/2018/07/03/WinSCP——基于SSH的安全文件传输软件/</id>
    <published>2018-07-03T02:10:14.000Z</published>
    <updated>2018-07-03T02:34:47.347Z</updated>
    
    <content type="html"><![CDATA[<p>我的一个影视网站因为之前买的虚拟主机到期了，就想着把它放到我那台ssr主机上，结果配置vstp的时候不知道什么原因，配置完用客户端登录的时候总是提示说密码验证失败。然后看到一个博主推荐，就是WinSCP了，它的好处在于他是基于SSH协议的sftp文件传输，也就是说，只要你的linux主机可以使用ssh，就可以用它进行文件传输。  </p><h1 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h1><p>sftp(Secure File Transfer Protocol)，安全文件传送协议，可以为传输文件提供一种安全的网络的加密方法。sftp与ftp有着几乎一样的语法和功能。SFTP是SSH的一部分，其实在SSH软件包中，已经包含了一个叫作SFTP的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。<br>SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，所以在对网络安全性要求更高时，可以使用SFTP代替FTP。</p><h1 id="sftp于ftp的区别"><a href="#sftp于ftp的区别" class="headerlink" title="sftp于ftp的区别"></a>sftp于ftp的区别</h1><p>FTP是一种文件传输协议，一般是为了方便数据共享的，包括一个FTP服务器和多个FTP客户端，FTP客户端通过FTP协议在服务器上下载资源。而SFTP协议是基于SSH，并在FTP的基础上对数据进行加密，使得传输的数据相对来说更安全。但是这种安全是以牺牲效率为代价的，也就是说SFTP的传输效率比FTP要略低。<br>而且在我的使用过程中，并没有感觉sftp的效率较于ftp有太大的差异，而且使用sftp最大的一个好处就是不需要安装而且安全性更高。<br>更详细的区别可以移步这里：<a href="https://www.cnblogs.com/mfryf/archive/2013/05/29/3107286.html" target="_blank" rel="noopener">Sftp和ftp 区别、工作原理等（汇总ing）</a></p><h1 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h1><p>官网地址：<a href="https://winscp.net/eng/docs/lang:chs" target="_blank" rel="noopener">https://winscp.net/eng/docs/lang:chs</a><br>除了WinSCP，Windows环境下还可以使用Core FTP，FileZilla, WinSCP，Xftp来连接SFTP进行上传，下载文件，建立，删除目录等操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的一个影视网站因为之前买的虚拟主机到期了，就想着把它放到我那台ssr主机上，结果配置vstp的时候不知道什么原因，配置完用客户端登录的时候总是提示说密码验证失败。然后看到一个博主推荐，就是WinSCP了，它的好处在于他是基于SSH协议的sftp文件传输，也就是说，只要你的
      
    
    </summary>
    
      <category term="Server" scheme="https://cyneliu.github.io/categories/Server/"/>
    
    
      <category term="文件传输" scheme="https://cyneliu.github.io/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    
      <category term="Server" scheme="https://cyneliu.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化运维笔记 —— Linux</title>
    <link href="https://cyneliu.github.io/2018/06/25/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux/"/>
    <id>https://cyneliu.github.io/2018/06/25/虚拟化运维笔记——Linux/</id>
    <published>2018-06-25T13:50:33.000Z</published>
    <updated>2018-08-09T05:39:30.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux下使用Rinetd来实现端口转发"><a href="#Linux下使用Rinetd来实现端口转发" class="headerlink" title="Linux下使用Rinetd来实现端口转发"></a>Linux下使用Rinetd来实现端口转发</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>centos</strong><br>0、对于centos，由于官方的源中并没有Rinetd，所以首先需要第三方源<br>32位系统：</p><blockquote></blockquote><pre><code>$ vim /etc/yum.repos.d/nux-misc.repo[nux-misc]name=Nux Miscbaseurl=http://li.nux.ro/download/nux/misc/el6/i386/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</code></pre><p>64位系统：</p><blockquote></blockquote><pre><code>$ vim  /etc/yum.repos.d/nux-misc.repo:[nux-misc]name=Nux Miscbaseurl=http://li.nux.ro/download/nux/misc/el6/x86_64/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</code></pre><p>1、安装Rinetd</p><blockquote></blockquote><pre><code>$ yum --enablerepo=nux-misc install rinetd</code></pre><p><strong>Ubuntu</strong></p><blockquote></blockquote><pre><code>apt-get install rinetd</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>端口转发的配置文件在<em>/etc/rinetd.conf</em><br>配置文件的格式：</p><blockquote></blockquote><pre><code>[bindaddress] [bindport] [connectaddress] [connectport]绑定的地址    绑定的端口  连接的地址      连接的端口[Source Address] [Source Port] [Destination Address] [Destination Port]源地址            源端口         目的地址               目的端口</code></pre><p>例如：</p><blockquote></blockquote><pre><code>0.0.0.0 8080 172.19.94.3 80800.0.0.0 2222 192.168.0.103 33891.2.3.4 80 192.168.0.10 80allow *.*.*.*logfile /var/log/rinetd.log</code></pre><p>说明  </p><blockquote><p>0.0.0.0表示本机绑定所有可用地址<br>将所有发往本机8080端口的请求转发到172.19.94.3的8080端口<br>将所有发往本机2222端口的请求转发到192.168.0.103的3389端口<br>将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口<br>allow设置允许访问的ip地址信息,<em>.</em>.<em>.</em>表示所有IP地址<br>logfil设置打印的log的位置  </p></blockquote><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><blockquote></blockquote><pre><code>pkill rinetd  ##关闭进程rinetd -c /etc/rinetd.conf  ##启动转发</code></pre><p>把命令加到/etc/rc.local里面就可以开机自动运行</p><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="默认编辑器nano"><a href="#默认编辑器nano" class="headerlink" title="默认编辑器nano"></a>默认编辑器nano</h2><p>用习惯了vim编辑器，有时候想修改配置文件，可设备又没网，Ubuntu默认使用的是nano编辑器，真心不如vim好用。</p><blockquote></blockquote><pre><code>ctrl+X  #退出ctrl+O  #保存</code></pre><h2 id="Ubuntu设置静态ip"><a href="#Ubuntu设置静态ip" class="headerlink" title="Ubuntu设置静态ip"></a>Ubuntu设置静态ip</h2><p>通过修改“/etc/network/interfaces”进行修改，<br><img src="https://i.loli.net/2018/06/25/5b30f4ef9991f.png" alt="QQ图片20180625214835.png"><br>注：在设置多个DNS服务器的时候要加“s”,如：</p><blockquote></blockquote><pre><code>dns-nameservers 114.114.114.114 8.8.8.8</code></pre><p>修改之后需要执行：  </p><blockquote></blockquote><pre><code>sudo /etc/init.d/networking restart</code></pre><p>使用这个方式修改ip地址，修改完interfaces文档中的内容后，需要修改/etc/NetworkManager/NetworkManager.conf文档中的managed参数，使之为true，并重启。否则，会提示说“有线网络设备未托管”。<br>重启网络或系统之后就修改完成了。  </p><h2 id="安装TeamViewer"><a href="#安装TeamViewer" class="headerlink" title="安装TeamViewer"></a>安装TeamViewer</h2><p>teamviewer远程登录的方式不建议使用！<br>1、到TeamViewer官网下载对应版本的安装包。<br>2、下载完成之后切换到下载目录，执行：</p><blockquote></blockquote><pre><code>sudo dpkg -i teamviewer_13.0.9865_amd64.deb</code></pre><p>版本号要根据下载的包进行更改。<br>这时候可能会报出如下错误：</p><blockquote></blockquote><pre><code>正在选中未选择的软件包 teamviewer。 (正在读取数据库 … 系统当前共安装有 253291 个文件和目录。) 正准备解包 teamviewer_13.0.6634_amd64.deb … 正在解包 teamviewer (13.0.6634) … dpkg：警告：无法删除原有的目录 /var/log/teamviewer12 ：目录非空 dpkg: 依赖关系问题使得 teamviewer 的配置工作不能继续： teamviewer 依赖于 qtdeclarative5-dialogs-plugin (&gt;= 5.2) | qml-module-qtquick-dialogs (&gt;= 5.2)；然而： 未安装软件包 qtdeclarative5-dialogs-plugin。 未安装软件包 qml-module-qtquick-dialogs。 dpkg: 处理软件包 teamviewer (–install)时出错： 依赖关系问题 - 仍未被配置 正在处理用于 desktop-file-utils (0.22-1ubuntu5.1) 的触发器 … 正在处理用于 gnome-menus (3.13.3-6ubuntu3.1) 的触发器 … 正在处理用于 bamfdaemon (0.5.3~bzr0+16.04.20160824-0ubuntu1) 的触发器 … Rebuilding /usr/share/applications/bamf-2.index… 正在处理用于 mime-support (3.59ubuntu1) 的触发器 … 正在处理用于 hicolor-icon-theme (0.15-0ubuntu1) 的触发器 … 在处理时有错误发生： teamviewer</code></pre><p>目前我遇到的有两种解决方式：<br>一、修复依赖关系</p><blockquote><p>一种解决方法是执行如下命令修复依赖关系：   </p></blockquote><pre><code>sudo apt install f</code></pre><p>执行完后再安装看看能否成功，如果还是不成功就要采用第二种方式了。<br>二、更新源地址</p><blockquote><p>①删除安装到一半的teamviewer：</p></blockquote><pre><code>sudo apt-get remove teamviewer</code></pre><p>②在Ubuntu的<a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">源列表</a>中找到对应系统的源，复制到/etc/apt/sources.list 里面，并把原来的链接注释掉。<br>③更新系统软件：</p><blockquote></blockquote><pre><code>sudo apt-get update #更新软件列表sudo apt-get upgrade #更新软件</code></pre><p>④运行安装命令：</p><blockquote></blockquote><pre><code>sudo dpkg -i teamviewer_13.0.9865_amd64.deb</code></pre><p>3、在TeamViewer的使用中发现经常在系统重启后连接就出现“未知原因”的问题，原因还在摸索中，目前能解决的方法就是卸载重新安装：</p><blockquote></blockquote><pre><code>apt purge teamviewersudo dpkg -i teamviewer_13.0.9865_amd64.deb</code></pre><h2 id="16-04出现“The-system-is-running-in-low-graphics-mode”"><a href="#16-04出现“The-system-is-running-in-low-graphics-mode”" class="headerlink" title="16.04出现“The system is running in low-graphics mode”"></a>16.04出现“The system is running in low-graphics mode”</h2><p>在虚拟机中安装的Ubuntu16.04无法显示完全，尝试修改分辨率后会卡死，然后重启就会出现如题所示的错误。<br>解决方法为：<br>1、重启虚拟机，按ctrl + alt + F1 进入纯字符界面，输入账号和密码<br>2、执行如下命令：</p><blockquote></blockquote><pre><code>cd /etc/X11sudo cp xorg.conf.failsafe xorg.conf #刷新配置文件sudo reboot</code></pre><p>重启之后就可以正常显示了。</p><h2 id="启用root用户"><a href="#启用root用户" class="headerlink" title="启用root用户"></a>启用root用户</h2><p>执行：</p><blockquote></blockquote><pre><code>sudo passwd root</code></pre><p>设置密码后即可使用su直接切换为root用户。<br><img src="https://img-blog.csdn.net/20160722112307840" alt=""></p><h2 id="安装GNOME-Shell桌面"><a href="#安装GNOME-Shell桌面" class="headerlink" title="安装GNOME Shell桌面"></a>安装GNOME Shell桌面</h2><p>1、安装GNOME Shell</p><blockquote></blockquote><pre><code>sudo apt-get install gnome-shell</code></pre><p>安装过程中出现如下界面，选择lightdm：<br><img src="https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2014/06/Switch_between_gdm_and_lightgdm_Ubuntu.jpeg" alt=""><br>2、退出当前账户，选择GNOME桌面系统<br>3、重新登陆，安装gnome-tweak</p><blockquote></blockquote><pre><code>sudo apt-get install gnome-tweak-tool</code></pre><p>tweak是主题管理工具，具体使用方法参见：<br><a href="https://itsfoss.com/install-switch-themes-gnome-shell/" target="_blank" rel="noopener">https://itsfoss.com/install-switch-themes-gnome-shell/ </a><br>4、使用tweak更换主题<br>方法参考：<br><a href="https://itsfoss.com/gnome-shell-themes-ubuntu-1404/" target="_blank" rel="noopener">https://itsfoss.com/gnome-shell-themes-ubuntu-1404/</a>  </p><h2 id="执行sudo-apt-get-update出错"><a href="#执行sudo-apt-get-update出错" class="headerlink" title="执行sudo apt-get update出错"></a>执行sudo apt-get update出错</h2><p>在运行sudo apt-get update时出现如下信息：</p><blockquote></blockquote><pre><code>Reading package lists... DoneE: Problem executing scripts APT::Update::Post-Invoke-Success&apos;if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli;then appstreamcli refresh &gt; /dev/null;fi&apos;E: Sub-process returned an error code</code></pre><p>解决方法如下：</p><blockquote></blockquote><pre><code>sudo pkill -KILL appstreamcliwget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.debsudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb</code></pre><p>或者：</p><blockquote></blockquote><pre><code>apt show appstreamsudo apt remove appstream</code></pre><h2 id="Ubuntu在虚拟机中显示不全的问题"><a href="#Ubuntu在虚拟机中显示不全的问题" class="headerlink" title="Ubuntu在虚拟机中显示不全的问题"></a>Ubuntu在虚拟机中显示不全的问题</h2><p>关于这个问题之前也是尝试了无数的方法，今天无意间明白了原因并解决了问题。<br>1、首先要明白的是不是随便一个分辨率都可以更改，首先执行以下命令查询当前的显示状态：</p><blockquote></blockquote><pre><code>xrandr</code></pre><p><img src="https://img-blog.csdn.net/20150602205903147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhczEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其中第一个带*的就是当前的分辨率，其下的数值是我们可以更改的分辨率，每个虚拟机可能略有不同。<br>2、执行：</p><blockquote></blockquote><pre><code>xrandr -s 1440x900_59.9</code></pre><p>即可将分辨率设置为1440x900。<br>3、上述命令只能临时修改，永久修改需要执行：</p><blockquote></blockquote><pre><code>xrandr --output Virtual1 --mode 1440x900</code></pre><p>其中“Virtual1”是显示器的名称，要根据执行xrandr返回的信息进行相应的替换。<br>4、错误<br>这些也是我自己遇到的一点问题。</p><blockquote><p>①有时候执行步骤3中所说的命令并不能永久更改，重启后会失效。目前一个方法就是在系统设置→显示中应用一下更改过来的分辨率，这样在重启之后就不会出现问题了。<br>②“xrandr: Configure crtc 0 failed”  </p><blockquote><p>这是一个系统bug，在设置,关于这台计算机,检查更新。更新完重启后就没问题了。</p></blockquote></blockquote><h2 id="Ubuntu16-04安装VNC"><a href="#Ubuntu16-04安装VNC" class="headerlink" title="Ubuntu16.04安装VNC"></a>Ubuntu16.04安装VNC</h2><p>“VNC有很多选择，VNC4server，tigervncserver等等，都不推荐，难装又难用。经过多次实验和测试，最后只采用x11vnc作为VNC服务器端。” <a href="https://blog.csdn.net/longhr/article/details/51657610" target="_blank" rel="noopener">查看原文</a><br>1、安装X11VNC</p><blockquote></blockquote><pre><code>sudo apt install x11vnc -y</code></pre><p>2、配置访问密码</p><blockquote></blockquote><pre><code>sudo x11vnc -storepasswd /etc/x11vnc.pass </code></pre><p>3、创建服务</p><blockquote></blockquote><pre><code>vi  /lib/systemd/system/x11vnc.service</code></pre><blockquote><p>粘贴如下代码：</p></blockquote><pre><code>[Unit]Description=Start x11vnc at startup.After=multi-user.target[Service]Type=simpleExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared[Install]WantedBy=multi-user.target</code></pre><p>4、配置防火墙，配置并启动服务</p><blockquote></blockquote><pre><code>sudo ufw allow 5900sudo systemctl enable x11vnc.servicesudo systemctl daemon-reload</code></pre><p>如果出现如下图所示的错误，就说明第三步中你的配置信息粘贴错误了，修改正确即可解决。<img src="https://i.loli.net/2018/06/30/5b37243cc1a2e.jpg" alt="QQ图片20180630142539.jpg"><br>5、重启系统</p><blockquote></blockquote><pre><code>reboot</code></pre><h2 id="nat123配置"><a href="#nat123配置" class="headerlink" title="nat123配置"></a>nat123配置</h2><p>nat123端口映射是专业的内网端口映射软件，在内网启动映射后，可在外网轻松访问连接内网网站等应用，不需要设置路由器，不需要公网ip,不需要固定ip,不需要动态域名。  </p><p>Ubuntu配置过程：（其它linux直接参考<a href="http://www.nat123.com/pages_17_600.jsp" target="_blank" rel="noopener">官网说明</a>）<br>0、注册账号<br>没有注册过账号的先到官网注册：<a href="http://www.nat123.com/" target="_blank" rel="noopener">http://www.nat123.com/</a><br>1、安装mono运行环境</p><blockquote></blockquote><pre><code>apt-get  install  mono-complete</code></pre><p>安装完成后执行“mono -V”可查看安装的版本信息。<br>2、客户端安装</p><blockquote></blockquote><pre><code>cd  /optmkdir  nat123cd  /nat123wget  http://www.nat123.com/down/nat123linux.tar.gztar  -zxvf  nat123linux.tar.gz</code></pre><p>3、启动客户端</p><blockquote></blockquote><pre><code>cd  /opt/nat123mono  nat123linux.sh</code></pre><p>输入用户名和密码登录成功后，直接结束当前进程，然后执行如下命令改为后台运行：</p><blockquote></blockquote><pre><code>cd  /opt/nat123mono  nat123linux.sh service &amp;ps  -ef|grep  nat123 #查看nat123状态</code></pre><p>4、登录网页添加端口映射或动态域名解析</p><h1 id="RHEL"><a href="#RHEL" class="headerlink" title="RHEL"></a>RHEL</h1><h2 id="系统意外重启后VNC连接失败"><a href="#系统意外重启后VNC连接失败" class="headerlink" title="系统意外重启后VNC连接失败"></a>系统意外重启后VNC连接失败</h2><p>在服务器中运行着几个RHEL实例，VNC是之前老师配置的，这几个实例在服务器断电重启之后会出现VNC连接出错的问题。解决方法如下：</p><blockquote></blockquote><pre><code>cd /tmprm -rvf .X11-unix #手动删除因为VNC非正常退出未删除的文件vncserver :3 #重启服务</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h1&gt;&lt;h2 id=&quot;Linux下使用Rinetd来实现端口转发&quot;&gt;&lt;a href=&quot;#Linux下使用Rinetd来实现端口转
      
    
    </summary>
    
      <category term="运维，笔记" scheme="https://cyneliu.github.io/categories/%E8%BF%90%E7%BB%B4%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="运维" scheme="https://cyneliu.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>SDN入门（一）—— 环境搭建</title>
    <link href="https://cyneliu.github.io/2018/06/24/SDN%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://cyneliu.github.io/2018/06/24/SDN入门（一）——-环境搭建/</id>
    <published>2018-06-24T01:20:49.000Z</published>
    <updated>2018-06-30T06:25:22.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h1><h2 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a>系统选择</h2><p>镜像建议使用16.04的版本，mininet官网有说明，是因为16.04支持新版本的openflow等协议，我这里使用的是“ubuntu-16.04-server-amd64.iso”，server版本更加稳定。</p><h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><h3 id="设置网卡"><a href="#设置网卡" class="headerlink" title="设置网卡"></a>设置网卡</h3><p>因为要使用ssh远程登录，这里我们添加一个网卡：<br><img src="https://i.loli.net/2018/06/24/5b2ef5cbec5f1.png" alt="01.png"><br>勾选“启用网络连接”，并选择仅主机模式。</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>挂载镜像之后启动虚拟机进行安装，基本的安装过程不一一详细介绍，不会的地方可以百度。<br><img src="https://i.loli.net/2018/06/24/5b2ef77a37059.png" alt="02.png"><br>可以看到安装程序已经识别出了两块网卡，我们选择默认的nat网卡作为主网络接口。<br><img src="https://i.loli.net/2018/06/24/5b2ef9a7a101d.png" alt="03.png"><br>软件安装，我们只需要安装ssh server就可以了，记得空格选择，回车确认。  </p><p>安装完成后，我们看一下系统的网卡信息，发现并没有我们添加的网卡。<br><img src="https://i.loli.net/2018/06/24/5b2efcabda76f.png" alt="04.png"><br>执行“sudo dhclient enp0s8”启用enp0s8网卡。<br>再次查看网卡信息：<br><img src="https://i.loli.net/2018/06/24/5b2efed26c4cc.png" alt="05.png"><br>可以看到已经添加进来了。我们还需要将第二块网卡的配置加入到网络配置文件中，不然重启之后第二块网卡还是看不到的：  </p><blockquote></blockquote><pre><code>sudo vi /etc/network/interfaces</code></pre><p>在interfaces配置文件中加入enp0s8，同样使用dhcp方式获取ip<br><img src="https://i.loli.net/2018/06/24/5b2efffbe249f.png" alt="06.png"><br>至此，我们的系统就配置完成了，用ssh工具进行连接：<br><img src="https://i.loli.net/2018/06/24/5b2f00ad250a3.png" alt="07.png"><br>已经可以成功连接。</p><h1 id="安装Ryu"><a href="#安装Ryu" class="headerlink" title="安装Ryu"></a>安装Ryu</h1><p>详细内容可参考<a href="http://linton.tw/2014/02/15/note-install-ryu-36-sdn-framework/" target="_blank" rel="noopener">linton的博客</a>。</p><p>1.下载python的套件库，并更新pip（因为下载的pip并不是最新版本）</p><blockquote></blockquote><pre><code>sudo apt-get install python-pip python-dev build-essentialsudo pip install --upgrade pip</code></pre><p>2.安装Ryu相依性套件</p><blockquote></blockquote><pre><code>sudo apt-get install python-eventletsudo apt-get install python-routessudo apt-get install python-webobsudo apt-get install python-paramiko</code></pre><p>3.使用pip下载并安装Ryu</p><blockquote></blockquote><pre><code>sudo pip install ryu</code></pre><p>此步骤如果出现如下错误信息说明你被挡在城内了，富强上网即可解决。<br><img src="https://i.loli.net/2018/06/24/5b2f22b8832fc.png" alt="需要富强上网.png"><br>4.如果需要使用Ryu with GUI则进行此步骤：下载Ryu source code（需要使用git套件）</p><blockquote></blockquote><pre><code>sudo apt-get install gitgit clone https://github.com/osrg/ryu.git</code></pre><p>5.完成安装，执行ryu-manager验证有没有出现错误，没问题的话会出现如下信息：<br><img src="https://i.loli.net/2018/06/24/5b2f1ff8a73bd.png" alt="chenggong.png"></p><h1 id="安装mininet"><a href="#安装mininet" class="headerlink" title="安装mininet"></a>安装mininet</h1><h2 id="使用源码安装mininet"><a href="#使用源码安装mininet" class="headerlink" title="使用源码安装mininet"></a>使用源码安装mininet</h2><p>为了减少之后不必要的麻烦，建议在安装开始前执行：sudo su切换到root用户下并在富强网络下进行安装。<br>1.升级系统</p><blockquote></blockquote><pre><code>apt-get updateapt-get upgrade</code></pre><p>2.安装git（如果你像我一样在之前安装Ryu时我们已经安装过git了，那么请直接跳过此步骤）</p><blockquote></blockquote><pre><code>apt install git</code></pre><p>3.从github上获取源码</p><blockquote></blockquote><pre><code>git clone git://github.com/mininet/mininet</code></pre><p>获取之后可以使用如下命令查看mininet的版本</p><blockquote></blockquote><pre><code>cd mininetcat INSTALL</code></pre><p><img src="https://i.loli.net/2018/06/24/5b2f4c772e56f.png" alt="cat.png"><br>4.确认无误后，安装mininet</p><blockquote></blockquote><pre><code>util/install.sh -a</code></pre><p>当你看到Enjoy Mininet！时，恭喜你已经安装成功了。<br><img src="https://i.loli.net/2018/06/24/5b2f4cb8a6bfc.png" alt="enjoy.png"><br>执行以下命令查看安装版本：</p><blockquote></blockquote><pre><code>mn --version</code></pre><h2 id="mininet可视化操作"><a href="#mininet可视化操作" class="headerlink" title="mininet可视化操作"></a>mininet可视化操作</h2><p>1.要进行mininet可视化操作，需要安装Xmanager套件，然后在通过Xshell远程连接主机时，在属性中做如下设置：<br><img src="https://i.loli.net/2018/06/24/5b2f4a82c2097.png" alt="suidao.png"><br>2.然后进入examples目录，执行miniedit.py即可启动可视化界面</p><blockquote></blockquote><pre><code>cd mininet/mininet/examples./miniedit.py</code></pre><p><img src="https://i.loli.net/2018/06/24/5b2f4cf66b46e.png" alt="可视化.png"><br>至此，整个环境就搭建完成了。<br>如果是桌面版系统并且用apt-get install mininet安装的mininet,目录在/usr / share /doc/mininet/examples,但是其可视化脚本是py.gz格式的，貌似无法使用。</p><p>如果对环境的安装有疑问，欢迎与我联系，一起沟通交流。  </p><blockquote><p>email: <a href="mailto:666@cyne.cf" target="_blank" rel="noopener">666@cyne.cf</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu安装&quot;&gt;&lt;a href=&quot;#Ubuntu安装&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装&quot;&gt;&lt;/a&gt;Ubuntu安装&lt;/h1&gt;&lt;h2 id=&quot;系统选择&quot;&gt;&lt;a href=&quot;#系统选择&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://cyneliu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack入门（三）—— OpenStack架构</title>
    <link href="https://cyneliu.github.io/2018/06/19/OpenStack%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-OpenStack%E6%9E%B6%E6%9E%84/"/>
    <id>https://cyneliu.github.io/2018/06/19/OpenStack入门（三）——-OpenStack架构/</id>
    <published>2018-06-19T11:51:37.000Z</published>
    <updated>2018-06-21T12:43:45.534Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396287488044421.jpg" alt=""></p><h1 id="OpenStack架构"><a href="#OpenStack架构" class="headerlink" title="OpenStack架构"></a>OpenStack架构</h1><p>OpenStack的Conceptual Architecture(概念体系结构)：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396288164018195.jpg" alt=""></p><blockquote><p>中间菱形是虚拟机，围绕 VM 的那些长方形代表 OpenStack 不同的模块（OpenStack 叫服务，后面都用服务这个术语），下面来分别介绍。</p></blockquote><blockquote><p>Nova：管理 VM 的生命周期，是 OpenStack 中最核心的服务。</p></blockquote><blockquote><p>Neutron：为 OpenStack 提供网络连接服务，负责创建和管理L2、L3 网络，为 VM 提供虚拟网络和物理网络连接。</p></blockquote><blockquote><p>Glance：管理 VM 的启动镜像，Nova 创建 VM 时将使用 Glance 提供的镜像。</p></blockquote><blockquote><p>Cinder：为 VM 提供块存储服务。Cinder 提供的每一个 Volume 在 VM 看来就是一块虚拟硬盘，一般用作数据盘。</p></blockquote><blockquote><p>Swift：提供对象存储服务。VM 可以通过 RESTful API 存放对象数据。作为可选的方案，Glance 可以将镜像存放在 Swift 中；Cinder 也可以将 Volume 备份到 Swift 中。</p></blockquote><blockquote><p>Keystone：为 OpenStack 的各种服务提供认证和权限管理服务。简单的说，OpenStack 上的每一个操作都必须通过 Keystone 的审核。</p></blockquote><blockquote><p>Ceilometer：提供 OpenStac k监控和计量服务，为报警、统计或计费提供数据。</p></blockquote><blockquote><p>Horizon：为 OpenStack 用户提供一个 Web 的自服务 Portal。  </p></blockquote><p>OpenStack的Logical Architecture（逻辑体系结构）：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396289980075632.jpg" alt=""></p><h1 id="搭建实验环境"><a href="#搭建实验环境" class="headerlink" title="搭建实验环境"></a>搭建实验环境</h1><p>我们分两个节点进行环境部署：<br>1.devstack-controller：控制节点 + 网络节点 + 块存储节点 + 计算节点<br>2.devstack-compute：计算节点<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160403-1459686062619002987.jpg" alt=""><br>配置要求：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160403-1459686062793065054.jpg" alt=""><br>网络规划：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160404-1459724662268078986.png" alt="network"><br>我们规划了三个网络： </p><p>1.<em>Management Network：</em></p><blockquote><p>用于 OpenStack 内部管理用，比如各服务之间通信。<br>这里使用 eth0        </p></blockquote><p>2.<em>VM（Tenant）Network：</em></p><blockquote><p>OpenStack 部署的虚拟机所使用的网络。<br>OpenStack 支持多租户（Tenant），虚机是放在 Tenant 下的，所以叫 Tenant Network。<br>这里使用 eth1        </p></blockquote><p>3.<em>External Network：</em></p><blockquote><p>一般来说，Tenant Network 是内部私有网络，只用于 VM 之间通信，与其他非 VM 网络是隔离的。<br>这里我们规划了一个外部网络（External Network），通过 devstak-controller 的 eth2 连接。<br>Neutron 通过 L3 服务让 VM 能够访问到 External Network。<br>对于公有云，External Network 一般指的是 Internet。<br>对于企业私有云，External Network 则可以是 Intranet 中的某个网络。 </p></blockquote><h1 id="部署DevStack"><a href="#部署DevStack" class="headerlink" title="部署DevStack"></a>部署DevStack</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396287488044421.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;OpenStack架构&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://cyneliu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack" scheme="https://cyneliu.github.io/tags/OpenStack/"/>
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack入门（二）—— 云计算</title>
    <link href="https://cyneliu.github.io/2018/06/19/OpenStack%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    <id>https://cyneliu.github.io/2018/06/19/OpenStack入门（二）——-云计算/</id>
    <published>2018-06-19T11:31:46.000Z</published>
    <updated>2018-06-19T11:47:01.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>这张图很形象的描述了云计算的基本概念：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160329-1459256505303011231.png" alt="云计算"><br>云平台是一个面向服务的架构，按照提供服务的不同分为 IaaS、PaaS 和 SaaS。<br><img src="http://img.blog.csdn.net/20160329205344575" alt="分类"><br><em>IaaS</em>（Infrastructure as a Service）提供的服务是虚拟机。</p><blockquote><p>IaaS 负责管理虚机的生命周期，包括创建、修改、备份、启停、销毁等。<br>使用者从云平台得到的是一个已经安装好镜像（操作系统+其他预装软件）的虚拟机。<br>使用者需要关心虚机的类型（OS）和配置（CPU、内存、磁盘），并且自己负责部署上层的中间件和应用。<br>IaaS 的使用者通常是数据中心的系统管理员。<br>典型的 IaaS 例子有 AWS、Rackspace、阿里云等。  </p></blockquote><p><em>PaaS</em>（Platform as a Service）提供的服务是应用的运行环境和一系列中间件服务（比如数据库、消息队列等）。</p><blockquote><p>使用者只需专注应用的开发，并将自己的应用和数据部署到PaaS环境中。<br>PaaS负责保证这些服务的可用性和性能。<br>PaaS的使用者通常是应用的开发人员。<br>典型的 PaaS 有 Google App Engine、IBM BlueMix 等  </p></blockquote><p><em>SaaS</em>（Software as a Service）提供的是应用服务。</p><blockquote><p>使用者只需要登录并使用应用，无需关心应用使用什么技术实现，也不需要关系应用部署在哪里。<br>SaaS的使用者通常是应用的最终用户。<br>典型的 SaaS 有 Google Gmail、Salesforce 等</p></blockquote><h1 id="云计算和OpenStack"><a href="#云计算和OpenStack" class="headerlink" title="云计算和OpenStack"></a>云计算和OpenStack</h1><p>OpenStack is a cloud operating system that controls large pools of compute, storage, and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface.  </p><p>以上是官网对 OpenStack 的定义，OpenStack 对数据中心的计算、存储和网络资源进行统一管理。<br>由此可见，OpenStack 针对的是 IT 基础设施，是 IaaS 这个层次的云操作系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;这张图很形象的描述了云计算的基本概念：&lt;br&gt;&lt;img src=&quot;http://7xo6kd.com1.z0.glb.clo
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://cyneliu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack" scheme="https://cyneliu.github.io/tags/OpenStack/"/>
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack入门（一）—— 虚拟化</title>
    <link href="https://cyneliu.github.io/2018/06/06/OpenStack%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://cyneliu.github.io/2018/06/06/OpenStack入门（一）——-虚拟化/</id>
    <published>2018-06-06T11:45:18.000Z</published>
    <updated>2018-06-27T13:04:17.650Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个网络工程专业的大二学生，现在已经临近期末，也就是说马上就要大三了。最近身边的一些事，让我慢慢发现，如果以后只做一个普通的网工，只会敲敲命令行之类的，几乎没有什么前景，而且随着SDN、自动化运维的发展，普通网工的价值也显得越来越低，所以还是觉得应该学点别的东西来武装自己，比如——虚拟化。  </p><p>今天在知乎上看了一些大佬的解答，感觉很受启发，网工可能真的是一个轻松的工作，但一个人的工资总是与创造的价值成正比的。虽然知道OpenStack体系结构复杂，知识涉及面庞大，但还是决定接触一下。所以从今天开始就要入门OpenStack了，也但愿我可以一路坚持下去。</p><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p><img src="https://i.loli.net/2018/06/06/5b17cf7d178cc.jpg" alt="1.jpg"> OpenStack是云操作系统，要学习OpenStack，首先需要掌握一些虚拟化和云计算的相关知识。  </p><blockquote><p>物理机为宿主机Host，虚拟机为客户机Guest<br>宿主机通过Hypervisor程序实现硬件的虚拟化<br>根据实现方式分为1型虚拟化和2型虚拟化  </p></blockquote><h2 id="1型虚拟化"><a href="#1型虚拟化" class="headerlink" title="1型虚拟化"></a>1型虚拟化</h2><p><img src="https://i.loli.net/2018/06/06/5b17e2cc5c425.jpg" alt="1.1.jpg"><br>Hypervisor 直接安装在物理机上，多个虚拟机在 Hypervisor 上运行。</p><h2 id="2型虚拟化"><a href="#2型虚拟化" class="headerlink" title="2型虚拟化"></a>2型虚拟化</h2><p><img src="https://i.loli.net/2018/06/06/5b17e2cc5d990.jpg" alt="1.2.jpg"><br>物理机上首先安装常规的操作系统，Hypervisor 作为 OS 上的一个程序模块运行，并对管理虚拟机进行管理。</p><h1 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://i.loli.net/2018/06/07/5b1919d6162be.png" alt="2.1.png"><br>因为在 x86 平台上最热门运用最广泛的虚拟化方案莫过于 KVM同时OpenStack对KVM支持的最好，所以实验环境选择KVM。  </p><blockquote><p>KVM是2型虚拟化<br>KVM有一个内核模块交kvm.ko，只用于广利虚拟cpu和内存<br>IO如存储和网络的虚拟化由Linux内核和Qemu实现<br>Libvirt简单的说就是KVM的管理工具  </p></blockquote><h2 id="安装KVM"><a href="#安装KVM" class="headerlink" title="安装KVM"></a>安装KVM</h2><p>因为手头没有可以用的Linux系统的主机，所以这里我选择在VMWare虚拟机安装KVM。为了能让 KVM 能创建 嵌套的虚机，要把 CPU 的虚拟化功能打开：<br><img src="https://i.loli.net/2018/06/07/5b1921f5d79c7.jpg" alt="2.2.jpg"><br>Ubuntu启动后，用一下命令确认cpu支持虚拟化：  </p><blockquote></blockquote><pre><code># egrep -o &apos;(vmx|svm)&apos; /proc/cpuinfo# vmx  </code></pre><p>确认 Libvirtd 服务已经启动:</p><blockquote></blockquote><pre><code># service libvirt-bin statuslibvirt-bin start/running, process 1478  </code></pre><p>到这里KVM准备就绪。</p><h2 id="几个小问题"><a href="#几个小问题" class="headerlink" title="几个小问题"></a>几个小问题</h2><p>我在安装环境的时候遇到了以下两个小问题：  </p><blockquote><p>1.未发现软件包<br><img src="https://i.loli.net/2018/06/08/5b1a9434c5b2c.png" alt="q1.png"><br>解决方法很简单，在命令行下执行： </p></blockquote><pre><code>sudo apt-get update </code></pre><blockquote><p>更新apt的资源列表即可解决  </p><p>2.ssh无法启动<br><img src="https://i.loli.net/2018/06/08/5b1a9434ba868.png" alt="q2.png"><br>这个主要是因为我安装的Ubuntu在安装时并没有安装ssh-server，执行：</p></blockquote><pre><code>sudo apt-get install openssh-server</code></pre><blockquote><p>安装ssh服务端程序即可解决。  </p><p>3.Ubuntu缺少管理员权限无法打开文件</p><p>这个问题也是我用Ubuntu感觉不太方便的地方，百度了以下可以安装这个：</p></blockquote><pre><code>sudo apt-get install nautilus-open-terminal</code></pre><blockquote><p>重启后，打开想要打开的目录执行：</p></blockquote><pre><code>sudo nautilus</code></pre><blockquote></blockquote><h1 id="启动第一个KVM虚拟机"><a href="#启动第一个KVM虚拟机" class="headerlink" title="启动第一个KVM虚拟机"></a>启动第一个KVM虚拟机</h1><h2 id="启动虚机"><a href="#启动虚机" class="headerlink" title="启动虚机"></a>启动虚机</h2><p><img src="https://i.loli.net/2018/06/08/5b1a9434c3dc3.jpg" alt="3.jpg"><br>环境搭好，这个步骤就很简单了。要做笔记的可能就是博主推荐的用来测试效果的超轻量级的Linux系统cirros了，镜像文件只有几十兆。<br>这是我的第一个KVM——kvm1，截个图纪念一下：<br><img src="https://i.loli.net/2018/06/08/5b1a9434c8ec6.png" alt="result.png"><br>另外除了用virt-manager对虚机进行各种管理操作，也可以使用命令 virsh管理虚机，比如查看宿主机上的虚机：</p><blockquote></blockquote><pre><code>root@ubuntu:~# virsh listId    Name              State--------------------------------8     kvm1              running  </code></pre><h2 id="远程管理虚机"><a href="#远程管理虚机" class="headerlink" title="远程管理虚机"></a>远程管理虚机</h2><p><img src="https://i.loli.net/2018/06/09/5b1b27716ddac.jpg" alt="4.jpg"><br>virt-manager也可以管理其它宿主机上的虚机，只需要将其添加进来就可以进行远程管理。<br>因为 KVM（准确说是 Libvirt）默认不接受远程管理，需要按下面的内容配置被管理宿主机中的两个文件：<br><em>/etc/default/libvirt-bin</em></p><blockquote><p>start_libvirtd=”yes”<br>libvirtd_opts=”-d -l”</p></blockquote><p><em>/etc/libvirt/libvirtd.conf</em></p><blockquote><p>listen_tls = 0<br>listen_tcp = 1<br>unix_sock_group = “libvirtd”<br>unix_sock_ro_perms = “0777”<br>unix_sock_rw_perms = “0770”<br>auth_unix_ro = “none”<br>auth_unix_rw = “none”<br>auth_tcp = “none”   </p></blockquote><p>然后重启 Libvirtd 服务就可以远程管理了。  </p><blockquote><p>service libvirt-bin restart  </p></blockquote><h1 id="KVM虚拟化原理"><a href="#KVM虚拟化原理" class="headerlink" title="KVM虚拟化原理"></a>KVM虚拟化原理</h1><p><img src="https://i.loli.net/2018/06/09/5b1b2969e2d27.jpg" alt="01.jpg"></p><h2 id="cpu虚拟化"><a href="#cpu虚拟化" class="headerlink" title="cpu虚拟化"></a>cpu虚拟化</h2><p>虚机中的每一个虚拟 vCPU 则对应 qemu-kvm 进程中的一个线程。<br><img src="https://i.loli.net/2018/06/09/5b1b2a550e50b.jpg" alt="4.1.jpg"><br>在这个例子中，宿主机有两个物理 CPU，上面起了两个虚机 VM1 和 VM2。<br>VM1 有两个 vCPU，VM2 有 4 个 vCPU。可以看到 VM1 和 VM2 分别有两个和 4 个线程在两个物理 CPU 上调度。<br>这里也演示了另一个知识点，即虚机的 vCPU 总数可以超过物理 CPU 数量，这个叫 CPU overcommit（超配）。<br>KVM 允许 overcommit，这个特性使得虚机能够充分利用宿主机的 CPU 资源，但前提是在同一时刻，不是所有的虚机都满负荷运行。<br>当然，如果每个虚机都很忙，反而会影响整体性能，所以在使用 overcommit 的时候，需要对虚机的负载情况有所了解，需要测试。</p><h2 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h2><p>KVM 通过内存虚拟化共享物理系统内存，动态分配给虚拟机。<br><img src="https://i.loli.net/2018/06/09/5b1b4479be961.jpg" alt="m.jpg"><br>为了在一台机器上运行多个虚拟机，KVM 需要实现 VA（虚拟内存） -&gt; PA（物理内存） -&gt; MA（机器内存）直接的地址转换。虚机 OS 控制虚拟地址到客户内存物理地址的映射 （VA -&gt; PA），但是虚机 OS 不能直接访问实际机器内存，因此 KVM 需要负责映射客户物理内存到实际机器内存 （PA -&gt; MA）。内存也是可以 overcommit 的，即所有虚机的内存之和可以超过宿主机的物理内存。但使用时也需要充分测试，否则性能会受影响。</p><h2 id="存储虚拟化"><a href="#存储虚拟化" class="headerlink" title="存储虚拟化"></a>存储虚拟化</h2><p>KVM 的存储虚拟化是通过存储池（Storage Pool）和卷（Volume）来管理的。<br>Storage Pool 是宿主机上可以看到的一片存储空间，可以是多种类型，后面会详细讨论。Volume 是在 Storage Pool 中划分出的一块空间，宿主机将 Volume 分配给虚拟机，Volume 在虚拟机中看到的就是一块硬盘。</p><h3 id="目录类型的-Storage-Pool"><a href="#目录类型的-Storage-Pool" class="headerlink" title="目录类型的 Storage Pool"></a>目录类型的 Storage Pool</h3><p>文件目录是最常用的 Storage Pool 类型。<br>KVM 将宿主机目录 /var/lib/libvirt/images/ 作为默认的 Storage Pool。<br>那么 Volume 是什么呢？答案就是该目录下面的文件了，一个文件就是一个 Volume。  </p><blockquote><p>为虚机 kvm1 添加一个新的磁盘，看看有什么变化。<br>在 virt-manager 中打开 kvm1 的配置页面，右键添加新硬件<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160313-1457875038029032821.jpg" alt=""><br>在默认 Pool 中创建一个 8G 的卷。<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160313-1457875038314009772.jpg" alt=""><br>然后发现在 /var/lib/libvirt/images/ 下多了一个 8G 的文件 kvm1.img  </p></blockquote><p>使用文件做 Volume 有很多优点：存储方便、移植性好、可复制、可远程访问。前面几个优点都很好理解，这里对“可远程访问”多解释一下。远程访问的意思是镜像文件不一定都放置到宿主机本地文件系统中，也可以存储在通过网络连接的远程文件系统，比如 NFS，或者是分布式文件系统中，比如 GlusterFS。这样镜像文件就可以在多个宿主机之间共享，便于虚机在不同宿主机之间做 Live Migration；如果是分布式文件系统，多副本的特性还可以保证镜像文件的高可用。<br>KVM 支持多种 Volume 文件格式，在添加 Volume 时可以选择：</p><blockquote><p>raw 是默认格式，即原始磁盘镜像格式，移植性好，性能好，但大小固定，不能节省磁盘空间。<br>qcow2 是推荐使用的格式，cow 表示 copy on write，能够节省磁盘空间，支持 AES 加密，支持 zlib 压缩，支持多快照，功能很多。<br>vmdk 是 VMWare 的虚拟磁盘格式，也就是说 VMWare 虚机可以直接在 KVM上 运行。</p></blockquote><h3 id="LVM类型的Storage-Pool"><a href="#LVM类型的Storage-Pool" class="headerlink" title="LVM类型的Storage Pool"></a>LVM类型的Storage Pool</h3><p>宿主机上 VG 中的 LV 也可以作为虚拟磁盘分配给虚拟机使用。<br>不过，LV 由于没有磁盘的 MBR 引导记录，不能作为虚拟机的启动盘，只能作为数据盘使用。<br>补充几个概念：</p><blockquote><p>逻辑卷管理器—–LVM（Logicl Volume Manager）  </p><blockquote><p>通过使用逻辑卷管理器对硬盘存储设备进行管理，可以实现硬盘空间的动态划分和调整。</p></blockquote><p>物理卷—–PV（Physical Volume）  </p><blockquote><p>物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘。 </p></blockquote></blockquote><p>卷组——–VG（Volumne Group）  </p><blockquote><blockquote><p>卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。</p></blockquote><p>逻辑卷—–LV（Logical Volume）</p><blockquote></blockquote><p>逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。  </p></blockquote><p>这种配置下，宿主机上的 VG 就是一个 Storage Pool，VG 中的 LV 就是 Volume。<br>LV 的优点是有较好的性能；不足的地方是管理和移动性方面不如镜像文件，而且不能通过网络远程使用。</p><h3 id="其他类型的Storage-Pool"><a href="#其他类型的Storage-Pool" class="headerlink" title="其他类型的Storage Pool"></a>其他类型的Storage Pool</h3><p>KVM 还支持 iSCSI，Ceph 等多种类型的 Storage Pool。</p><h2 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h2><p><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160317-1458221777139021452.jpg" alt="4.4"><br>下面这个图是OpenStack官网给出的计算节点（可以理解为 KVM 的宿主机）虚拟网络的逻辑图：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160317-1458221777406075614.jpg" alt="4.4.0"></p><h3 id="Linux-Bridge"><a href="#Linux-Bridge" class="headerlink" title="Linux Bridge"></a>Linux Bridge</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>给 VM1 分配一个虚拟网卡 vnet0，通过 Linux Bridge  br0 将 eth0 和 vnet0 连接起来，如下图所示:<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160317-1458221778960074364.png" alt=""><br>Linux Bridge 是 Linux 上用来做 TCP/IP 二层协议交换的设备，其功能大家可以简单的理解为是一个二层交换机或者 Hub。多个网络设备可以连接到同一个 Linux Bridge，当某个设备收到数据包时，Linux Bridge 会将数据转发给其他设备。<br>在上面这个例子中，当有数据到达 eth0 时，br0 会将数据转发给 vnet0，这样 VM1 就能接收到来自外网的数据；反过来，VM1 发送数据给 vnet0，br0 也会将数据转发到 eth0，从而实现了 VM1 与外网的通信。<br>现在我们增加一个虚机 VM2，如下图所示:<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160317-1458221779001036894.png" alt=""><br>VM2 的虚拟网卡 vnet1 也连接到了 br0 上。<br>现在 VM1 和 VM2 之间可以通信，同时 VM1 和 VM2 也都可以与外网通信。</p><h4 id="动手实践虚拟网络"><a href="#动手实践虚拟网络" class="headerlink" title="动手实践虚拟网络"></a>动手实践虚拟网络</h4><h5 id="配置Linux-Bridge-br0"><a href="#配置Linux-Bridge-br0" class="headerlink" title="配置Linux Bridge br0"></a>配置Linux Bridge br0</h5><p>有两点需要注意：  </p><blockquote><p>1.之前宿主机的 IP 是通过 dhcp 配置在 eth0 上的；创建 Linux Bridge 之后，IP 就必须放到 br0 上了<br>2.在 br0 的配置信息中请注意最后一行 “bridge_ports eth0”，其作用就是将 eth0 挂到 br0 上</p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>配置过程很简单，有一个影响不大的小问题是我的interfaces文件不太一样，不过按照博主的配置，虽然写的多了一点，但不影响效果。<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160319-1458396234852047669.jpg" alt=""><br>最后附一张成功的截图，学习的乐趣也就在于这种满足感吧，哈哈。<br><img src="https://i.loli.net/2018/06/11/5b1e7bb8b2a03.png" alt="snipaste_20180611_213328.png"></p><h4 id="理解virbr0"><a href="#理解virbr0" class="headerlink" title="理解virbr0"></a>理解virbr0</h4><blockquote><p>1.virbr0 是 KVM 默认创建的一个 Bridge，其作用是为连接其上的虚机网卡提供 NAT 访问外网的功能。<br>2.virbr0 默认分配了一个IP 192.168.122.1，并为连接其上的其他虚拟网卡提供 DHCP 服务。<br>3.使用 NAT 的虚机 VM1 可以访问外网，但外网无法直接访问 VM1。</p></blockquote><h3 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h3><p><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160324-1458779560823058198.jpg" alt=""><br>eth0 是宿主机上的物理网卡，有一个命名为 eth0.10 的子设备与之相连。<br>eth0.10 就是 VLAN 设备了，其 VLAN ID 就是 VLAN 10。<br>eth0.10 挂在命名为 brvlan10 的 Linux Bridge 上，虚机 VM1 的虚拟网卡 vent0 也挂在 brvlan10 上。 </p><p>这样的配置其效果就是：  </p><blockquote><p>宿主机用软件实现了一个交换机（当然是虚拟的），上面定义了一个 VLAN10。<br>eth0.10，brvlan10 和 vnet0 都分别接到 VLAN10 的 Access口上。而 eth0 就是一个 Trunk 口。<br>VM1 通过 vnet0 发出来的数据包会被打上 VLAN10 的标签。  </p></blockquote><p>eth0.10 的作用是：定义了 VLAN10<br>brvlan10 的作用是：Bridge 上的其他网络设备自动加入到 VLAN10 中  </p><p>配置上图的实验环境后，测试KVM1和KVM2的连通性结果如下：<br><img src="https://i.loli.net/2018/06/19/5b28e7c40b35c.png" alt="snipaste_20180619_191904.png"></p><h3 id="Linux-Bridge-VLAN-虚拟交换机"><a href="#Linux-Bridge-VLAN-虚拟交换机" class="headerlink" title="Linux Bridge + VLAN = 虚拟交换机"></a>Linux Bridge + VLAN = 虚拟交换机</h3><p>现在对 KVM 的网络虚拟化做个总结。  </p><blockquote><p>1.物理交换机存在多个 VLAN，每个 VLAN 拥有多个端口。<br>同一 VLAN 端口之间可以交换转发，不同 VLAN 端口之间隔离。<br>所以交换机其包含两层功能：交换与隔离。<br>2.Linux 的 VLAN 设备实现的是隔离功能，但没有交换功能。<br>一个 VLAN 母设备（比如 eth0）不能拥有两个相同 ID 的 VLAN 子设备，因此也就不可能出现数据交换情况。<br>3.Linux Bridge 专门实现交换功能。将同一 VLAN 的子设备都挂载到一个 Bridge 上，设备之间就可以交换数据了。  </p></blockquote><p>总结起来，Linux Bridge 加 VLAN 在功能层面完整模拟现实世界里的二层交换机。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个网络工程专业的大二学生，现在已经临近期末，也就是说马上就要大三了。最近身边的一些事，让我慢慢发现，如果以后只做一个普通的网工，只会敲敲命令行之类的，几乎没有什么前景，而且随着SDN、自动化运维的发展，普通网工的价值也显得越来越低，所以还是觉得应该学点别的东西来武装自
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://cyneliu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack" scheme="https://cyneliu.github.io/tags/OpenStack/"/>
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>基于阿卡信自建聊天服务器</title>
    <link href="https://cyneliu.github.io/2018/06/03/%E5%9F%BA%E4%BA%8E%E9%98%BF%E5%8D%A1%E4%BF%A1%E8%87%AA%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://cyneliu.github.io/2018/06/03/基于阿卡信自建聊天服务器/</id>
    <published>2018-06-03T01:55:23.000Z</published>
    <updated>2018-06-03T02:46:34.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装JAVA和MAVEN环境"><a href="#一、安装JAVA和MAVEN环境" class="headerlink" title="一、安装JAVA和MAVEN环境"></a>一、安装JAVA和MAVEN环境</h1><p>这两个安装很简单，网上一大把的教程，因为我手头可用的只有一个Windows Server，所以这里只演示Win版的安装配置过程。</p><blockquote><p>①首先在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre10-downloads-4417026.html" target="_blank" rel="noopener">ORACLE官网</a>下载jre，然后直接运行安装就可以。<br>②同样，在<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">maven官网</a>下载maven的压缩包，具体的安装配置过程可以参考CSDN博主的<a href="https://blog.csdn.net/h312387398/article/details/79136960" target="_blank" rel="noopener">教程</a>。<br>③安装成功后，在cmd命令行分别用一下两条命令测试是否正确安装配置：</p><blockquote><p>java -version<br>mvn -v</p></blockquote></blockquote><h1 id="二、安装Akaxin服务端程序"><a href="#二、安装Akaxin服务端程序" class="headerlink" title="二、安装Akaxin服务端程序"></a>二、安装Akaxin服务端程序</h1><p>在<a href="https://github.com/akaxincom/openzaly/blob/master/README.md" target="_blank" rel="noopener">Github</a>下载官方提供的jar包，并移动到C盘目录下，在cmd中首先切换到本目录：cd C:\ <img src="https://i.loli.net/2018/06/03/5b1352a48dbf1.png" alt="aaa.png"><br>然后直接运行jar包：java -jar openzaly-server.jar 然后看到提示就说明启动成功了。</p><h1 id="三、安装客户端程序连接使用"><a href="#三、安装客户端程序连接使用" class="headerlink" title="三、安装客户端程序连接使用"></a>三、安装客户端程序连接使用</h1><p>最后就是下载客户端程序了，在<a href="https://www.akaxin.com/" target="_blank" rel="noopener">官网</a>下载客户端程序后，输入服务器ip地址就可以正常使用了。<br><img src="https://i.loli.net/2018/06/03/5b1354ced508f.jpg" alt="QQ图片20180603103858.jpg">这里需要注意的是，首个成员需要输入邀请码：000000进入，这样就会默认成为站点的管理员并提供管理权限。</p><h1 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h1><p>我在配置完成之后遇到一个问题就是用客户端连接服务器的时候提示：请稍后重试，解决的办法是在服务器的安全组策略中放行：2021/2021端口。<br><img src="https://i.loli.net/2018/06/03/5b1355a46befb.png" alt="snipaste_20180603_104228.png"></p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>阿卡信官网：<a href="https://www.akaxin.com/" target="_blank" rel="noopener">https://www.akaxin.com/</a><br>Github项目：<a href="https://github.com/akaxincom/openzaly" target="_blank" rel="noopener">https://github.com/akaxincom/openzaly</a><br>码云：<a href="https://gitee.com/akaxin/openzaly" target="_blank" rel="noopener">https://gitee.com/akaxin/openzaly</a><br>QQ群：655249600</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装JAVA和MAVEN环境&quot;&gt;&lt;a href=&quot;#一、安装JAVA和MAVEN环境&quot; class=&quot;headerlink&quot; title=&quot;一、安装JAVA和MAVEN环境&quot;&gt;&lt;/a&gt;一、安装JAVA和MAVEN环境&lt;/h1&gt;&lt;p&gt;这两个安装很简单，网上一大把
      
    
    </summary>
    
      <category term="Server" scheme="https://cyneliu.github.io/categories/Server/"/>
    
    
      <category term="聊天服务器" scheme="https://cyneliu.github.io/tags/%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="阿卡信" scheme="https://cyneliu.github.io/tags/%E9%98%BF%E5%8D%A1%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>专治疑难杂症</title>
    <link href="https://cyneliu.github.io/2018/05/30/%E4%B8%93%E6%B2%BB%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    <id>https://cyneliu.github.io/2018/05/30/专治疑难杂症/</id>
    <published>2018-05-30T12:50:21.000Z</published>
    <updated>2018-09-11T08:04:18.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加开机启动项"><a href="#添加开机启动项" class="headerlink" title="添加开机启动项"></a>添加开机启动项</h1><p>因为电脑装了某管家，不知道哪天自己把我的开机启动项给关了，只能手动添加回去，之前用的计划任务并不好用，今天知道了一个简单办法。<br>Windows有专门的启动目录，只要把想要开机启动的应用的快捷方式复制进去就可以了。<br>开机启动目录：</p><blockquote></blockquote><pre><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code></pre><p>当然，有可能你根本找不到这个路径，只要把以上地址复制到地址栏，回车访问即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;添加开机启动项&quot;&gt;&lt;a href=&quot;#添加开机启动项&quot; class=&quot;headerlink&quot; title=&quot;添加开机启动项&quot;&gt;&lt;/a&gt;添加开机启动项&lt;/h1&gt;&lt;p&gt;因为电脑装了某管家，不知道哪天自己把我的开机启动项给关了，只能手动添加回去，之前用的计划任务并不好用
      
    
    </summary>
    
      <category term="疑难杂症" scheme="https://cyneliu.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="疑难杂症" scheme="https://cyneliu.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>自建ssr服务器</title>
    <link href="https://cyneliu.github.io/2018/05/07/%E8%87%AA%E5%BB%BAssr%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://cyneliu.github.io/2018/05/07/自建ssr服务器/</id>
    <published>2018-05-07T13:09:20.000Z</published>
    <updated>2018-06-03T02:46:41.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VPS购买"><a href="#VPS购买" class="headerlink" title="VPS购买"></a>VPS购买</h1><p><img src="https://i.loli.net/2018/05/07/5af051641868c.png" alt="vpsAO">昨天晚上看见了一个便宜的VPS没怎么想就买了，毕竟3.5刀一年，虽然平时对富强上网需求不是特别大，但是想借着这个便宜主机了解一下SSR的搭建使用，所以这点钱花的还是很值的我自己觉得。当然便宜也就意味着配置不会好了，96M内存，不过做SSR足够了。</p><h1 id="SSR安装部署"><a href="#SSR安装部署" class="headerlink" title="SSR安装部署"></a>SSR安装部署</h1><p>在这之前就有过搭建SSR的想法，所以当时找了一个比较不错的教程，写的比较详细，毕竟搭建SSR还是比较傻瓜的，没什么难度，按照提示写参数就行，教程地址：<a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">点这里</a>。<br>唯一的一个遗憾就是我买的这个VPS不支持教程里说的谷歌BBR加速，而且不知道是不是因为这个原因，我做出来的这个SSR延迟还是比较高的。如图：<br><img src="https://i.loli.net/2018/05/07/5af0549490164.png" alt="网速测试.png"><br>当然，网速还是不太稳定的，下午测试的时候是1M左右，晚上就到6.9M了，不过这也都无所谓了。</p><h1 id="SSR客户端"><a href="#SSR客户端" class="headerlink" title="SSR客户端"></a>SSR客户端</h1><p>最后附上Win和Android端的客户端  </p><blockquote><p>Windows：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank" rel="noopener">下载地址</a><br>Android：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases/download/3.4.0.8/shadowsocksr-release.apk" target="_blank" rel="noopener">下载地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VPS购买&quot;&gt;&lt;a href=&quot;#VPS购买&quot; class=&quot;headerlink&quot; title=&quot;VPS购买&quot;&gt;&lt;/a&gt;VPS购买&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/05/07/5af051641868c.png&quot;
      
    
    </summary>
    
      <category term="Server" scheme="https://cyneliu.github.io/categories/Server/"/>
    
    
      <category term="Server" scheme="https://cyneliu.github.io/tags/Server/"/>
    
      <category term="SSR" scheme="https://cyneliu.github.io/tags/SSR/"/>
    
  </entry>
  
</feed>
