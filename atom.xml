<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyne&#39;s Blog</title>
  
  <subtitle>越努力，越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cyneliu.github.io/"/>
  <updated>2019-03-28T03:35:17.934Z</updated>
  <id>https://cyneliu.github.io/</id>
  
  <author>
    <name>Cyne Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cisco配置VPN IPSec</title>
    <link href="https://cyneliu.github.io/2019/03/28/Cisco%E9%85%8D%E7%BD%AEVPN-IPSec/"/>
    <id>https://cyneliu.github.io/2019/03/28/Cisco配置VPN-IPSec/</id>
    <published>2019-03-28T02:09:29.000Z</published>
    <updated>2019-03-28T03:35:17.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2019/03/28/5c9c3006a1ccd.png" alt="00.png"></p><h1 id="配置运营商网络"><a href="#配置运营商网络" class="headerlink" title="配置运营商网络"></a>配置运营商网络</h1><p>在配置VPN之前，首先要保证模拟的运营商网络是可以正常通信的，这里我配置的是OSPF，需要注意的是两边的路由器不要把内网网段也给宣告出去了，如果是这样那VPN也就没有存在的意义了。<br>首先是左边的R1：</p><blockquote></blockquote><pre><code>Router(config)#int f0/0Router(config-if)#ip add 202.1.1.1 255.255.255.0Router(config-if)#no shutRouter(config-if)#exitRouter(config)#router ospf 1Router(config-router)#net 202.1.1.0 0.0.0.255 area 0</code></pre><p>中间的R0：</p><blockquote></blockquote><pre><code>Router(config)#int f0/0Router(config-if)#ip add 202.1.1.254 255.255.255.0Router(config-if)#no shutRouter(config)#int f0/1Router(config-if)#ip add 210.1.1.254 255.255.255.0Router(config-if)#no shutRouter(config-if)#exitRouter(config)#router ospf 1Router(config-router)#net 202.1.1.0 0.0.0.255 area 0Router(config-router)#net 210.1.1.0 0.0.0.255 area 0</code></pre><p>右边的R2：</p><blockquote></blockquote><pre><code>Router(config)#int f0/0Router(config-if)#ip add 210.1.1.1 255.255.255.0Router(config-if)#no shutRouter(config-if)#exitRouter(config)#router ospf 1Router(config-router)#net 210.1.1.0 0.0.0.255 area 0</code></pre><p>等待收敛完成验证网络是否可以正常通信。</p><h1 id="配置内网"><a href="#配置内网" class="headerlink" title="配置内网"></a>配置内网</h1><p>内网过于简单这里不再赘述，我的左边的区域1的网段是10.0.1.0/24，右边的区域2是10.0.2.0/24，网关则分别为1.1和2.1。</p><h1 id="配置IPSec-site-to-site"><a href="#配置IPSec-site-to-site" class="headerlink" title="配置IPSec(site to site)"></a>配置IPSec(site to site)</h1><p>R1:</p><blockquote></blockquote><pre><code>Router(config)#crypto isakmp enable #启用IKE,默认即为启动Router(config)#crypto isakmp policy 1 #定义IKE安全策略集1Router(config-isakmp)#authentication pre-share #IKE验证方式胃预共享密钥Router(config-isakmp)#encryption 3des #IKE加密方式为3desRouter(config-isakmp)#group 1 #IKE使用Diffie-Hellman组1Router(config-isakmp)#hash md5 #IKE的Hash验证为MD5Router(config-isakmp)#exitRouter(config)#crypto isakmp key cyne address 210.1.1.1 #两端的KEY必须一致，210.1.1.1是对端的公网地址Router(config)#crypto ipsec transform-set lab ah-md5-hmac esp-3des #定义VPN使用IPSec策略集，lab为策略集名称Router(config)#access-list 100 permit ip 10.0.1.0 0.0.0.255 10.0.2.0 0.0.0.255 #定义在R1上需要加密的流量Router(config)#crypto map test 110 ipsec-isakmp #定义加密图Router(config-crypto-map)#match address 100 #在加密图中声明加密流量列表Router(config-crypto-map)#set peer 210.1.1.1 #对端公网ipRouter(config-crypto-map)#set transform-set lab #在加密图中调用IPSec的策略集labRouter(config-crypto-map)#exitRouter(config)#int f1/0Router(config-if)#crypto map test #将加密图应用到此端口Router(config-if)#exit Router(config)#ip route 10.0.2.0 255.255.255.0 f0/0 #指定VPN的静态路由</code></pre><p>R2:</p><blockquote></blockquote><pre><code>Router(config)#crypto isakmp enableRouter(config)#crypto isakmp policy 1Router(config-isakmp)#authentication pre-share Router(config-isakmp)#encryption 3desRouter(config-isakmp)#group 1Router(config-isakmp)#hash md5Router(config-isakmp)#exitRouter(config)#crypto isakmp key cyne address 202.1.1.1 #两端的KEY必须一致，202.1.1.1是对端的公网地址Router(config)#crypto ipsec transform-set lab ah-md5-hmac esp-3desRouter(config)#access-list 100 permit ip 10.0.2.0 0.0.0.255 10.0.1.0 0.0.0.255Router(config)#crypto map test 110 ipsec-isakmp Router(config-crypto-map)#match address 100 Router(config-crypto-map)#set peer 202.1.1.1 #对端公网ipRouter(config-crypto-map)#set transform-set labRouter(config-crypto-map)#exitRouter(config)#int f0/0Router(config-if)#crypto map testRouter(config-if)#exit Router(config)#ip route 10.0.1.0 255.255.255.0 f0/0</code></pre><h1 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h1><p>使用区域1内的PC ping 区域2中的PC，发现已经可以通信：<br><img src="https://i.loli.net/2019/03/28/5c9c3cfee86a3.png" alt="01.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://wenku.baidu.com/view/aec4df5a5727a5e9856a61eb" target="_blank" rel="noopener">https://wenku.baidu.com/view/aec4df5a5727a5e9856a61eb</a><br><a href="http://www.solves.com.cn/doc-view-2025.html" target="_blank" rel="noopener">http://www.solves.com.cn/doc-view-2025.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验拓扑&quot;&gt;&lt;a href=&quot;#实验拓扑&quot; class=&quot;headerlink&quot; title=&quot;实验拓扑&quot;&gt;&lt;/a&gt;实验拓扑&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/28/5c9c3006a1ccd.png&quot; alt
      
    
    </summary>
    
      <category term="网络" scheme="https://cyneliu.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Cisco" scheme="https://cyneliu.github.io/tags/Cisco/"/>
    
      <category term="VPN" scheme="https://cyneliu.github.io/tags/VPN/"/>
    
      <category term="IPSec" scheme="https://cyneliu.github.io/tags/IPSec/"/>
    
  </entry>
  
  <entry>
    <title>在ESXI环境中部署fuel openstack虚拟环境</title>
    <link href="https://cyneliu.github.io/2019/03/20/%E5%9C%A8ESXI%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%83%A8%E7%BD%B2fuel-openstack%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://cyneliu.github.io/2019/03/20/在ESXI环境中部署fuel-openstack虚拟环境/</id>
    <published>2019-03-20T12:02:15.000Z</published>
    <updated>2019-03-26T01:10:14.866Z</updated>
    
    <content type="html"><![CDATA[<p>一年之前就开始接触OpenStack，但是还没入门就放弃了，因为实验环境实在是太难装了，尝试了很多次均以失败告终，大多教程中都是安装devstack的方式进行部署，但是作为一个刚入门的小白，个人觉得这种方式可能并不是太友好。最近看了一份教程，了解到fuel openstack的部署方式，决定再尝试一下，据说这也是企业生产环境中经常用到的方式。<br>由于自己的电脑配置比较低，在笔记本上安装虚拟环境体验不是很好，正好身边有一套ESXI环境，所以尝试在ESXI环境中进行部署，尝试了很多次之后终于成功，在此记录一下部署过程，以供参考。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先下载fuel openstack镜像文件，主要有两个途径可以获取到fuel的镜像，第一个是fuel的官网，目前可以下载到9.0的版本。第二个是OpenStack的wiki，目前提供的最新版本是11.0：</p><blockquote></blockquote><p><a href="https://www.mirantis.com/software/openstack/" target="_blank" rel="noopener">https://www.mirantis.com/software/openstack/</a><br><a href="https://wiki.openstack.org/wiki/Fuel#Where_to_get_Fuel" target="_blank" rel="noopener">https://wiki.openstack.org/wiki/Fuel#Where_to_get_Fuel</a></p><h1 id="规划网络"><a href="#规划网络" class="headerlink" title="规划网络"></a>规划网络</h1><p>我的esxi主机所在网络为192.168.100.0/24网段，此网段对OpenStack来说也就是公网（Public），此外还需要有一个PXE网段，用于fuel部署系统，此外还有management、storage、private等网段，我们使用三块网卡来连接这三个网段。</p><h2 id="在ESXI中部署网络"><a href="#在ESXI中部署网络" class="headerlink" title="在ESXI中部署网络"></a>在ESXI中部署网络</h2><p>首先是创建两个新的虚拟交换机，选中esxi主机，点击配置，网络，添加网络：<br><img src="https://i.loli.net/2019/03/21/5c9394143c777.png" alt="01.png"><br>连接类型选择虚拟机：<br><img src="https://i.loli.net/2019/03/21/5c93948b28789.png" alt="02.png"><br>选择创建vSphere标准交换机，将下面的网卡取消勾选：<br><img src="https://i.loli.net/2019/03/21/5c9394ff6c53d.png" alt="03.png"><br>网络标签可以自行修改，vlan id选择全部：<br><img src="https://i.loli.net/2019/03/21/5c93955b01f35.png" alt="04.png"><br>编辑vSwitch属性，开启混杂模式：<br><img src="https://i.loli.net/2019/03/21/5c9395965b223.png" alt="05.png"><br>要注意左边列表中的两项都要开启<br><img src="https://i.loli.net/2019/03/21/5c939596595d3.png" alt="06.png"><br>用相同的方法再创建一个vSwitch，我这里分别是fuel_pxe和fuel_private：<br><img src="https://i.loli.net/2019/03/21/5c9394143c777.png" alt="01.png"><br>最后再修改以下vSwitch0的属性，修改如下两项：<br><img src="https://i.loli.net/2019/03/26/5c99754ebeec5.png" alt="31.png"><br><img src="https://i.loli.net/2019/03/26/5c99754ed633c.png" alt="32.png"></p><h1 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h1><p>fuel的架构如下图所示：<br><img src="https://i.loli.net/2019/03/21/5c93976f857b9.png" alt="09.png"><br>这里我没有部署单独的Storage节点，只部署三个节点：master、controller和compute，三个节点的配置及网卡连接情况如下：  </p><blockquote><p>master节点：</p><blockquote><p>8核 8G内存 100G存储 fuel_pxe vmnet vmnet</p></blockquote></blockquote><blockquote><p>controller节点：</p><blockquote><p>8核 8G内存 100G存储 fuel_pxe vmnet fuel_private</p></blockquote></blockquote><blockquote><p>compute节点</p><blockquote><p>8核 16G内存 200G存储 fuel_pxe vmnet fuel_private</p></blockquote></blockquote><h2 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h2><p>新建名称为fuel_master的虚拟机,网卡配置如下图所示：<br><img src="https://i.loli.net/2019/03/21/5c9395966aa1c.png" alt="07.png"><br>开机并挂载fuel镜像：<br><img src="https://i.loli.net/2019/03/21/5c939597b4d7e.png" alt="08.png"><br>选择第一项直接开始安装，安装时间较长，耐心等待其安装完成。<br>安装完成后登录master节点，修改一些配置，首先是配置一个我们可以连接的ip，默认情况下eth0的ip地址已经设置为10.20.0.2，我这里选择使用eth1进行修改：</p><blockquote></blockquote><pre><code>vim /etc/sysconfig/network-scrips/eth1</code></pre><p>将配置文件中的ONBOOT=no改为yes,ip地址我这里使用的是dhcp分配的方式，当然你也可以手工指定。<br>修改完成后保存退出并重启网络:</p><blockquote></blockquote><pre><code>service network restart</code></pre><p>然后允许ssh登录，默认情况下是只允许10.20.0.0/24这个网段登录的：</p><blockquote></blockquote><pre><code>iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPTservice iptables saveservice iptables restart</code></pre><p>查看eth1的ip地址，这时我们就可以使用eth1的ip访问mater的web界面了(浏览器通常会阻止访问，点击继续访问或添加例外即可)：<br><img src="https://i.loli.net/2019/03/22/5c943671a130c.png" alt="11.png"><br>使用默认用户名/密码：admin/admin登录，登录进去之后会提示修改密码，暂时先不修改。此外因为安装时master节点并没有连接外网，所以这时会有如下提示信息：<br><img src="https://i.loli.net/2019/03/22/5c94373142e10.png" alt="10.png"><br>有以下两种解决方式：</p><h3 id="联网方式"><a href="#联网方式" class="headerlink" title="联网方式"></a>联网方式</h3><p>根据提示信息执行命令：</p><blockquote></blockquote><pre><code>fuel-bootstrap build --activate</code></pre><p>这种方式的前提是master节点可以连接到外网，而且根据网络环境的不同可能时间会比较长。另外这条命令在11.0的版本可以正常使用，而在9.0版本中貌似有些源已经访问不到了，所以推荐使用本地源。</p><h3 id="本地方式"><a href="#本地方式" class="headerlink" title="本地方式"></a>本地方式</h3><p>下载以下两个文件(如果失效可以自己google)：<br><em>mirrors.zip</em>：<a href="https://pan.baidu.com/s/1npQ2MBps6ypx2X_ebCJ2jg" target="_blank" rel="noopener">密码：j0yk</a><br><em>bootstraps.zip</em>：<a href="https://pan.baidu.com/s/1EeLLaenosPr2OLULw-VB_w" target="_blank" rel="noopener">密码：miwf</a></p><p>解压bootstrap.zip，上传“bootstrap”文件夹至master节点的<em>/var/www/nailgun/</em>目录下，覆盖原有bootstrap目录，然后执行如下命令：</p><blockquote></blockquote><pre><code>fuel-bootstrap activate d01c72e6-83f4-4a19-bb86-6085e40416e6  #激活bootstrapfuel-bootstrap list   #查看处于活动状态的bootstrap</code></pre><p>解压mirrors.zip，上传解压的“mirrors”文件夹至master节点的<em>/var/www/nailgun/</em>目录，</p><blockquote></blockquote><pre><code>fuel-createmirror   #在处于离线状态的master节点运行命令（会报错，直接忽略）</code></pre><p>注意以上两个解压文件不要出现同名嵌套的文件夹，比如bootstrap文件夹下还有一个bootstrap文件夹。</p><h2 id="controller和compute节点"><a href="#controller和compute节点" class="headerlink" title="controller和compute节点"></a>controller和compute节点</h2><p>新建两台虚拟机，配置可以自行设置，我这里按上面预先规划的配置进行设置，重点是两个节点的网卡配置，如下分别是我的controller节点和compute节点配置：<br><img src="https://i.loli.net/2019/03/25/5c98db1d162a3.png" alt="27.png"><br><img src="https://i.loli.net/2019/03/25/5c98db1ce03c4.png" alt="26.png"><br>启动controller和compute两个节点，两个节点会自动从pxe完成启动进入bootstrap，登录fuel的web界面，mater节点已经获取到两个节点的基本信息：<br><img src="https://i.loli.net/2019/03/22/5c943c595f95c.png" alt="14.png"></p><h1 id="创建OpenStack环境"><a href="#创建OpenStack环境" class="headerlink" title="创建OpenStack环境"></a>创建OpenStack环境</h1><p>点击“New OpenStack Enviroment”创建一个OpenStack环境：<br><img src="https://i.loli.net/2019/03/22/5c943a1e20593.png" alt="12.png"><br>相关选项根据需要自己修改，我这里全部保持默认，点击<em>create</em>完成创建。  </p><h2 id="修改网络配置"><a href="#修改网络配置" class="headerlink" title="修改网络配置"></a>修改网络配置</h2><p>点击Networks进入网络配置页面，修改Public网段，即连接外网的网段：<br><img src="https://i.loli.net/2019/03/22/5c943da406cf0.png" alt="15.png"><br>同时需要修改L3的网络配置，L3需要跟Public处在同一网段且地址块不能重叠：<br><img src="https://i.loli.net/2019/03/22/5c943dff6d1ac.png" alt="16.png"><br>修改DNS：<br><img src="https://i.loli.net/2019/03/22/5c943e66ecd60.png" alt="17.png"><br>其它配置，建议勾选此选项，并将两个server地址设置为master节点的地址：10.20.0.2<br><img src="https://i.loli.net/2019/03/25/5c98dbe04cab6.png" alt="28.png"></p><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><p>进入<em>Nodes</em>页面，点击<em>Add Nodes</em>添加已经发现到的两个节点并选择相应的角色：<br><img src="https://i.loli.net/2019/03/22/5c948f7d7dd43.png" alt="20.png"><br>上图是我第一遍操作时截的图，没有选择cinder角色，后来重新部署的时候遵从建议选择了cinder角色（fuel建议至少有一个cinder节点），这里也推荐大家部署cinder角色。在controller节点安装了cinder角色，补一个部署之后的截图：<br><img src="https://i.loli.net/2019/03/25/5c98de4957eac.png" alt="29.png"><br>点击节点右侧的齿轮按钮，设置一下接口配置，我的两个节点接口配置：<br><img src="https://i.loli.net/2019/03/22/5c94916f9bbc6.png" alt="22.png"></p><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>以上操作完成后到<em>Network</em>页面检查一下网络配置是否正确：<br><img src="https://i.loli.net/2019/03/22/5c949006bed85.png" alt="21.png"><br>检查通过就可以开始部署了，回到<em>Dashboard</em>页面，点击<em>Deploy Changes</em>开始部署：<br><img src="https://i.loli.net/2019/03/22/5c949299188fc.png" alt="24.png"><br>经过漫长的等待，最后部署成功：<br><img src="https://i.loli.net/2019/03/25/5c98df0dd505a.png" alt="30.png"><br>点击Horizon即可访问dashboard，输入用户名/密码：admin/admin登录：<br><img src="https://i.loli.net/2019/03/25/5c98df780c4df.png" alt="66.png"></p><h1 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h1><h2 id="sync-time-error"><a href="#sync-time-error" class="headerlink" title="sync_time error"></a>sync_time error</h2><p>时间同步错误，原因在于fuel主节点没有合适的时间同步，所以子节点无法完成时间同步，修改fuel主节点的ntp配置即可解决：</p><blockquote></blockquote><pre><code>vim /etc/ntp.conf</code></pre><p>在server段添加如下内容,并将原来的server注释掉。</p><blockquote></blockquote><pre><code>server asia.pool.ntp.org  iburst minpoll 3 maxpoll 9</code></pre><p>重启ntp服务：</p><blockquote></blockquote><pre><code>systemctl restart ntpdate.servicesystemctl restart ntpd.service</code></pre><h2 id="build-deploy-image-error"><a href="#build-deploy-image-error" class="headerlink" title="build_deploy_image error"></a>build_deploy_image error</h2><p>错误提示信息：<br>All nodes are finished. Failed tasks: Task[build_deploy_image/master] Stopping the deployment process!<br><img src="https://i.loli.net/2019/03/22/5c94aaf11fd3a.png" alt="25.png"><br>原因是master节点无法连接外网，修改相关网络配置即可，我这里是启用eth1网卡连接外网。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.51cto.com/goome/1916247" target="_blank" rel="noopener">https://blog.51cto.com/goome/1916247</a><br><a href="https://www.cnblogs.com/shoufengwei/p/6901173.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoufengwei/p/6901173.html</a><br><a href="https://blog.csdn.net/qq_35180983/article/details/82181496" target="_blank" rel="noopener">https://blog.csdn.net/qq_35180983/article/details/82181496</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年之前就开始接触OpenStack，但是还没入门就放弃了，因为实验环境实在是太难装了，尝试了很多次均以失败告终，大多教程中都是安装devstack的方式进行部署，但是作为一个刚入门的小白，个人觉得这种方式可能并不是太友好。最近看了一份教程，了解到fuel openstac
      
    
    </summary>
    
      <category term="OpenStack" scheme="https://cyneliu.github.io/categories/OpenStack/"/>
    
    
      <category term="Esxi" scheme="https://cyneliu.github.io/tags/Esxi/"/>
    
      <category term="fuel" scheme="https://cyneliu.github.io/tags/fuel/"/>
    
      <category term="OpenStack" scheme="https://cyneliu.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04安装OpenDaylight Carbon</title>
    <link href="https://cyneliu.github.io/2019/03/14/Ubuntu16-04%E5%AE%89%E8%A3%85OpenDaylight-Carbon/"/>
    <id>https://cyneliu.github.io/2019/03/14/Ubuntu16-04安装OpenDaylight-Carbon/</id>
    <published>2019-03-14T00:57:44.000Z</published>
    <updated>2019-03-14T01:26:38.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="JRE安装配置"><a href="#JRE安装配置" class="headerlink" title="JRE安装配置"></a>JRE安装配置</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html</a><br>我这里下载的是目前的最新版本：</p><blockquote></blockquote><pre><code>wget https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/server-jre-8u201-linux-x64.tar.gz</code></pre><p>解压到自定义目录中：</p><blockquote></blockquote><pre><code>mkdir -p /opt/java #将下载下来的安装包移动到此目录（自己定义）tar -xzvf server-jre-8u201-linux-x64.tar.gz</code></pre><p>配置环境变量：</p><blockquote></blockquote><pre><code>vim /etc/profile</code></pre><p>在文件末尾添加如下配置：</p><blockquote></blockquote><pre><code>export JAVA_HOME=/opt/java/jdk1.8.0_201export JRE_HOME=/opt/java/jdk1.8.0_201export CLASSPATH=$JRE_HOME/lib/rt.jar:$JRE_HOME/lib/extexport PATH=$PATH:$JRE_HOME/bin</code></pre><p>使配置生效：</p><blockquote></blockquote><pre><code>source /etc/profile</code></pre><p>验证配置成功：</p><blockquote></blockquote><pre><code>java -version #显示java版本信息</code></pre><h1 id="OpenDaylight-Carbon-安装配置"><a href="#OpenDaylight-Carbon-安装配置" class="headerlink" title="OpenDaylight(Carbon)安装配置"></a>OpenDaylight(Carbon)安装配置</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>我这里下载的是0.6.4版本：</p><blockquote></blockquote><pre><code>wget https://nexus.opendaylight.org/content/repositories/public/org/opendaylight/integration/distribution-karaf/0.6.4-Carbon/distribution-karaf-0.6.4-Carbon.zip</code></pre><h2 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h2><blockquote></blockquote><pre><code>uzip distribution-karaf-0.6.4-Carbon.zip</code></pre><h2 id="启动karaf"><a href="#启动karaf" class="headerlink" title="启动karaf"></a>启动karaf</h2><blockquote></blockquote><pre><code>cd distribution-karaf-0.6.4-Carbon./bin/karaf</code></pre><h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><p>安装REST API组件</p><blockquote></blockquote><pre><code>feature:install odl-restconf</code></pre><p>安装L2 switch组件：</p><blockquote></blockquote><pre><code>feature:install odl-l2switch-switch-ui</code></pre><p>安装API查看器：</p><blockquote></blockquote><pre><code>feature:install odl-mdsal-apidocs</code></pre><p>安装 dlux 展示页面:</p><blockquote></blockquote><pre><code>feature:install odl-dluxapps-applications</code></pre><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><h3 id="登录管理页面"><a href="#登录管理页面" class="headerlink" title="登录管理页面"></a>登录管理页面</h3><p>用浏览器访问：<a href="http://localhost:8080/index.html" target="_blank" rel="noopener">http://localhost:8080/index.html</a><br>用户名/密码：admin/admin</p><h3 id="使用OpenvSwitch连接ODL控制器"><a href="#使用OpenvSwitch连接ODL控制器" class="headerlink" title="使用OpenvSwitch连接ODL控制器"></a>使用OpenvSwitch连接ODL控制器</h3><p>用下面的命令将br0网桥连接至指定的控制器:</p><blockquote></blockquote><pre><code>ovs-vsctl set-controller br0 tcp:&lt;controller IP&gt;:&lt;port&gt;</code></pre><p>执行：ovs-vsctl show,出现is_connected:true字样表示连接成功：<br><img src="https://i.loli.net/2019/03/14/5c89ad571b951.png" alt="01.png"><br>登录管理页面查看拓扑发现已经连接的OVS交换机：<br><img src="https://i.loli.net/2019/03/14/5c89ad5730b6b.png" alt="02.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;h2 id=&quot;JRE安装配置&quot;&gt;&lt;a href=&quot;#JRE安装配置&quot; class=&quot;headerlink&quot; title=&quot;JRE
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="OpenDaylight" scheme="https://cyneliu.github.io/tags/OpenDaylight/"/>
    
      <category term="Ubuntu16.04" scheme="https://cyneliu.github.io/tags/Ubuntu16-04/"/>
    
  </entry>
  
  <entry>
    <title>ovs-vsctl: unix:/usr/local/var/run/openvswitch/db.sock: database connection failed</title>
    <link href="https://cyneliu.github.io/2019/03/13/ovs-vsctl-unix-usr-local-var-run-openvswitch-db-sock-database-connection-failed/"/>
    <id>https://cyneliu.github.io/2019/03/13/ovs-vsctl-unix-usr-local-var-run-openvswitch-db-sock-database-connection-failed/</id>
    <published>2019-03-13T14:08:46.000Z</published>
    <updated>2019-03-13T14:13:29.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在OpenvSwitch中执行ovs-vsctl show命令时，出现如下错误提示：</p><blockquote></blockquote><pre><code>ovs-vsctl: unix:/usr/local/var/run/openvswitch/db.sock: database connection failed</code></pre><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在每次重启开机之后执行如下命令：</p><blockquote></blockquote><pre><code>ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \                 --remote=db:Open_vSwitch,Open_vSwitch,manager_options \                 --private-key=db:Open_vSwitch,SSL,private_key \                 --certificate=db:Open_vSwitch,SSL,certificate \                 --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \                 --pidfile --detachovs-vsctl --no-wait initovs-vswitchd --pidfile --detach</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;在OpenvSwitch中执行ovs-vsctl show命令时，出现如下错误提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="OpenvSwitch" scheme="https://cyneliu.github.io/tags/OpenvSwitch/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu执行apt-get-update出现Error in &#39;appstreamcli&#39;错误</title>
    <link href="https://cyneliu.github.io/2019/03/13/ubuntu%E6%89%A7%E8%A1%8Capt-get-update%E5%87%BA%E7%8E%B0Error%20in%20&#39;appstreamcli&#39;%E9%94%99%E8%AF%AF/"/>
    <id>https://cyneliu.github.io/2019/03/13/ubuntu执行apt-get-update出现Error in &#39;appstreamcli&#39;错误/</id>
    <published>2019-03-13T13:54:13.000Z</published>
    <updated>2019-03-13T14:06:07.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>新装Ubuntu16.04桌面版后执行apt-get update时出现了如下图所示的错误：<br><img src="https://i.loli.net/2019/03/13/5c890d5cd7212.png" alt="11.png"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>执行如下命令：</p><blockquote></blockquote><pre><code>sudo apt install appstream/xenial-backports sudo appstreamcli refresh –-force sudo apt-get update</code></pre><p>然后再次执行：</p><blockquote></blockquote><pre><code>apt-get update</code></pre><p>这时已经可以成功执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;新装Ubuntu16.04桌面版后执行apt-get update时出现了如下图所示的错误：&lt;br&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
      <category term="Linux" scheme="https://cyneliu.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://cyneliu.github.io/tags/Ubuntu/"/>
    
      <category term="apt-get" scheme="https://cyneliu.github.io/tags/apt-get/"/>
    
  </entry>
  
  <entry>
    <title>mininet gave up after 3 retries问题</title>
    <link href="https://cyneliu.github.io/2019/03/02/mininet-gave-up-after-3-retries%E9%97%AE%E9%A2%98/"/>
    <id>https://cyneliu.github.io/2019/03/02/mininet-gave-up-after-3-retries问题/</id>
    <published>2019-03-02T12:08:01.000Z</published>
    <updated>2019-03-05T11:48:53.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用mn创建拓扑时，出现以下错误：</p><blockquote></blockquote><pre><code>*** Creating network*** Adding controller*** Adding hosts:h1 h2 *** Adding switches:s1 *** Adding links:*** gave up after 3 retries</code></pre><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>出现如上错误是因为kernel版本的问题，在安装mininet时使用的是apt-get install mininet的方式安装的，这种方式安装的mininet并不是最新版本，安装最新版本以解决问题：<br>1、卸载之前的安装</p><blockquote></blockquote><pre><code>sudo apt-get remove mininetsudo apt-get remove --auto-remove mininetsudo apt-get purge mininet</code></pre><p>2、安装最新版本(<a href="https://cyne.tk/2018/06/24/Mininet%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">详细步骤</a>)</p><blockquote></blockquote><pre><code>git clone git://github.com/mininet/mininetcd mininetutil/install.sh -a</code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>后来使用Ubuntu16.04，同样使用apt-get install直接安装openvswitch和mininet时，没有出现上述问题，推荐使用16.04版本安装环境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;在使用mn创建拓扑时，出现以下错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;*
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="mininet" scheme="https://cyneliu.github.io/tags/mininet/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu14.04安装OpenDaylight(锂版本)</title>
    <link href="https://cyneliu.github.io/2019/02/27/Ubuntu14-04%E5%AE%89%E8%A3%85OpenDaylight/"/>
    <id>https://cyneliu.github.io/2019/02/27/Ubuntu14-04安装OpenDaylight/</id>
    <published>2019-02-27T13:33:58.000Z</published>
    <updated>2019-03-15T00:32:17.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="下载OpenDaylight"><a href="#下载OpenDaylight" class="headerlink" title="下载OpenDaylight"></a>下载OpenDaylight</h2><p>下载OpenDaylight Lithium压缩包：<a href="https://pan.baidu.com/s/16rLxNFvz-XhGuSz62a5eQQ" target="_blank" rel="noopener">提取码：y4ae </a>  </p><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><blockquote></blockquote><pre><code>sudo apt-get install openjdk-7-jdk</code></pre><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>编辑 ~/.bashrc文件：</p><blockquote></blockquote><pre><code>vim ~/.bashrc</code></pre><p>将以下内容添加至文件末尾：</p><blockquote></blockquote><pre><code>export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64 </code></pre><p>应用 ~/.bashrc文件：</p><blockquote></blockquote><pre><code>source ~/.bashrc</code></pre><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><blockquote></blockquote><pre><code>java -version</code></pre><h1 id="安装OpenDaylight"><a href="#安装OpenDaylight" class="headerlink" title="安装OpenDaylight"></a>安装OpenDaylight</h1><p>将之前准备的安装包文件解压，并进入目录：</p><blockquote></blockquote><pre><code>unzip lithium.zipcd distribution-karaf-0.3.0-Lithium</code></pre><p>启动控制器，并进入karaf控制台：</p><blockquote></blockquote><pre><code>./bin/karaf</code></pre><p>这样启动后关闭命令终端，控制器进程也会随之关闭，我们采用如下方式后台启动：</p><blockquote></blockquote><pre><code>./bin/start./bin/client -u karaf</code></pre><p>加载组件：</p><blockquote></blockquote><pre><code>feature:install odl-restconffeature:install odl-l2switch-switchfeature:install odl-openflowplugin-allfeature:install odl-dlux-allfeature:install odl-mdsal-allfeature:install odl-adsal-northbound</code></pre><h1 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h1><p>最后使用mininet创建拓扑连接OpenDaylight控制器进行验证：</p><blockquote></blockquote><pre><code>mn --controller=remote,ip=192.168.1.3,port=6633&gt; pingall</code></pre><p><img src="https://i.loli.net/2019/03/05/5c7e7ae09ba8e.png" alt="01.png"><br>可以看到两台设备通过控制器自动下发的流表已经可以互通了。<br>打开浏览器访问：http://[controller ip]:8080/index.html,用户名密码为admin/admin，登录控制器就可以看到刚刚创建的拓扑了：<br><img src="https://i.loli.net/2019/03/05/5c7e7ae093d62.png" alt="02.png"></p><h1 id="ODL关闭后重新启动出错"><a href="#ODL关闭后重新启动出错" class="headerlink" title="ODL关闭后重新启动出错"></a>ODL关闭后重新启动出错</h1><p>进入ODL主目录，(删除data目录，我在尝试时没删除也不影响效果),执行：</p><blockquote></blockquote><pre><code>./karaf clean</code></pre><p>然后重新启动：</p><blockquote></blockquote><pre><code>./karaf</code></pre><p>重新加载组件：</p><blockquote></blockquote><pre><code>feature:install odl-restconffeature:install odl-l2switch-switchfeature:install odl-openflowplugin-allfeature:install odl-dlux-allfeature:install odl-mdsal-allfeature:install odl-adsal-northbound</code></pre><h1 id="参考链接-与本文安装方式无关-："><a href="#参考链接-与本文安装方式无关-：" class="headerlink" title="参考链接(与本文安装方式无关)："></a>参考链接(与本文安装方式无关)：</h1><p>maven下载地址（bin.tar.gz）：</p><blockquote><p><a href="http://archive.apache.org/dist/maven/maven-3/3.3.3/binaries/" target="_blank" rel="noopener">http://archive.apache.org/dist/maven/maven-3/3.3.3/binaries/</a></p></blockquote><p><a href="https://wiki.opendaylight.org/view/Install_On_Ubuntu_14.04" target="_blank" rel="noopener">https://wiki.opendaylight.org/view/Install_On_Ubuntu_14.04</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;h2 id=&quot;下载OpenDaylight&quot;&gt;&lt;a href=&quot;#下载OpenDaylight&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="OpenDaylight" scheme="https://cyneliu.github.io/tags/OpenDaylight/"/>
    
      <category term="Lithium" scheme="https://cyneliu.github.io/tags/Lithium/"/>
    
  </entry>
  
  <entry>
    <title>端口检测小工具:tcping</title>
    <link href="https://cyneliu.github.io/2019/01/27/%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B%E5%B0%8F%E5%B7%A5%E5%85%B7-tcping/"/>
    <id>https://cyneliu.github.io/2019/01/27/端口检测小工具-tcping/</id>
    <published>2019-01-27T01:27:19.000Z</published>
    <updated>2019-01-27T02:16:39.202Z</updated>
    
    <content type="html"><![CDATA[<p>tcping是一个可以用来检测端口是否开启的小工具，从名字就可以看出这个跟我们经常使用的ping命令比较相似，不同之处在于，ping是基于ICMP协议，而tcping顾名思义使用的是tcp协议，且不支持udp，所以不能检测udp端口。  </p><h1 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h1><p>工具下载：<a href="https://pan.baidu.com/s/1bjyXW2w8Z18FUofMrdf_Ng" target="_blank" rel="noopener">提取码 cyne</a>   </p><p>将下载文件解压后粘贴到 <em>C:\WINDOWS\system32</em> 目录下后就可以直接在cmd中使用了，查看命令帮助：</p><blockquote></blockquote><pre><code>tcping /?</code></pre><p><img src="https://i.loli.net/2019/01/27/5c4d123c40c13.png" alt="02.png"></p><p>比如我们检测本机的端口：<br>首先查看我们开放了哪些端口：</p><blockquote></blockquote><pre><code>netstat -a</code></pre><p><img src="https://i.loli.net/2019/01/27/5c4d12f9320e5.png" alt="01.png"></p><p>可以看到我的135端口是处于监听状态，我们用tcping测试一下：</p><blockquote></blockquote><pre><code>tcping -f 127.0.0.1 135</code></pre><p><img src="https://i.loli.net/2019/01/27/5c4d14489478c.png" alt="03.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tcping是一个可以用来检测端口是否开启的小工具，从名字就可以看出这个跟我们经常使用的ping命令比较相似，不同之处在于，ping是基于ICMP协议，而tcping顾名思义使用的是tcp协议，且不支持udp，所以不能检测udp端口。  &lt;/p&gt;
&lt;h1 id=&quot;下载使用&quot;
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="tcping" scheme="https://cyneliu.github.io/tags/tcping/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理</title>
    <link href="https://cyneliu.github.io/2019/01/26/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://cyneliu.github.io/2019/01/26/Nginx反向代理/</id>
    <published>2019-01-26T07:19:40.000Z</published>
    <updated>2019-01-26T09:06:58.125Z</updated>
    
    <content type="html"><![CDATA[<p>最近我用国内阿里云的服务器搭建了几个站点，但是由于没有备案所以只能采用域名+端口的方式访问，这样访问起来很别扭，于是就想到了使用Nginx反向代理。</p><h1 id="环境简介"><a href="#环境简介" class="headerlink" title="环境简介"></a>环境简介</h1><p><img src="https://i.loli.net/2019/01/26/5c4c0e2cc5892.png" alt="00.png"><br>做了一个简陋的拓扑图说明一下，图中的两台服务器都是处于公网的vps，都具有公网的ip地址，其中WEB服务器就是我在阿里云的未备案的vps，另一台是一台位于境外的vps，这里用来做Nginx反向代理。</p><h1 id="在代理服务器安装nginx"><a href="#在代理服务器安装nginx" class="headerlink" title="在代理服务器安装nginx"></a>在代理服务器安装nginx</h1><p>安装所需环境，详细的安装步骤可以参考<a href="https://www.cnblogs.com/kaid/p/7640723.html" target="_blank" rel="noopener">这里</a>：</p><blockquote></blockquote><pre><code>yum install gcc zlib zlib-devel openssl openssl-devel -y</code></pre><p>下载nginx安装包：</p><blockquote></blockquote><pre><code>wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</code></pre><p>解压：</p><blockquote></blockquote><pre><code>tar -zxvf nginx-1.10.1.tar.gzcd nginx-1.10.1</code></pre><p>使用默认配置：</p><blockquote></blockquote><pre><code>./configure</code></pre><p>编译安装：</p><blockquote></blockquote><pre><code>makemake install</code></pre><p>查找安装路径：</p><blockquote></blockquote><pre><code>whereis nginx</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1167725ea.png" alt="01.png"></p><p>根据回显的信息进入安装路径，在nginx目录下有以下文件，我们主要用到的是sbin(执行程序)和conf(配置文件)两个文件夹：<br><img src="https://i.loli.net/2019/01/26/5c4c1276be783.png" alt="02.png"><br>nginx常用命令：</p><blockquote></blockquote><pre><code>./nginx #启动nginx./nginx -s stop #此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程./nginx -s quit #此方式停止步骤是待nginx进程处理任务完毕进行停止./nginx -s reload #重载配置文件./nginx -v #查看版本信息</code></pre><p>执行在sbin目录下执行./nginx启动Nginx，访问此vps的ip地址出现如下页面说明安装成功：<br><img src="https://i.loli.net/2019/01/26/5c4c1514634dd.png" alt="03.png"><br>设置开机启动：</p><blockquote></blockquote><pre><code>vi /etc/rc.local</code></pre><p>增加一行：/usr/local/nginx/sbin/nginx<br>设置执行权限：</p><blockquote></blockquote><pre><code>chmod 755 rc.local</code></pre><h1 id="配置代理服务器"><a href="#配置代理服务器" class="headerlink" title="配置代理服务器"></a>配置代理服务器</h1><p>这里有两种配置方法，一种是反向代理单个域名，通过这一个域名访问WEB服务器的单一服务；另一种则是代理多个域名，访问相应的域名时将请求代理到响应ip的响应端口。</p><h2 id="代理单个域名"><a href="#代理单个域名" class="headerlink" title="代理单个域名"></a>代理单个域名</h2><p>编辑默认配置文件：</p><blockquote></blockquote><pre><code>vim /usr/local/nginx/conf/nginx.conf</code></pre><p>将以下内容添加到如下图所示的部分：</p><blockquote></blockquote><pre><code>proxy_pass http://172.18.78.14:6080;proxy_http_version 1.1;proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection &quot;Upgrade&quot;;</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1914b6b3b.png" alt="04.png"></p><p>重载配置：</p><blockquote></blockquote><pre><code>./nginx -s reload</code></pre><p>最后将域名解析到代理服务器的ip地址即可。</p><h2 id="代理多个域名"><a href="#代理多个域名" class="headerlink" title="代理多个域名"></a>代理多个域名</h2><p>因为代理多个域名配置较多，我们新建一个配置文件方便查看：</p><blockquote></blockquote><pre><code>vim /usr/local/nginx/conf/reverse-proxy.conf</code></pre><p>粘贴如下内容：</p><blockquote></blockquote><pre><code>server {    listen 80;    server_name a.test.com;    location /{        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8081;        #proxy_pass http://tomcat;    }    access_log logs/tomcat1_access.log;}server {    listen 80;    server_name b.test.com;    location /{        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8082;        #proxy_pass http://tomcat;    }    access_log logs/tomcat2_access.log;}</code></pre><p>需要注意的是，我在一开始的配置时同时代理了主域名即子域名，即test.com和a.test.com，这样配置的结果就是主域名无法进行代理，这种情况下如果还想使用主域名，可以使用www域名，即同时代理<a href="http://www.test.com和a.test.com等。" target="_blank" rel="noopener">www.test.com和a.test.com等。</a>  </p><p>修改nginx.conf,导入刚才写的配置,在http{}中加入如下内容：</p><blockquote></blockquote><pre><code>include reverse-proxy.conf;</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1d8b15629.png" alt="05.png"></p><p>最后重载配置即可：</p><blockquote></blockquote><pre><code>./nginx -s reload</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近我用国内阿里云的服务器搭建了几个站点，但是由于没有备案所以只能采用域名+端口的方式访问，这样访问起来很别扭，于是就想到了使用Nginx反向代理。&lt;/p&gt;
&lt;h1 id=&quot;环境简介&quot;&gt;&lt;a href=&quot;#环境简介&quot; class=&quot;headerlink&quot; title=&quot;环境
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="Nginx" scheme="https://cyneliu.github.io/tags/Nginx/"/>
    
      <category term="反向代理" scheme="https://cyneliu.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7最小化安装后找不到ifconfig命令</title>
    <link href="https://cyneliu.github.io/2019/01/11/CentOS7%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0ifconfig%E5%91%BD%E4%BB%A4/"/>
    <id>https://cyneliu.github.io/2019/01/11/CentOS7最小化安装后找不到ifconfig命令/</id>
    <published>2019-01-11T11:43:09.000Z</published>
    <updated>2019-01-11T11:44:50.941Z</updated>
    
    <content type="html"><![CDATA[<p>“ifconfig”命令用于配置GNU/Linux系统的网络接口。它显示网络接口卡的详细信息，包括IP地址，MAC地址，以及网络接口卡状态之类。但是，该命令已经过时了，而且在最小化版本的RHEL 7以及它的克隆版本CentOS 7，Oracle Linux 7和Scientific Linux 7中也找不到该命令。</p><h1 id="使用ip-addr和ip-link查看网卡信息"><a href="#使用ip-addr和ip-link查看网卡信息" class="headerlink" title="使用ip addr和ip link查看网卡信息"></a>使用ip addr和ip link查看网卡信息</h1><blockquote></blockquote><pre><code>ip addr # 查看网卡细节ip linkip -s link # 查看网络接口统计数据</code></pre><h1 id="依然使用ifconfig"><a href="#依然使用ifconfig" class="headerlink" title="依然使用ifconfig"></a>依然使用ifconfig</h1><p>如果说我们还是想使用ifconfig命令，我们就需要安装相应的包来使用。首先查看哪些包提供ifconfig命令：</p><blockquote></blockquote><pre><code>yum provides ifconfig</code></pre><p>或者：</p><blockquote></blockquote><pre><code>yum whatprovides ifconfig</code></pre><p>根据输出信息安装相应的包即可使用ifconfig命令。  </p><p>参考自：<a href="https://linux.cn/article-3631-1.html" target="_blank" rel="noopener">Linux中国</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“ifconfig”命令用于配置GNU/Linux系统的网络接口。它显示网络接口卡的详细信息，包括IP地址，MAC地址，以及网络接口卡状态之类。但是，该命令已经过时了，而且在最小化版本的RHEL 7以及它的克隆版本CentOS 7，Oracle Linux 7和Scient
      
    
    </summary>
    
      <category term="Linux" scheme="https://cyneliu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://cyneliu.github.io/tags/CentOS/"/>
    
      <category term="ifconfig" scheme="https://cyneliu.github.io/tags/ifconfig/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04安装包方式安装Open vSwitch</title>
    <link href="https://cyneliu.github.io/2018/12/28/Ubuntu16-04%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Open-vSwitch/"/>
    <id>https://cyneliu.github.io/2018/12/28/Ubuntu16-04压缩包方式安装Open-vSwitch/</id>
    <published>2018-12-28T09:15:02.000Z</published>
    <updated>2018-12-28T09:47:43.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载安装Open-vSwitch"><a href="#下载安装Open-vSwitch" class="headerlink" title="下载安装Open vSwitch"></a>下载安装Open vSwitch</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote></blockquote><pre><code>apt-get updateapt-get install build-essential</code></pre><h2 id="下载解压安装包"><a href="#下载解压安装包" class="headerlink" title="下载解压安装包"></a>下载解压安装包</h2><p>下载Open vSwitch安装包：<a href="http://www.openvswitch.org/download/" target="_blank" rel="noopener">Open vSwitch官网下载地址</a><br>这里我下载的是最新的2.10.1版本：</p><blockquote></blockquote><pre><code>wget https://www.openvswitch.org/releases/openvswitch-2.10.1.tar.gztar -xzvf openvswitch-2.10.1.tar.gz</code></pre><h2 id="构建基于Linux内核的交换机"><a href="#构建基于Linux内核的交换机" class="headerlink" title="构建基于Linux内核的交换机"></a>构建基于Linux内核的交换机</h2><blockquote></blockquote><pre><code>cd openvswitch-2.10.1./configure --with-linux=/lib/modules/&quot;uname -r&quot;/build# 注意这条命令中的&quot;uname -r&quot;是输出当前系统的版本号# 比如我执行&quot;uname -r&quot;后的结果为4.4.0-21-generic，那么我应该执行的命令即为：# ./configure --with-linux=/lib/modules/4.4.0-21-generic/build</code></pre><h2 id="编译安装Open-vSwitch"><a href="#编译安装Open-vSwitch" class="headerlink" title="编译安装Open vSwitch"></a>编译安装Open vSwitch</h2><blockquote></blockquote><pre><code>makemake install</code></pre><h2 id="加载openvswitch-ko模块-遇到错误"><a href="#加载openvswitch-ko模块-遇到错误" class="headerlink" title="加载openvswitch.ko模块(遇到错误)"></a>加载openvswitch.ko模块(遇到错误)</h2><p>如果需要OVS支持VLAN功能，还需要加载openvswitch.ko模块，如果不需要，此步可以忽略。  </p><blockquote></blockquote><pre><code>modprobe greinsmod datapath/linux/openvswitch.ko</code></pre><p>我在执行第二条命令时遇到了如下错误：</p><blockquote></blockquote><pre><code>insmod: ERROR: could not insert module openvswitch.ko: Unkown symbol in module</code></pre><p>google了几个方法都没能成功解决问题，有人说是bug，也有说是因为兼容性问题，因为我暂时用不到VLAN功能，就暂时跳过此步骤了。</p><h2 id="安装并加载构建的内核模块"><a href="#安装并加载构建的内核模块" class="headerlink" title="安装并加载构建的内核模块"></a>安装并加载构建的内核模块</h2><blockquote></blockquote><pre><code>make modules_install/sbin/modprobe openvswitch</code></pre><h2 id="使用ovsdb工具初始化配置数据库"><a href="#使用ovsdb工具初始化配置数据库" class="headerlink" title="使用ovsdb工具初始化配置数据库"></a>使用ovsdb工具初始化配置数据库</h2><blockquote></blockquote><pre><code>ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema# 在执行此命令时报错没有此文件夹，我直接手动创建了对应的文件夹：# mkdir -p /usr/local/etc/openvswitch</code></pre><h1 id="启动Open-vSwitch"><a href="#启动Open-vSwitch" class="headerlink" title="启动Open vSwitch"></a>启动Open vSwitch</h1><h2 id="启动ovsdb-server配置数据库"><a href="#启动ovsdb-server配置数据库" class="headerlink" title="启动ovsdb-server配置数据库:"></a>启动ovsdb-server配置数据库:</h2><blockquote></blockquote><pre><code>ovsdb-server -v --remote=punix:/usr/local/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,Open_vSwitch,manager_options --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --pidfile --detach --log-file# 这里同样报错没有此文件夹，同样手动创建了相应的文件夹</code></pre><p>首次用ovsdb-tool创建数据库时需用ovs-vsctl命令初始化下数据库:</p><blockquote></blockquote><pre><code>ovs-vsctl --no-wait init</code></pre><h2 id="启动OVS主进程"><a href="#启动OVS主进程" class="headerlink" title="启动OVS主进程:"></a>启动OVS主进程:</h2><blockquote></blockquote><pre><code>ovs-vswitchd --pidfile --detach --log-file</code></pre><h2 id="查看OVS进程是否启动"><a href="#查看OVS进程是否启动" class="headerlink" title="查看OVS进程是否启动:"></a>查看OVS进程是否启动:</h2><blockquote></blockquote><pre><code>ps aux|grep ovs</code></pre><h2 id="查看所安装OVS的版本号"><a href="#查看所安装OVS的版本号" class="headerlink" title="查看所安装OVS的版本号:"></a>查看所安装OVS的版本号:</h2><blockquote></blockquote><pre><code>ovs-vsctl --version</code></pre><p>至此，Open vSwitch就安装完成了，安装过程中的几个小问题本次没有解决，希望之后能找到解决办法。最后再补充一个更简单的方式——使用apt install的方式直接安装：</p><blockquote></blockquote><pre><code>apt-get install openvswitch-switch</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载安装Open-vSwitch&quot;&gt;&lt;a href=&quot;#下载安装Open-vSwitch&quot; class=&quot;headerlink&quot; title=&quot;下载安装Open vSwitch&quot;&gt;&lt;/a&gt;下载安装Open vSwitch&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="Open vSwitch" scheme="https://cyneliu.github.io/tags/Open-vSwitch/"/>
    
  </entry>
  
  <entry>
    <title>ESXI安装OpenWrt/LEDE实现软路由功能</title>
    <link href="https://cyneliu.github.io/2018/12/23/ESXI%E5%AE%89%E8%A3%85OpenWrt-LEDE%E5%AE%9E%E7%8E%B0%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"/>
    <id>https://cyneliu.github.io/2018/12/23/ESXI安装OpenWrt-LEDE实现软路由功能/</id>
    <published>2018-12-23T10:23:17.000Z</published>
    <updated>2018-12-23T12:04:24.631Z</updated>
    
    <content type="html"><![CDATA[<p>最近部署一套环境需要从国外的服务器下载文件，因为众所周知的原因，速度慢到几kb不说，还经常传输失败，但一台一台的设置科学上网又比较麻烦，所以就有了设置一个可以使用酸酸乳的软路由作为网关的想法。  </p><p>实验室硬件不支持肯定首先想到的就是软路由了，常用的比较有名的当属RouterOS了，再就是<a href="http://www.hi-spider.com/zh" target="_blank" rel="noopener">海蜘蛛</a>和<a href="http://www.ikuai8.com/" target="_blank" rel="noopener">爱快</a>等等了，但是貌似都不能用酸酸乳，最后找到的就是OpenWrt/LEDE这个方案了，下面简单整理一下过程。  </p><h1 id="下载-vmdk文件"><a href="#下载-vmdk文件" class="headerlink" title="下载*.vmdk文件"></a>下载*.vmdk文件</h1><p>感谢koolshare论坛的大佬给出的硬盘文件，原帖地址：<a href="http://koolshare.cn/thread-67584-1-8.html" target="_blank" rel="noopener">http://koolshare.cn/thread-67584-1-8.html</a>  </p><p>下载地址：<a href="https://pan.baidu.com/s/1kVHJ3gj#list/path=%2F" target="_blank" rel="noopener">百度网盘</a>（4kqa）</p><h1 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h1><p>打开vSphere客户端，新建虚拟机，因为之后需要换硬盘文件，所以这里配置什么的就无所谓了，直接选择典型就可以了。客户机操作系统我这里选择的是“其他Linux(64位)”：<br><img src="https://i.loli.net/2018/12/23/5c1f721de8dfe.png" alt="01.png"><br>然后网卡根据需要设置成两个或两个以上，我这里没有特殊需要，两个网卡一个WAN口一个LAN口就可以了：<br><img src="https://i.loli.net/2018/12/23/5c1f721df2c97.png" alt="02.png"><br>之后默认即可，完成虚拟机创建。</p><h1 id="修改硬盘文件"><a href="#修改硬盘文件" class="headerlink" title="修改硬盘文件"></a>修改硬盘文件</h1><p>在服务器存储中找到刚刚创建的虚拟机的虚拟磁盘文件（.vmdk）并删除：<br><img src="https://i.loli.net/2018/12/23/5c1f732863c64.png" alt="03.png"><br>在当前目录上传之前下载的两个.vmdk文件，上传之后会被合并为一个文件：<br><img src="https://i.loli.net/2018/12/23/5c1f741fb2876.png" alt="04.png"><br>编辑虚拟机设置，添加现有虚拟磁盘，在存储中找到刚刚上传的文件完成添加并删除原来的硬盘：<br><img src="https://i.loli.net/2018/12/23/5c1f7516ded5b.png" alt="05.png"><br>打开电源即可开始安装。</p><h1 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h1><p>安装完成后按回车进入：<br><img src="https://i.loli.net/2018/12/23/5c1f76226f85a.png" alt="06.png"><br>网络的配置文件在“/etc/config/network”下，可以根据需要进行修改：<br><img src="https://i.loli.net/2018/12/23/5c1f76f5e44c4.png" alt="07.png"><br>这里我没有做任何更改，因为上接网络中有DHCP服务器，所以自动获取了一个WAN口ip，如果没有DHCP需要手工设置ip地址，LAN口ip使用默认的192.168.1.1。</p><h1 id="登录WEB页面"><a href="#登录WEB页面" class="headerlink" title="登录WEB页面"></a>登录WEB页面</h1><p>我们需要使用LAN口的ip地址进入WEB页面，所以我把一台Windows设备的ip地址设置为192.168.1.2/24，网关192.168.1.1。  </p><p>打开浏览器访问192.168.1.1，用户名：admin，密码：koolshare。<br><img src="https://i.loli.net/2018/12/23/5c1f78cab38bd.png" alt="08.png"></p><p>开启SS服务并将需要和谐上网的虚拟机修改网关为LAN口地址，大功告成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近部署一套环境需要从国外的服务器下载文件，因为众所周知的原因，速度慢到几kb不说，还经常传输失败，但一台一台的设置科学上网又比较麻烦，所以就有了设置一个可以使用酸酸乳的软路由作为网关的想法。  &lt;/p&gt;
&lt;p&gt;实验室硬件不支持肯定首先想到的就是软路由了，常用的比较有名的当
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="ESXI" scheme="https://cyneliu.github.io/tags/ESXI/"/>
    
      <category term="OpenWrt" scheme="https://cyneliu.github.io/tags/OpenWrt/"/>
    
      <category term="软路由" scheme="https://cyneliu.github.io/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    
      <category term="虚拟化" scheme="https://cyneliu.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装VNC服务端程序</title>
    <link href="https://cyneliu.github.io/2018/12/21/CentOS7%E5%AE%89%E8%A3%85VNC%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F/"/>
    <id>https://cyneliu.github.io/2018/12/21/CentOS7安装VNC服务端程序/</id>
    <published>2018-12-21T11:28:27.000Z</published>
    <updated>2018-12-21T12:11:22.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检查是否已安装VNC"><a href="#检查是否已安装VNC" class="headerlink" title="检查是否已安装VNC"></a>检查是否已安装VNC</h1><blockquote></blockquote><pre><code>rpm -q tigervnc tigervnc-server</code></pre><h1 id="安装X-Window"><a href="#安装X-Window" class="headerlink" title="安装X-Window"></a>安装X-Window</h1><blockquote></blockquote><pre><code>yum check-updateyum groupinstall &quot;X Window System&quot; #这里可能会有警告提示，忽略即可yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fontsunlink /etc/systemd/system/default.targetln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.targetreboot #重启机器</code></pre><h1 id="安装VNC服务端"><a href="#安装VNC服务端" class="headerlink" title="安装VNC服务端"></a>安装VNC服务端</h1><blockquote></blockquote><pre><code>yum install tigervnc-server -y</code></pre><h1 id="从VNC备份库中复制service文件到系统service服务管理目录下"><a href="#从VNC备份库中复制service文件到系统service服务管理目录下" class="headerlink" title="从VNC备份库中复制service文件到系统service服务管理目录下"></a>从VNC备份库中复制service文件到系统service服务管理目录下</h1><blockquote></blockquote><pre><code>cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service  #复制并重命名为vncserver@:1.service</code></pre><h1 id="修改vncserver-1-service文件"><a href="#修改vncserver-1-service文件" class="headerlink" title="修改vncserver@:1.service文件"></a>修改vncserver@:1.service文件</h1><p>使用如下信息覆盖原信息：</p><blockquote></blockquote><pre><code>[Unit]Description=Remote desktop service (VNC)After=syslog.target network.target[Service]Type=forkingUser=rootExecStartPre=-/usr/bin/vncserver -kill %iExecStart=/sbin/runuser -l root -c &quot;/usr/bin/vncserver %i&quot; PIDFile=/root/.vnc/%H%i.pidExecStop=-/usr/bin/vncserver -kill %i[Install]WantedBy=multi-user.target</code></pre><h1 id="修改文件使配置生效"><a href="#修改文件使配置生效" class="headerlink" title="修改文件使配置生效"></a>修改文件使配置生效</h1><blockquote></blockquote><pre><code>systemctl daemon-reload</code></pre><h1 id="为vncserver-1-service设置密码"><a href="#为vncserver-1-service设置密码" class="headerlink" title="为vncserver@:1.service设置密码"></a>为vncserver@:1.service设置密码</h1><blockquote></blockquote><pre><code>vncpasswd</code></pre><h1 id="启动VNC"><a href="#启动VNC" class="headerlink" title="启动VNC"></a>启动VNC</h1><blockquote></blockquote><pre><code>systemctl enable vncserver@:1.service #设置开机启动systemctl start vncserver@:1.service #启动vnc会话服务systemctl status vncserver@:1.service #查看nvc会话服务状态systemctl stop vncserver@:1.service #关闭nvc会话服务netstat -lnt | grep 590*  </code></pre><p>5901端口已经处于监听状态：<br><img src="https://i.loli.net/2018/12/21/5c1cd3d638c69.png" alt="01.png"></p><h1 id="开启防火墙端口"><a href="#开启防火墙端口" class="headerlink" title="开启防火墙端口"></a>开启防火墙端口</h1><p>在安装后防火墙默认关掉了相应的端口，需要手动开启一下。<br>查看zone名称：</p><blockquote></blockquote><pre><code>firewall-cmd --get-active-zones</code></pre><p>允许相关端口：</p><blockquote></blockquote><pre><code>firewall-cmd --zone=public --add-port=5901/tcp --permanent #5901即为要开启的端口</code></pre><p>最后重启防火墙：</p><blockquote></blockquote><pre><code>firewall-cmd --reload</code></pre><p>确认端口号是否开启：</p><blockquote></blockquote><pre><code>firewall-cmd --query-port=5901/tcp</code></pre><h1 id="下载客户端进行连接"><a href="#下载客户端进行连接" class="headerlink" title="下载客户端进行连接"></a>下载客户端进行连接</h1><p>使用“ip::port”的方式进行连接，下图表明已经可以成功连接：<br><img src="https://i.loli.net/2018/12/21/5c1cd858e4d38.png" alt="2.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检查是否已安装VNC&quot;&gt;&lt;a href=&quot;#检查是否已安装VNC&quot; class=&quot;headerlink&quot; title=&quot;检查是否已安装VNC&quot;&gt;&lt;/a&gt;检查是否已安装VNC&lt;/h1&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rpm
      
    
    </summary>
    
      <category term="Linux" scheme="https://cyneliu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://cyneliu.github.io/tags/CentOS/"/>
    
      <category term="VNC" scheme="https://cyneliu.github.io/tags/VNC/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql8.0服务无法启动的问题</title>
    <link href="https://cyneliu.github.io/2018/11/29/%E5%85%B3%E4%BA%8Emysql8-0%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cyneliu.github.io/2018/11/29/关于mysql8-0服务无法启动的问题/</id>
    <published>2018-11-29T02:41:37.000Z</published>
    <updated>2018-11-29T03:07:43.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>如图：<br><img src="https://i.loli.net/2018/11/29/5bff526bca5e0.png" alt="02.png"><br>我下载的是mysql-8.0.13-winx64解压版本，但安装后出现如上图所示服务无法启动的问题。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>首先简单说明一下我的安装过程，将压缩包解压后在mysql的根目录创建“my.ini”，内容如下：</p><blockquote></blockquote><pre><code>[mysqld]  #basedir代表自己MySQL的安装根目录  basedir = E:\\mysql-8.0.13-winx64  #datadir代表自己MySQL的数据库保存的目录  datadir = E:\\mysql-8.0.13-winx64\\data  #port代表端口号  port = 3306  sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  </code></pre><p><img src="https://i.loli.net/2018/11/29/5bff564b8580d.png" alt="03.png"></p><p>删除根目录下自带的data文件夹，原因下面会有说明。  </p><p>然后以管理员身份运行cmd，进入mysql根目录下的bin目录中。  </p><p>移除之前安装的服务：</p><blockquote></blockquote><pre><code>mysqld -remove</code></pre><p>初始化：</p><blockquote></blockquote><pre><code>mysqld --initialize-insecure  #这里我使用的是无密的方式</code></pre><p>这个步骤会重新生成data文件夹，需要等待一会。</p><p>重新安装mysql服务：</p><blockquote></blockquote><pre><code>mysqld -install</code></pre><p>启动mysql服务：</p><blockquote></blockquote><pre><code>net start mysql</code></pre><p><img src="https://i.loli.net/2018/11/29/5bff526bc3777.png" alt="01.png"></p><p>最后说明一下删除data文件夹的原因，网上很多教程里写的是直接在配置文件中写上data文件夹的路径就可以甚至没有data文件夹自己新建的一个。  </p><p>不能说那些教程里的做法就是错的，因为版本不同的原因，情况也不尽相同，新版本在初始化时会自动生成data文件夹，如果直接使用自带的data文件夹而不删除让它自动创建的话，很容易出错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;如图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/11/29/5bff526bca5e0.p
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="mysql" scheme="https://cyneliu.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>deepin使用ssr不能和谐上网</title>
    <link href="https://cyneliu.github.io/2018/11/25/deepin%E4%BD%BF%E7%94%A8ssr%E4%B8%8D%E8%83%BD%E5%92%8C%E8%B0%90%E4%B8%8A%E7%BD%91/"/>
    <id>https://cyneliu.github.io/2018/11/25/deepin使用ssr不能和谐上网/</id>
    <published>2018-11-25T13:19:14.000Z</published>
    <updated>2018-11-25T13:42:58.720Z</updated>
    
    <content type="html"><![CDATA[<p>最近在笔记本上装了deepin体验一番，看到深度商店有SSR客户端毫不犹豫的就安装上了，但是添加节点后发现并不能奏效。搜索不到解决方法，自己尝试了很多方法也没能解决，最后终于在深度商店的应用评论里看到了解决办法。  </p><p>首先保证客户端设置正确，在添加节点信息之后，软件默认的本地端口是0，这里需要改为1080。<br><img src="https://i.loli.net/2018/11/25/5bfaa5fc3cc94.png" alt="01.png"><br>然后到系统设置中，选择网络，设置系统代理模式为手动，将Socks代理参数改为127.0.0.1，端口改为1080。<br><img src="https://i.loli.net/2018/11/25/5bfaa6dc4926d.png" alt="02.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在笔记本上装了deepin体验一番，看到深度商店有SSR客户端毫不犹豫的就安装上了，但是添加节点后发现并不能奏效。搜索不到解决方法，自己尝试了很多方法也没能解决，最后终于在深度商店的应用评论里看到了解决办法。  &lt;/p&gt;
&lt;p&gt;首先保证客户端设置正确，在添加节点信息之后
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="deepin" scheme="https://cyneliu.github.io/tags/deepin/"/>
    
      <category term="ssr" scheme="https://cyneliu.github.io/tags/ssr/"/>
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>安装VMware后没有虚拟网卡的解决方法</title>
    <link href="https://cyneliu.github.io/2018/11/22/%E5%AE%89%E8%A3%85VMware%E5%90%8E%E6%B2%A1%E6%9C%89%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://cyneliu.github.io/2018/11/22/安装VMware后没有虚拟网卡的解决方法/</id>
    <published>2018-11-22T03:27:49.000Z</published>
    <updated>2018-11-25T13:30:13.877Z</updated>
    
    <content type="html"><![CDATA[<p>这两天好几位同学找我说在安装VMware后都出现了没有VMnet虚拟网卡的问题，经过数次尝试终于找到了比较靠谱点的解决方式。</p><h1 id="还原虚拟网络设置"><a href="#还原虚拟网络设置" class="headerlink" title="还原虚拟网络设置"></a>还原虚拟网络设置</h1><p>因为每个人的电脑环境不同，问题的原因当然也不会完全一样，在发现没有虚拟网卡的情况下，最先应该尝试的方法应该是找到虚拟网络编辑器，还原默认设置，这样移除虚拟网卡又重新安装激活后有的时候就解决问题了。</p><h1 id="清理注册表和历史痕迹"><a href="#清理注册表和历史痕迹" class="headerlink" title="清理注册表和历史痕迹"></a>清理注册表和历史痕迹</h1><p>在还原默认设置没有效果之后，就可以用下面说的这个方法，清除掉VMware的痕迹了。  </p><p>为什么需要这么做呢？因为我发现出现这个问题的电脑都是之前安装过VMware的，然后保留了注册表和部分历史文件的。  </p><h2 id="卸载VMware"><a href="#卸载VMware" class="headerlink" title="卸载VMware"></a>卸载VMware</h2><p>首先将VMware卸载掉，推荐使用专门的卸载工具，在卸载的同时会清理掉残留的文件和注册表等，当然没有卸载工具的话也没有关系，按照下面的步骤继续做就ok。</p><h2 id="清理注册表"><a href="#清理注册表" class="headerlink" title="清理注册表"></a>清理注册表</h2><p>使用专门的注册表清理工具清理掉VMware留下的注册表，这里我用的是CCleaner，直接百度找一个靠谱的网站下载就行，打开CCleaner之后点击注册表，扫描问题，等待扫描完成后选择修复选定的问题。这里会弹出提示询问你是否需要备份注册表，这里根据自己的需要选择就可以，我个人感觉没有必要去备份。最后点击修复所有问题，VMware残留的注册表就被删除掉了。  </p><h2 id="清理残留文件"><a href="#清理残留文件" class="headerlink" title="清理残留文件"></a>清理残留文件</h2><p>打开系统盘，搜索“vmware”，等待搜索完成后将找到的所有文件删除，可能会有一些文件无法删除，跳过这些文件就行。 </p><h2 id="重启计算机"><a href="#重启计算机" class="headerlink" title="重启计算机"></a>重启计算机</h2><p>推荐在这时候重启电脑，因为不重启的话重新安装上VMware后还是会没有网卡，给一台重装的时候就忘记了重启，安装后发现还是没有虚拟网卡，在安装之后重启之后就有了。所以最后重启应该也是可以的，但是不能没有这个操作。</p><h2 id="重新安装VMware"><a href="#重新安装VMware" class="headerlink" title="重新安装VMware"></a>重新安装VMware</h2><p>最后重新安装上VMware，打开网络适配器，看到你的VMnet1和VMnet8网卡，就说明成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天好几位同学找我说在安装VMware后都出现了没有VMnet虚拟网卡的问题，经过数次尝试终于找到了比较靠谱点的解决方式。&lt;/p&gt;
&lt;h1 id=&quot;还原虚拟网络设置&quot;&gt;&lt;a href=&quot;#还原虚拟网络设置&quot; class=&quot;headerlink&quot; title=&quot;还原虚拟网络
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="VMware" scheme="https://cyneliu.github.io/tags/VMware/"/>
    
      <category term="虚拟网卡" scheme="https://cyneliu.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于Win2012在VMware环境下部署DHCP服务器的问题</title>
    <link href="https://cyneliu.github.io/2018/11/20/%E5%85%B3%E4%BA%8EWin2012%E5%9C%A8VMware%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cyneliu.github.io/2018/11/20/关于Win2012在VMware环境下部署DHCP服务器的问题/</id>
    <published>2018-11-20T08:35:46.000Z</published>
    <updated>2018-11-20T08:51:36.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端无法获取来自DHCP地址池的正确ip"><a href="#客户端无法获取来自DHCP地址池的正确ip" class="headerlink" title="客户端无法获取来自DHCP地址池的正确ip"></a>客户端无法获取来自DHCP地址池的正确ip</h1><p>昨天在VMware WorkStation的Server 2012安装完DHCP服务之后，使用另一台虚拟机测试时怎么都获取不到正确的ip，给到的是一个不同于DHCP地址池的其它子网的ip地址，两个小时愣是没找出原因。  </p><p>今天早上终于找到了原因，在这里记录一下。</p><h1 id="原因简述"><a href="#原因简述" class="headerlink" title="原因简述"></a>原因简述</h1><p>VMware中的VMnet虚拟网卡默认开启了本地DHCP服务，虚拟机在使用dhcp自动获取ip时是从VMnet的本地dhcp拿到的ip地址，因为每个人的VMnet网卡设置的网段不一样，获取的ip地址就是VMnet设置的网段，比如我的VMnet子网地址是192.168.138.0，我拿到的ip地址就是这个网段内的地址。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><img src="https://i.loli.net/2018/11/20/5bf3caebf40da.png" alt="01.png"><br>打开虚拟网络编辑器，选择你正在使用的虚拟网卡，比如我使用的是仅主机模式，对应的就是我的VMnet1网卡。更改设置，将“使用本地DHCP服务将IP分配给虚拟机”取消勾选就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;客户端无法获取来自DHCP地址池的正确ip&quot;&gt;&lt;a href=&quot;#客户端无法获取来自DHCP地址池的正确ip&quot; class=&quot;headerlink&quot; title=&quot;客户端无法获取来自DHCP地址池的正确ip&quot;&gt;&lt;/a&gt;客户端无法获取来自DHCP地址池的正确ip&lt;/
      
    
    </summary>
    
      <category term="服务器" scheme="https://cyneliu.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Windows Server" scheme="https://cyneliu.github.io/tags/Windows-Server/"/>
    
      <category term="DHCP" scheme="https://cyneliu.github.io/tags/DHCP/"/>
    
      <category term="VMware" scheme="https://cyneliu.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>科学上网工具 - WireGuard</title>
    <link href="https://cyneliu.github.io/2018/11/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B7%A5%E5%85%B7-WireGuard/"/>
    <id>https://cyneliu.github.io/2018/11/14/科学上网工具-WireGuard/</id>
    <published>2018-11-14T12:22:33.000Z</published>
    <updated>2018-11-14T12:57:37.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WireGuard是什么？"><a href="#WireGuard是什么？" class="headerlink" title="WireGuard是什么？"></a>WireGuard是什么？</h1><p>WireGuard是一个构建快速、现代、安全的VPN的协议和工具套件，它具有以下优点：</p><blockquote></blockquote><p>使用最先进的加密技术，防范攻击（RSA，SHA广被诟病都将被淘汰）<br>性能远超OpenVPN<br>效率极高，WireGuard协议作为Linux内核模块运行<br>通用用途，支持嵌入式和非嵌入式设备<br>跨平台，初期只在Linux平台发布，现已支持所有平台<br>易用，用过OpenVPN等工具集的人都明白这其中的痛苦<br>工作在3层（链路层），支持漫游，地址变更对用户无感知，使用更简单，切换更平滑<br>使用UDP传输数据，轻量、高效、节能、节省带宽（适用于 IOT 领域）<br>基于GPLv2Linux Kernel 基于 GPLv2）免费开源  </p><p>Linus Torvalds对WireGuard的评价：</p><blockquote><p>Can I just once again state my love for it and hope it gets merged soon? Maybe the code isn’t perfect, but I’ve skimmed it, and compared to the horrors that are OpenVPN and IPSec, it’s a work of art.</p></blockquote><h1 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h1><h2 id="脚本要求"><a href="#脚本要求" class="headerlink" title="脚本要求"></a>脚本要求</h2><blockquote><p>仅适用于centos7<br>vps架构必须为KVM<br>centos7的内核大部分为3.10，不能正确安装，必须升级（已经集成在脚本中）</p></blockquote><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>1、下载并执行脚本：</p><blockquote></blockquote><pre><code>wget https://raw.githubusercontent.com/yobabyshark/wireguard/master/wireguard_install.sh &amp;&amp; chmod +x wireguard_install.sh &amp;&amp; ./wireguard_install.sh</code></pre><p><img src="https://i.loli.net/2018/11/14/5bec1723904fd.png" alt="01.png"></p><p>2、输入“1”升级内核，按照提示重启。  </p><p>3、重启完成后，再次执行脚本：</p><blockquote></blockquote><pre><code>./wireguard_install.sh</code></pre><p>4、输入“2”安装WireGuard。  </p><p>5、使用ftp工具连接vps，将<strong>/etc/wireguard</strong>目录下的client.conf下载到本地。</p><p>6、下载安装TunSafe，这是一个windows端的第三方客户端，因为官方windows版本的还没开发完成，先用这个软件代替，TunSafe已经开源，可以放心使用。<br>官网下载：<a href="https://tunsafe.com/download" target="_blank" rel="noopener">TunSafe</a></p><p>7、打开TunSafe，单击file，选择import file，将下载的client.conf导入到软件中。  </p><p>8、导入后会自动进行连接，进入全局代理模式，也就是所有流量都会被代理。</p><h1 id="其它平台客户端"><a href="#其它平台客户端" class="headerlink" title="其它平台客户端"></a>其它平台客户端</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>1、下载WireGuard安卓客户端：  </p><blockquote><p>Android客户端：<a href="https://f-droid.org/repo/com.wireguard.android_439.apk" target="_blank" rel="noopener">点此下载</a></p></blockquote><p>2、打开app，点击加号导入client.conf文件。</p><blockquote><p>这里可能会提示错误，原因是没有文件操作权限，去权限管理里给软件勾上存储权限即可。</p></blockquote><h1 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h1><p>Youtube视频地址：<a href="https://youtu.be/A1tdPsdBATw" target="_blank" rel="noopener">点击观看</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WireGuard是什么？&quot;&gt;&lt;a href=&quot;#WireGuard是什么？&quot; class=&quot;headerlink&quot; title=&quot;WireGuard是什么？&quot;&gt;&lt;/a&gt;WireGuard是什么？&lt;/h1&gt;&lt;p&gt;WireGuard是一个构建快速、现代、安全的VPN
      
    
    </summary>
    
      <category term="VPS" scheme="https://cyneliu.github.io/categories/VPS/"/>
    
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="VPS" scheme="https://cyneliu.github.io/tags/VPS/"/>
    
      <category term="WireGuard" scheme="https://cyneliu.github.io/tags/WireGuard/"/>
    
  </entry>
  
  <entry>
    <title>简单识别Linux vps架构(xen,openvz,kvm)</title>
    <link href="https://cyneliu.github.io/2018/11/14/%E7%AE%80%E5%8D%95%E8%AF%86%E5%88%ABLinux-vps%E6%9E%B6%E6%9E%84-xen-openvz-kvm/"/>
    <id>https://cyneliu.github.io/2018/11/14/简单识别Linux-vps架构-xen-openvz-kvm/</id>
    <published>2018-11-14T12:10:11.000Z</published>
    <updated>2018-11-14T12:16:49.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装virt-what"><a href="#安装virt-what" class="headerlink" title="安装virt-what"></a>安装virt-what</h1><blockquote></blockquote><pre><code>yum -y install virt-what</code></pre><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><blockquote></blockquote><pre><code>virt-what</code></pre><p>如图，这台vps是基于xen架构。<br><img src="https://i.loli.net/2018/11/14/5bec12288d430.png" alt="01.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装virt-what&quot;&gt;&lt;a href=&quot;#安装virt-what&quot; class=&quot;headerlink&quot; title=&quot;安装virt-what&quot;&gt;&lt;/a&gt;安装virt-what&lt;/h1&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="VPS" scheme="https://cyneliu.github.io/categories/VPS/"/>
    
    
      <category term="VPS" scheme="https://cyneliu.github.io/tags/VPS/"/>
    
      <category term="linux" scheme="https://cyneliu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈几种快充技术</title>
    <link href="https://cyneliu.github.io/2018/11/07/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8D%E5%BF%AB%E5%85%85%E6%8A%80%E6%9C%AF/"/>
    <id>https://cyneliu.github.io/2018/11/07/浅谈几种快充技术/</id>
    <published>2018-11-07T11:00:56.000Z</published>
    <updated>2018-11-07T11:50:05.314Z</updated>
    
    <content type="html"><![CDATA[<p>原来的充电宝丢了，今天又在某宝上溜达买了一个，溜达的时候发现了好多的新名词，就索性查了一下，整理一下写在这里了。</p><h1 id="PD快充协议"><a href="#PD快充协议" class="headerlink" title="PD快充协议"></a>PD快充协议</h1><p>PD充电协议是USB-IF组织公布的功率传输协议，它可以使目前默认最大功率5V/2A的type-c接口提高到100W，同时谷歌宣布Android7.0以上的手机搭载的快充协议必须支持PD协议，意在统一快充市场。  </p><p>USB-PowerDelivery（USBPD）是目前主流的快充协议之一。是由USB-IF组织制定的一种快速充电规范。USBPD透过USB电缆和连接器增加电力输送，扩展USB应用中的电缆总线供电能力。该规范可实现更高的电压和电流，输送的功率最高可达100瓦，并可以自由的改变电力的输送方向。  </p><p>USBPD和Type-C的关系。经常会有人把USBPD和Type-C放在一起谈，甚至就把Type-C充电器叫做PD充电器。USBPD和Type-C其实是两码事，USBPD是一种快速充电协议，而Type-C则是一种新的接口规范。Type-C接口默认最大支持5V/3A，但在实现了USBPD协议以后，能够使输出功率最大支持到前文提到的100W。所以现在许多实用Type-C接口的设备都会支持USBPD协议。</p><p>USBPD的发展前景。USBPD现在已经发展到了USBPD3.0版本。在谷歌的推动下目USBPD已经收编了高通的QC快充协议，并获得了中国工信部的支持。</p><h1 id="QC-1-0-2-0-3-0"><a href="#QC-1-0-2-0-3-0" class="headerlink" title="QC 1.0/2.0/3.0"></a>QC 1.0/2.0/3.0</h1><p>Qualcomm Quick Charge 3.0（下文简称QC 3.0）快充技术不知不觉已经是Qualcomm第三代快充技术，前几年快充技术还没百家齐放的时候，QC门派的关注度还是蛮高的。前几年QC 1.0和QC 2.0仍然比较受手机厂商和消费者欢迎。尤其是QC 2.0技术，如今很多手机厂商的快充技术其实都是基于QC 2.0基础上延伸出来的，例如下文将会提到的Moto涡轮快充和vivo双引擎闪充。  </p><blockquote></blockquote><p><strong>QC 1.0</strong>：最高支持5V/2A充电功率。</p><blockquote><p><strong>QC 2.0</strong>：兼容5V/9V/12V/20V四档充电电压。  </p></blockquote><p><strong>QC 3.0</strong>：以200mV增量为一档，提供从3.6V到20V电压的灵活选择，让手机厂商能够根据自身需求调整最佳电压，达到预期电流，提供充电效率同时降低功耗和发热。目前市面上标配QC 3.0快充头并支持该协议手机有LG G5、小米手机5等。</p><h1 id="MTK：PumpExpress-Plus"><a href="#MTK：PumpExpress-Plus" class="headerlink" title="MTK：PumpExpress Plus"></a>MTK：PumpExpress Plus</h1><p>说完高通的，再来看看联发科的快充技术。  </p><p>联发科MTP Pump Express Plus快充技术，原理与高通QC快充基本相同，都是在恒定电流的同时，通过提升充电电压来获得更大的充电功率。最新的Pump Express 3.0宣称能够在20分钟内为智能手机充满70%电量，同时相比PumpExpress Plus功耗减少50%，间接降低发热。  </p><p>PumpExpress允许充电器根据电流决定充电所需的初始电压，通过内置的PMIC电源管理集成电路发出脉冲电流指令给充电器，调整输出电压，逐渐增加到最大充电电流。相比QC 3.0的200mV为一档增量的做法，PumpExpress 3.0电压微调幅度仅为10mV，理论最高可提供5A充电电流。  </p><h1 id="手机厂商快充协议"><a href="#手机厂商快充协议" class="headerlink" title="手机厂商快充协议"></a>手机厂商快充协议</h1><blockquote></blockquote><p>华为：FCP（Fast Charger Protocol）<br>三星：AFC<br>一加：DASH极速闪充<br>vivo:双引擎闪充<br>OPPO：VOOC闪充技术<br>Moto：涡轮快充技术<br>魅族：mCharge 3.0  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原来的充电宝丢了，今天又在某宝上溜达买了一个，溜达的时候发现了好多的新名词，就索性查了一下，整理一下写在这里了。&lt;/p&gt;
&lt;h1 id=&quot;PD快充协议&quot;&gt;&lt;a href=&quot;#PD快充协议&quot; class=&quot;headerlink&quot; title=&quot;PD快充协议&quot;&gt;&lt;/a&gt;PD快充
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="快充" scheme="https://cyneliu.github.io/tags/%E5%BF%AB%E5%85%85/"/>
    
  </entry>
  
</feed>
