<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyne&#39;s Blog</title>
  
  <subtitle>越努力，越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cyneliu.github.io/"/>
  <updated>2019-01-26T08:44:59.684Z</updated>
  <id>https://cyneliu.github.io/</id>
  
  <author>
    <name>Cyne Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx反向代理</title>
    <link href="https://cyneliu.github.io/2019/01/26/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://cyneliu.github.io/2019/01/26/Nginx反向代理/</id>
    <published>2019-01-26T07:19:40.000Z</published>
    <updated>2019-01-26T08:44:59.684Z</updated>
    
    <content type="html"><![CDATA[<p>最近我用国内阿里云的服务器搭建了几个站点，但是由于没有备案所以只能采用域名+端口的方式访问，这样访问起来很别扭，于是就想到了使用Nginx反向代理。</p><h1 id="环境简介"><a href="#环境简介" class="headerlink" title="环境简介"></a>环境简介</h1><p><img src="https://i.loli.net/2019/01/26/5c4c0e2cc5892.png" alt="00.png"><br>做了一个简陋的拓扑图说明一下，图中的两台服务器都是处于公网的vps，都具有公网的ip地址，其中WEB服务器就是我在阿里云的未备案的vps，另一台是一台位于境外的vps，这里用来做Nginx反向代理。</p><h1 id="在代理服务器安装nginx"><a href="#在代理服务器安装nginx" class="headerlink" title="在代理服务器安装nginx"></a>在代理服务器安装nginx</h1><p>安装所需环境，详细的安装步骤可以参考<a href="https://www.cnblogs.com/kaid/p/7640723.html" target="_blank" rel="noopener">这里</a>：</p><blockquote></blockquote><pre><code>yum install gcc zlib zlib-devel openssl openssl-devel -y</code></pre><p>下载nginx安装包：</p><blockquote></blockquote><pre><code>wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</code></pre><p>解压：</p><blockquote></blockquote><pre><code>tar -zxvf nginx-1.10.1.tar.gzcd nginx-1.10.1</code></pre><p>使用默认配置：</p><blockquote></blockquote><pre><code>./configure</code></pre><p>编译安装：</p><blockquote></blockquote><pre><code>makemake install</code></pre><p>查找安装路径：</p><blockquote></blockquote><pre><code>whereis nginx</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1167725ea.png" alt="01.png"></p><p>根据回显的信息进入安装路径，在nginx目录下有以下文件，我们主要用到的是sbin(执行程序)和conf(配置文件)两个文件夹：<br><img src="https://i.loli.net/2019/01/26/5c4c1276be783.png" alt="02.png"><br>nginx常用命令：</p><blockquote></blockquote><pre><code>./nginx #启动nginx./nginx -s stop #此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程./nginx -s quit #此方式停止步骤是待nginx进程处理任务完毕进行停止./nginx -s reload #重载配置文件./nginx -v #查看版本信息</code></pre><p>执行在sbin目录下执行./nginx启动Nginx，访问此vps的ip地址出现如下页面说明安装成功：<br><img src="https://i.loli.net/2019/01/26/5c4c1514634dd.png" alt="03.png"><br>设置开机启动：</p><blockquote></blockquote><pre><code>vi /etc/rc.local</code></pre><p>增加一行：/usr/local/nginx/sbin/nginx<br>设置执行权限：</p><blockquote></blockquote><pre><code>chmod 755 rc.local</code></pre><h1 id="配置代理服务器"><a href="#配置代理服务器" class="headerlink" title="配置代理服务器"></a>配置代理服务器</h1><p>这里有两种配置方法，一种是反向代理单个域名，通过这一个域名访问WEB服务器的单一服务；另一种则是代理多个域名，访问相应的域名时将请求代理到响应ip的响应端口。</p><h2 id="代理单个域名"><a href="#代理单个域名" class="headerlink" title="代理单个域名"></a>代理单个域名</h2><p>编辑默认配置文件：</p><blockquote></blockquote><pre><code>vim /usr/local/nginx/conf/nginx.conf</code></pre><p>将以下内容添加到如下图所示的部分：</p><blockquote></blockquote><pre><code>proxy_pass http://172.18.78.14:6080;proxy_http_version 1.1;proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection &quot;Upgrade&quot;;</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1914b6b3b.png" alt="04.png"></p><p>重载配置：</p><blockquote></blockquote><pre><code>./nginx -s reload</code></pre><p>最后将域名解析到代理服务器的ip地址即可。</p><h1 id="代理多个域名"><a href="#代理多个域名" class="headerlink" title="代理多个域名"></a>代理多个域名</h1><p>因为代理多个域名配置较多，我们新建一个配置文件方便查看：</p><blockquote></blockquote><pre><code>vim /usr/local/nginx/conf/reverse-proxy.conf</code></pre><p>粘贴如下内容：</p><blockquote></blockquote><pre><code>server {    listen 80;    server_name a.test.com;    location /{        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8081;        #proxy_pass http://tomcat;    }    access_log logs/tomcat1_access.log;}server {    listen 80;    server_name b.test.com;    location /{        proxy_redirect off;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8082;        #proxy_pass http://tomcat;    }    access_log logs/tomcat2_access.log;}</code></pre><p>需要注意的是，我在一开始的配置时同时代理了主域名即子域名，即test.com和a.test.com，这样配置的结果就是主域名无法进行代理，这种情况下如果还想使用主域名，可以使用www域名，即同时代理<a href="http://www.test.com和a.test.com等。" target="_blank" rel="noopener">www.test.com和a.test.com等。</a>  </p><p>修改nginx.conf,导入刚才写的配置,在http{}中加入如下内容：</p><blockquote></blockquote><pre><code>include reverse-proxy.conf;</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c1d8b15629.png" alt="05.png"></p><p>最后重载配置即可：</p><blockquote></blockquote><pre><code>./nginx -s reload</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近我用国内阿里云的服务器搭建了几个站点，但是由于没有备案所以只能采用域名+端口的方式访问，这样访问起来很别扭，于是就想到了使用Nginx反向代理。&lt;/p&gt;
&lt;h1 id=&quot;环境简介&quot;&gt;&lt;a href=&quot;#环境简介&quot; class=&quot;headerlink&quot; title=&quot;环境
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="Nginx" scheme="https://cyneliu.github.io/tags/Nginx/"/>
    
      <category term="反向代理" scheme="https://cyneliu.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7最小化安装后找不到ifconfig命令</title>
    <link href="https://cyneliu.github.io/2019/01/11/CentOS7%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0ifconfig%E5%91%BD%E4%BB%A4/"/>
    <id>https://cyneliu.github.io/2019/01/11/CentOS7最小化安装后找不到ifconfig命令/</id>
    <published>2019-01-11T11:43:09.000Z</published>
    <updated>2019-01-11T11:44:50.941Z</updated>
    
    <content type="html"><![CDATA[<p>“ifconfig”命令用于配置GNU/Linux系统的网络接口。它显示网络接口卡的详细信息，包括IP地址，MAC地址，以及网络接口卡状态之类。但是，该命令已经过时了，而且在最小化版本的RHEL 7以及它的克隆版本CentOS 7，Oracle Linux 7和Scientific Linux 7中也找不到该命令。</p><h1 id="使用ip-addr和ip-link查看网卡信息"><a href="#使用ip-addr和ip-link查看网卡信息" class="headerlink" title="使用ip addr和ip link查看网卡信息"></a>使用ip addr和ip link查看网卡信息</h1><blockquote></blockquote><pre><code>ip addr # 查看网卡细节ip linkip -s link # 查看网络接口统计数据</code></pre><h1 id="依然使用ifconfig"><a href="#依然使用ifconfig" class="headerlink" title="依然使用ifconfig"></a>依然使用ifconfig</h1><p>如果说我们还是想使用ifconfig命令，我们就需要安装相应的包来使用。首先查看哪些包提供ifconfig命令：</p><blockquote></blockquote><pre><code>yum provides ifconfig</code></pre><p>或者：</p><blockquote></blockquote><pre><code>yum whatprovides ifconfig</code></pre><p>根据输出信息安装相应的包即可使用ifconfig命令。  </p><p>参考自：<a href="https://linux.cn/article-3631-1.html" target="_blank" rel="noopener">Linux中国</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“ifconfig”命令用于配置GNU/Linux系统的网络接口。它显示网络接口卡的详细信息，包括IP地址，MAC地址，以及网络接口卡状态之类。但是，该命令已经过时了，而且在最小化版本的RHEL 7以及它的克隆版本CentOS 7，Oracle Linux 7和Scient
      
    
    </summary>
    
      <category term="Linux" scheme="https://cyneliu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://cyneliu.github.io/tags/CentOS/"/>
    
      <category term="ifconfig" scheme="https://cyneliu.github.io/tags/ifconfig/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04安装包方式安装Open vSwitch</title>
    <link href="https://cyneliu.github.io/2018/12/28/Ubuntu16-04%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85Open-vSwitch/"/>
    <id>https://cyneliu.github.io/2018/12/28/Ubuntu16-04压缩包方式安装Open-vSwitch/</id>
    <published>2018-12-28T09:15:02.000Z</published>
    <updated>2018-12-28T09:47:43.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载安装Open-vSwitch"><a href="#下载安装Open-vSwitch" class="headerlink" title="下载安装Open vSwitch"></a>下载安装Open vSwitch</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote></blockquote><pre><code>apt-get updateapt-get install build-essential</code></pre><h2 id="下载解压安装包"><a href="#下载解压安装包" class="headerlink" title="下载解压安装包"></a>下载解压安装包</h2><p>下载Open vSwitch安装包：<a href="http://www.openvswitch.org/download/" target="_blank" rel="noopener">Open vSwitch官网下载地址</a><br>这里我下载的是最新的2.10.1版本：</p><blockquote></blockquote><pre><code>wget https://www.openvswitch.org/releases/openvswitch-2.10.1.tar.gztar -xzvf openvswitch-2.10.1.tar.gz</code></pre><h2 id="构建基于Linux内核的交换机"><a href="#构建基于Linux内核的交换机" class="headerlink" title="构建基于Linux内核的交换机"></a>构建基于Linux内核的交换机</h2><blockquote></blockquote><pre><code>cd openvswitch-2.10.1./configure --with-linux=/lib/modules/&quot;uname -r&quot;/build# 注意这条命令中的&quot;uname -r&quot;是输出当前系统的版本号# 比如我执行&quot;uname -r&quot;后的结果为4.4.0-21-generic，那么我应该执行的命令即为：# ./configure --with-linux=/lib/modules/4.4.0-21-generic/build</code></pre><h2 id="编译安装Open-vSwitch"><a href="#编译安装Open-vSwitch" class="headerlink" title="编译安装Open vSwitch"></a>编译安装Open vSwitch</h2><blockquote></blockquote><pre><code>makemake install</code></pre><h2 id="加载openvswitch-ko模块-遇到错误"><a href="#加载openvswitch-ko模块-遇到错误" class="headerlink" title="加载openvswitch.ko模块(遇到错误)"></a>加载openvswitch.ko模块(遇到错误)</h2><p>如果需要OVS支持VLAN功能，还需要加载openvswitch.ko模块，如果不需要，此步可以忽略。  </p><blockquote></blockquote><pre><code>modprobe greinsmod datapath/linux/openvswitch.ko</code></pre><p>我在执行第二条命令时遇到了如下错误：</p><blockquote></blockquote><pre><code>insmod: ERROR: could not insert module openvswitch.ko: Unkown symbol in module</code></pre><p>google了几个方法都没能成功解决问题，有人说是bug，也有说是因为兼容性问题，因为我暂时用不到VLAN功能，就暂时跳过此步骤了。</p><h2 id="安装并加载构建的内核模块"><a href="#安装并加载构建的内核模块" class="headerlink" title="安装并加载构建的内核模块"></a>安装并加载构建的内核模块</h2><blockquote></blockquote><pre><code>make modules_install/sbin/modprobe openvswitch</code></pre><h2 id="使用ovsdb工具初始化配置数据库"><a href="#使用ovsdb工具初始化配置数据库" class="headerlink" title="使用ovsdb工具初始化配置数据库"></a>使用ovsdb工具初始化配置数据库</h2><blockquote></blockquote><pre><code>ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema# 在执行此命令时报错没有此文件夹，我直接手动创建了对应的文件夹：# mkdir -p /usr/local/etc/openvswitch</code></pre><h1 id="启动Open-vSwitch"><a href="#启动Open-vSwitch" class="headerlink" title="启动Open vSwitch"></a>启动Open vSwitch</h1><h2 id="启动ovsdb-server配置数据库"><a href="#启动ovsdb-server配置数据库" class="headerlink" title="启动ovsdb-server配置数据库:"></a>启动ovsdb-server配置数据库:</h2><blockquote></blockquote><pre><code>ovsdb-server -v --remote=punix:/usr/local/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,Open_vSwitch,manager_options --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --pidfile --detach --log-file# 这里同样报错没有此文件夹，同样手动创建了相应的文件夹</code></pre><p>首次用ovsdb-tool创建数据库时需用ovs-vsctl命令初始化下数据库:</p><blockquote></blockquote><pre><code>ovs-vsctl --no-wait init</code></pre><h2 id="启动OVS主进程"><a href="#启动OVS主进程" class="headerlink" title="启动OVS主进程:"></a>启动OVS主进程:</h2><blockquote></blockquote><pre><code>ovs-vswitchd --pidfile --detach --log-file</code></pre><h2 id="查看OVS进程是否启动"><a href="#查看OVS进程是否启动" class="headerlink" title="查看OVS进程是否启动:"></a>查看OVS进程是否启动:</h2><blockquote></blockquote><pre><code>ps aux|grep ovs</code></pre><h2 id="查看所安装OVS的版本号"><a href="#查看所安装OVS的版本号" class="headerlink" title="查看所安装OVS的版本号:"></a>查看所安装OVS的版本号:</h2><blockquote></blockquote><pre><code>ovs-vsctl --version</code></pre><p>至此，Open vSwitch就安装完成了，安装过程中的几个小问题本次没有解决，希望之后能找到解决办法。最后再补充一个更简单的方式——使用apt install的方式直接安装：</p><blockquote></blockquote><pre><code>apt-get install openvswitch-switch</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载安装Open-vSwitch&quot;&gt;&lt;a href=&quot;#下载安装Open-vSwitch&quot; class=&quot;headerlink&quot; title=&quot;下载安装Open vSwitch&quot;&gt;&lt;/a&gt;下载安装Open vSwitch&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="Open vSwitch" scheme="https://cyneliu.github.io/tags/Open-vSwitch/"/>
    
  </entry>
  
  <entry>
    <title>ESXI安装OpenWrt/LEDE实现软路由功能</title>
    <link href="https://cyneliu.github.io/2018/12/23/ESXI%E5%AE%89%E8%A3%85OpenWrt-LEDE%E5%AE%9E%E7%8E%B0%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"/>
    <id>https://cyneliu.github.io/2018/12/23/ESXI安装OpenWrt-LEDE实现软路由功能/</id>
    <published>2018-12-23T10:23:17.000Z</published>
    <updated>2018-12-23T12:04:24.631Z</updated>
    
    <content type="html"><![CDATA[<p>最近部署一套环境需要从国外的服务器下载文件，因为众所周知的原因，速度慢到几kb不说，还经常传输失败，但一台一台的设置科学上网又比较麻烦，所以就有了设置一个可以使用酸酸乳的软路由作为网关的想法。  </p><p>实验室硬件不支持肯定首先想到的就是软路由了，常用的比较有名的当属RouterOS了，再就是<a href="http://www.hi-spider.com/zh" target="_blank" rel="noopener">海蜘蛛</a>和<a href="http://www.ikuai8.com/" target="_blank" rel="noopener">爱快</a>等等了，但是貌似都不能用酸酸乳，最后找到的就是OpenWrt/LEDE这个方案了，下面简单整理一下过程。  </p><h1 id="下载-vmdk文件"><a href="#下载-vmdk文件" class="headerlink" title="下载*.vmdk文件"></a>下载*.vmdk文件</h1><p>感谢koolshare论坛的大佬给出的硬盘文件，原帖地址：<a href="http://koolshare.cn/thread-67584-1-8.html" target="_blank" rel="noopener">http://koolshare.cn/thread-67584-1-8.html</a>  </p><p>下载地址：<a href="https://pan.baidu.com/s/1kVHJ3gj#list/path=%2F" target="_blank" rel="noopener">百度网盘</a>（4kqa）</p><h1 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h1><p>打开vSphere客户端，新建虚拟机，因为之后需要换硬盘文件，所以这里配置什么的就无所谓了，直接选择典型就可以了。客户机操作系统我这里选择的是“其他Linux(64位)”：<br><img src="https://i.loli.net/2018/12/23/5c1f721de8dfe.png" alt="01.png"><br>然后网卡根据需要设置成两个或两个以上，我这里没有特殊需要，两个网卡一个WAN口一个LAN口就可以了：<br><img src="https://i.loli.net/2018/12/23/5c1f721df2c97.png" alt="02.png"><br>之后默认即可，完成虚拟机创建。</p><h1 id="修改硬盘文件"><a href="#修改硬盘文件" class="headerlink" title="修改硬盘文件"></a>修改硬盘文件</h1><p>在服务器存储中找到刚刚创建的虚拟机的虚拟磁盘文件（.vmdk）并删除：<br><img src="https://i.loli.net/2018/12/23/5c1f732863c64.png" alt="03.png"><br>在当前目录上传之前下载的两个.vmdk文件，上传之后会被合并为一个文件：<br><img src="https://i.loli.net/2018/12/23/5c1f741fb2876.png" alt="04.png"><br>编辑虚拟机设置，添加现有虚拟磁盘，在存储中找到刚刚上传的文件完成添加并删除原来的硬盘：<br><img src="https://i.loli.net/2018/12/23/5c1f7516ded5b.png" alt="05.png"><br>打开电源即可开始安装。</p><h1 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h1><p>安装完成后按回车进入：<br><img src="https://i.loli.net/2018/12/23/5c1f76226f85a.png" alt="06.png"><br>网络的配置文件在“/etc/config/network”下，可以根据需要进行修改：<br><img src="https://i.loli.net/2018/12/23/5c1f76f5e44c4.png" alt="07.png"><br>这里我没有做任何更改，因为上接网络中有DHCP服务器，所以自动获取了一个WAN口ip，如果没有DHCP需要手工设置ip地址，LAN口ip使用默认的192.168.1.1。</p><h1 id="登录WEB页面"><a href="#登录WEB页面" class="headerlink" title="登录WEB页面"></a>登录WEB页面</h1><p>我们需要使用LAN口的ip地址进入WEB页面，所以我把一台Windows设备的ip地址设置为192.168.1.2/24，网关192.168.1.1。  </p><p>打开浏览器访问192.168.1.1，用户名：admin，密码：koolshare。<br><img src="https://i.loli.net/2018/12/23/5c1f78cab38bd.png" alt="08.png"></p><p>开启SS服务并将需要和谐上网的虚拟机修改网关为LAN口地址，大功告成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近部署一套环境需要从国外的服务器下载文件，因为众所周知的原因，速度慢到几kb不说，还经常传输失败，但一台一台的设置科学上网又比较麻烦，所以就有了设置一个可以使用酸酸乳的软路由作为网关的想法。  &lt;/p&gt;
&lt;p&gt;实验室硬件不支持肯定首先想到的就是软路由了，常用的比较有名的当
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="ESXI" scheme="https://cyneliu.github.io/tags/ESXI/"/>
    
      <category term="OpenWrt" scheme="https://cyneliu.github.io/tags/OpenWrt/"/>
    
      <category term="软路由" scheme="https://cyneliu.github.io/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    
      <category term="虚拟化" scheme="https://cyneliu.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装VNC服务端程序</title>
    <link href="https://cyneliu.github.io/2018/12/21/CentOS7%E5%AE%89%E8%A3%85VNC%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F/"/>
    <id>https://cyneliu.github.io/2018/12/21/CentOS7安装VNC服务端程序/</id>
    <published>2018-12-21T11:28:27.000Z</published>
    <updated>2018-12-21T12:11:22.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检查是否已安装VNC"><a href="#检查是否已安装VNC" class="headerlink" title="检查是否已安装VNC"></a>检查是否已安装VNC</h1><blockquote></blockquote><pre><code>rpm -q tigervnc tigervnc-server</code></pre><h1 id="安装X-Window"><a href="#安装X-Window" class="headerlink" title="安装X-Window"></a>安装X-Window</h1><blockquote></blockquote><pre><code>yum check-updateyum groupinstall &quot;X Window System&quot; #这里可能会有警告提示，忽略即可yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fontsunlink /etc/systemd/system/default.targetln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.targetreboot #重启机器</code></pre><h1 id="安装VNC服务端"><a href="#安装VNC服务端" class="headerlink" title="安装VNC服务端"></a>安装VNC服务端</h1><blockquote></blockquote><pre><code>yum install tigervnc-server -y</code></pre><h1 id="从VNC备份库中复制service文件到系统service服务管理目录下"><a href="#从VNC备份库中复制service文件到系统service服务管理目录下" class="headerlink" title="从VNC备份库中复制service文件到系统service服务管理目录下"></a>从VNC备份库中复制service文件到系统service服务管理目录下</h1><blockquote></blockquote><pre><code>cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service  #复制并重命名为vncserver@:1.service</code></pre><h1 id="修改vncserver-1-service文件"><a href="#修改vncserver-1-service文件" class="headerlink" title="修改vncserver@:1.service文件"></a>修改vncserver@:1.service文件</h1><p>使用如下信息覆盖原信息：</p><blockquote></blockquote><pre><code>[Unit]Description=Remote desktop service (VNC)After=syslog.target network.target[Service]Type=forkingUser=rootExecStartPre=-/usr/bin/vncserver -kill %iExecStart=/sbin/runuser -l root -c &quot;/usr/bin/vncserver %i&quot; PIDFile=/root/.vnc/%H%i.pidExecStop=-/usr/bin/vncserver -kill %i[Install]WantedBy=multi-user.target</code></pre><h1 id="修改文件使配置生效"><a href="#修改文件使配置生效" class="headerlink" title="修改文件使配置生效"></a>修改文件使配置生效</h1><blockquote></blockquote><pre><code>systemctl daemon-reload</code></pre><h1 id="为vncserver-1-service设置密码"><a href="#为vncserver-1-service设置密码" class="headerlink" title="为vncserver@:1.service设置密码"></a>为vncserver@:1.service设置密码</h1><blockquote></blockquote><pre><code>vncpasswd</code></pre><h1 id="启动VNC"><a href="#启动VNC" class="headerlink" title="启动VNC"></a>启动VNC</h1><blockquote></blockquote><pre><code>systemctl enable vncserver@:1.service #设置开机启动systemctl start vncserver@:1.service #启动vnc会话服务systemctl status vncserver@:1.service #查看nvc会话服务状态systemctl stop vncserver@:1.service #关闭nvc会话服务netstat -lnt | grep 590*  </code></pre><p>5901端口已经处于监听状态：<br><img src="https://i.loli.net/2018/12/21/5c1cd3d638c69.png" alt="01.png"></p><h1 id="开启防火墙端口"><a href="#开启防火墙端口" class="headerlink" title="开启防火墙端口"></a>开启防火墙端口</h1><p>在安装后防火墙默认关掉了相应的端口，需要手动开启一下。<br>查看zone名称：</p><blockquote></blockquote><pre><code>firewall-cmd --get-active-zones</code></pre><p>允许相关端口：</p><blockquote></blockquote><pre><code>firewall-cmd --zone=public --add-port=5901/tcp --permanent #5901即为要开启的端口</code></pre><p>最后重启防火墙：</p><blockquote></blockquote><pre><code>firewall-cmd --reload</code></pre><p>确认端口号是否开启：</p><blockquote></blockquote><pre><code>firewall-cmd --query-port=5901/tcp</code></pre><h1 id="下载客户端进行连接"><a href="#下载客户端进行连接" class="headerlink" title="下载客户端进行连接"></a>下载客户端进行连接</h1><p>使用“ip::port”的方式进行连接，下图表明已经可以成功连接：<br><img src="https://i.loli.net/2018/12/21/5c1cd858e4d38.png" alt="2.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检查是否已安装VNC&quot;&gt;&lt;a href=&quot;#检查是否已安装VNC&quot; class=&quot;headerlink&quot; title=&quot;检查是否已安装VNC&quot;&gt;&lt;/a&gt;检查是否已安装VNC&lt;/h1&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rpm
      
    
    </summary>
    
      <category term="Linux" scheme="https://cyneliu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://cyneliu.github.io/tags/CentOS/"/>
    
      <category term="VNC" scheme="https://cyneliu.github.io/tags/VNC/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql8.0服务无法启动的问题</title>
    <link href="https://cyneliu.github.io/2018/11/29/%E5%85%B3%E4%BA%8Emysql8-0%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cyneliu.github.io/2018/11/29/关于mysql8-0服务无法启动的问题/</id>
    <published>2018-11-29T02:41:37.000Z</published>
    <updated>2018-11-29T03:07:43.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>如图：<br><img src="https://i.loli.net/2018/11/29/5bff526bca5e0.png" alt="02.png"><br>我下载的是mysql-8.0.13-winx64解压版本，但安装后出现如上图所示服务无法启动的问题。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>首先简单说明一下我的安装过程，将压缩包解压后在mysql的根目录创建“my.ini”，内容如下：</p><blockquote></blockquote><pre><code>[mysqld]  #basedir代表自己MySQL的安装根目录  basedir = E:\\mysql-8.0.13-winx64  #datadir代表自己MySQL的数据库保存的目录  datadir = E:\\mysql-8.0.13-winx64\\data  #port代表端口号  port = 3306  sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  </code></pre><p><img src="https://i.loli.net/2018/11/29/5bff564b8580d.png" alt="03.png"></p><p>删除根目录下自带的data文件夹，原因下面会有说明。  </p><p>然后以管理员身份运行cmd，进入mysql根目录下的bin目录中。  </p><p>移除之前安装的服务：</p><blockquote></blockquote><pre><code>mysqld -remove</code></pre><p>初始化：</p><blockquote></blockquote><pre><code>mysqld --initialize-insecure  #这里我使用的是无密的方式</code></pre><p>这个步骤会重新生成data文件夹，需要等待一会。</p><p>重新安装mysql服务：</p><blockquote></blockquote><pre><code>mysqld -install</code></pre><p>启动mysql服务：</p><blockquote></blockquote><pre><code>net start mysql</code></pre><p><img src="https://i.loli.net/2018/11/29/5bff526bc3777.png" alt="01.png"></p><p>最后说明一下删除data文件夹的原因，网上很多教程里写的是直接在配置文件中写上data文件夹的路径就可以甚至没有data文件夹自己新建的一个。  </p><p>不能说那些教程里的做法就是错的，因为版本不同的原因，情况也不尽相同，新版本在初始化时会自动生成data文件夹，如果直接使用自带的data文件夹而不删除让它自动创建的话，很容易出错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;如图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/11/29/5bff526bca5e0.p
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="mysql" scheme="https://cyneliu.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>deepin使用ssr不能和谐上网</title>
    <link href="https://cyneliu.github.io/2018/11/25/deepin%E4%BD%BF%E7%94%A8ssr%E4%B8%8D%E8%83%BD%E5%92%8C%E8%B0%90%E4%B8%8A%E7%BD%91/"/>
    <id>https://cyneliu.github.io/2018/11/25/deepin使用ssr不能和谐上网/</id>
    <published>2018-11-25T13:19:14.000Z</published>
    <updated>2018-11-25T13:42:58.720Z</updated>
    
    <content type="html"><![CDATA[<p>最近在笔记本上装了deepin体验一番，看到深度商店有SSR客户端毫不犹豫的就安装上了，但是添加节点后发现并不能奏效。搜索不到解决方法，自己尝试了很多方法也没能解决，最后终于在深度商店的应用评论里看到了解决办法。  </p><p>首先保证客户端设置正确，在添加节点信息之后，软件默认的本地端口是0，这里需要改为1080。<br><img src="https://i.loli.net/2018/11/25/5bfaa5fc3cc94.png" alt="01.png"><br>然后到系统设置中，选择网络，设置系统代理模式为手动，将Socks代理参数改为127.0.0.1，端口改为1080。<br><img src="https://i.loli.net/2018/11/25/5bfaa6dc4926d.png" alt="02.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在笔记本上装了deepin体验一番，看到深度商店有SSR客户端毫不犹豫的就安装上了，但是添加节点后发现并不能奏效。搜索不到解决方法，自己尝试了很多方法也没能解决，最后终于在深度商店的应用评论里看到了解决办法。  &lt;/p&gt;
&lt;p&gt;首先保证客户端设置正确，在添加节点信息之后
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="deepin" scheme="https://cyneliu.github.io/tags/deepin/"/>
    
      <category term="ssr" scheme="https://cyneliu.github.io/tags/ssr/"/>
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>安装VMware后没有虚拟网卡的解决方法</title>
    <link href="https://cyneliu.github.io/2018/11/22/%E5%AE%89%E8%A3%85VMware%E5%90%8E%E6%B2%A1%E6%9C%89%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://cyneliu.github.io/2018/11/22/安装VMware后没有虚拟网卡的解决方法/</id>
    <published>2018-11-22T03:27:49.000Z</published>
    <updated>2018-11-25T13:30:13.877Z</updated>
    
    <content type="html"><![CDATA[<p>这两天好几位同学找我说在安装VMware后都出现了没有VMnet虚拟网卡的问题，经过数次尝试终于找到了比较靠谱点的解决方式。</p><h1 id="还原虚拟网络设置"><a href="#还原虚拟网络设置" class="headerlink" title="还原虚拟网络设置"></a>还原虚拟网络设置</h1><p>因为每个人的电脑环境不同，问题的原因当然也不会完全一样，在发现没有虚拟网卡的情况下，最先应该尝试的方法应该是找到虚拟网络编辑器，还原默认设置，这样移除虚拟网卡又重新安装激活后有的时候就解决问题了。</p><h1 id="清理注册表和历史痕迹"><a href="#清理注册表和历史痕迹" class="headerlink" title="清理注册表和历史痕迹"></a>清理注册表和历史痕迹</h1><p>在还原默认设置没有效果之后，就可以用下面说的这个方法，清除掉VMware的痕迹了。  </p><p>为什么需要这么做呢？因为我发现出现这个问题的电脑都是之前安装过VMware的，然后保留了注册表和部分历史文件的。  </p><h2 id="卸载VMware"><a href="#卸载VMware" class="headerlink" title="卸载VMware"></a>卸载VMware</h2><p>首先将VMware卸载掉，推荐使用专门的卸载工具，在卸载的同时会清理掉残留的文件和注册表等，当然没有卸载工具的话也没有关系，按照下面的步骤继续做就ok。</p><h2 id="清理注册表"><a href="#清理注册表" class="headerlink" title="清理注册表"></a>清理注册表</h2><p>使用专门的注册表清理工具清理掉VMware留下的注册表，这里我用的是CCleaner，直接百度找一个靠谱的网站下载就行，打开CCleaner之后点击注册表，扫描问题，等待扫描完成后选择修复选定的问题。这里会弹出提示询问你是否需要备份注册表，这里根据自己的需要选择就可以，我个人感觉没有必要去备份。最后点击修复所有问题，VMware残留的注册表就被删除掉了。  </p><h2 id="清理残留文件"><a href="#清理残留文件" class="headerlink" title="清理残留文件"></a>清理残留文件</h2><p>打开系统盘，搜索“vmware”，等待搜索完成后将找到的所有文件删除，可能会有一些文件无法删除，跳过这些文件就行。 </p><h2 id="重启计算机"><a href="#重启计算机" class="headerlink" title="重启计算机"></a>重启计算机</h2><p>推荐在这时候重启电脑，因为不重启的话重新安装上VMware后还是会没有网卡，给一台重装的时候就忘记了重启，安装后发现还是没有虚拟网卡，在安装之后重启之后就有了。所以最后重启应该也是可以的，但是不能没有这个操作。</p><h2 id="重新安装VMware"><a href="#重新安装VMware" class="headerlink" title="重新安装VMware"></a>重新安装VMware</h2><p>最后重新安装上VMware，打开网络适配器，看到你的VMnet1和VMnet8网卡，就说明成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天好几位同学找我说在安装VMware后都出现了没有VMnet虚拟网卡的问题，经过数次尝试终于找到了比较靠谱点的解决方式。&lt;/p&gt;
&lt;h1 id=&quot;还原虚拟网络设置&quot;&gt;&lt;a href=&quot;#还原虚拟网络设置&quot; class=&quot;headerlink&quot; title=&quot;还原虚拟网络
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="VMware" scheme="https://cyneliu.github.io/tags/VMware/"/>
    
      <category term="虚拟网卡" scheme="https://cyneliu.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于Win2012在VMware环境下部署DHCP服务器的问题</title>
    <link href="https://cyneliu.github.io/2018/11/20/%E5%85%B3%E4%BA%8EWin2012%E5%9C%A8VMware%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cyneliu.github.io/2018/11/20/关于Win2012在VMware环境下部署DHCP服务器的问题/</id>
    <published>2018-11-20T08:35:46.000Z</published>
    <updated>2018-11-20T08:51:36.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端无法获取来自DHCP地址池的正确ip"><a href="#客户端无法获取来自DHCP地址池的正确ip" class="headerlink" title="客户端无法获取来自DHCP地址池的正确ip"></a>客户端无法获取来自DHCP地址池的正确ip</h1><p>昨天在VMware WorkStation的Server 2012安装完DHCP服务之后，使用另一台虚拟机测试时怎么都获取不到正确的ip，给到的是一个不同于DHCP地址池的其它子网的ip地址，两个小时愣是没找出原因。  </p><p>今天早上终于找到了原因，在这里记录一下。</p><h1 id="原因简述"><a href="#原因简述" class="headerlink" title="原因简述"></a>原因简述</h1><p>VMware中的VMnet虚拟网卡默认开启了本地DHCP服务，虚拟机在使用dhcp自动获取ip时是从VMnet的本地dhcp拿到的ip地址，因为每个人的VMnet网卡设置的网段不一样，获取的ip地址就是VMnet设置的网段，比如我的VMnet子网地址是192.168.138.0，我拿到的ip地址就是这个网段内的地址。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><img src="https://i.loli.net/2018/11/20/5bf3caebf40da.png" alt="01.png"><br>打开虚拟网络编辑器，选择你正在使用的虚拟网卡，比如我使用的是仅主机模式，对应的就是我的VMnet1网卡。更改设置，将“使用本地DHCP服务将IP分配给虚拟机”取消勾选就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;客户端无法获取来自DHCP地址池的正确ip&quot;&gt;&lt;a href=&quot;#客户端无法获取来自DHCP地址池的正确ip&quot; class=&quot;headerlink&quot; title=&quot;客户端无法获取来自DHCP地址池的正确ip&quot;&gt;&lt;/a&gt;客户端无法获取来自DHCP地址池的正确ip&lt;/
      
    
    </summary>
    
      <category term="服务器" scheme="https://cyneliu.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Windows Server" scheme="https://cyneliu.github.io/tags/Windows-Server/"/>
    
      <category term="DHCP" scheme="https://cyneliu.github.io/tags/DHCP/"/>
    
      <category term="VMware" scheme="https://cyneliu.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>科学上网工具 - WireGuard</title>
    <link href="https://cyneliu.github.io/2018/11/14/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B7%A5%E5%85%B7-WireGuard/"/>
    <id>https://cyneliu.github.io/2018/11/14/科学上网工具-WireGuard/</id>
    <published>2018-11-14T12:22:33.000Z</published>
    <updated>2018-11-14T12:57:37.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WireGuard是什么？"><a href="#WireGuard是什么？" class="headerlink" title="WireGuard是什么？"></a>WireGuard是什么？</h1><p>WireGuard是一个构建快速、现代、安全的VPN的协议和工具套件，它具有以下优点：</p><blockquote></blockquote><p>使用最先进的加密技术，防范攻击（RSA，SHA广被诟病都将被淘汰）<br>性能远超OpenVPN<br>效率极高，WireGuard协议作为Linux内核模块运行<br>通用用途，支持嵌入式和非嵌入式设备<br>跨平台，初期只在Linux平台发布，现已支持所有平台<br>易用，用过OpenVPN等工具集的人都明白这其中的痛苦<br>工作在3层（链路层），支持漫游，地址变更对用户无感知，使用更简单，切换更平滑<br>使用UDP传输数据，轻量、高效、节能、节省带宽（适用于 IOT 领域）<br>基于GPLv2Linux Kernel 基于 GPLv2）免费开源  </p><p>Linus Torvalds对WireGuard的评价：</p><blockquote><p>Can I just once again state my love for it and hope it gets merged soon? Maybe the code isn’t perfect, but I’ve skimmed it, and compared to the horrors that are OpenVPN and IPSec, it’s a work of art.</p></blockquote><h1 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h1><h2 id="脚本要求"><a href="#脚本要求" class="headerlink" title="脚本要求"></a>脚本要求</h2><blockquote><p>仅适用于centos7<br>vps架构必须为KVM<br>centos7的内核大部分为3.10，不能正确安装，必须升级（已经集成在脚本中）</p></blockquote><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>1、下载并执行脚本：</p><blockquote></blockquote><pre><code>wget https://raw.githubusercontent.com/yobabyshark/wireguard/master/wireguard_install.sh &amp;&amp; chmod +x wireguard_install.sh &amp;&amp; ./wireguard_install.sh</code></pre><p><img src="https://i.loli.net/2018/11/14/5bec1723904fd.png" alt="01.png"></p><p>2、输入“1”升级内核，按照提示重启。  </p><p>3、重启完成后，再次执行脚本：</p><blockquote></blockquote><pre><code>./wireguard_install.sh</code></pre><p>4、输入“2”安装WireGuard。  </p><p>5、使用ftp工具连接vps，将<strong>/etc/wireguard</strong>目录下的client.conf下载到本地。</p><p>6、下载安装TunSafe，这是一个windows端的第三方客户端，因为官方windows版本的还没开发完成，先用这个软件代替，TunSafe已经开源，可以放心使用。<br>官网下载：<a href="https://tunsafe.com/download" target="_blank" rel="noopener">TunSafe</a></p><p>7、打开TunSafe，单击file，选择import file，将下载的client.conf导入到软件中。  </p><p>8、导入后会自动进行连接，进入全局代理模式，也就是所有流量都会被代理。</p><h1 id="其它平台客户端"><a href="#其它平台客户端" class="headerlink" title="其它平台客户端"></a>其它平台客户端</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>1、下载WireGuard安卓客户端：  </p><blockquote><p>Android客户端：<a href="https://f-droid.org/repo/com.wireguard.android_439.apk" target="_blank" rel="noopener">点此下载</a></p></blockquote><p>2、打开app，点击加号导入client.conf文件。</p><blockquote><p>这里可能会提示错误，原因是没有文件操作权限，去权限管理里给软件勾上存储权限即可。</p></blockquote><h1 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h1><p>Youtube视频地址：<a href="https://youtu.be/A1tdPsdBATw" target="_blank" rel="noopener">点击观看</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WireGuard是什么？&quot;&gt;&lt;a href=&quot;#WireGuard是什么？&quot; class=&quot;headerlink&quot; title=&quot;WireGuard是什么？&quot;&gt;&lt;/a&gt;WireGuard是什么？&lt;/h1&gt;&lt;p&gt;WireGuard是一个构建快速、现代、安全的VPN
      
    
    </summary>
    
      <category term="VPS" scheme="https://cyneliu.github.io/categories/VPS/"/>
    
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="VPS" scheme="https://cyneliu.github.io/tags/VPS/"/>
    
      <category term="WireGuard" scheme="https://cyneliu.github.io/tags/WireGuard/"/>
    
  </entry>
  
  <entry>
    <title>简单识别Linux vps架构(xen,openvz,kvm)</title>
    <link href="https://cyneliu.github.io/2018/11/14/%E7%AE%80%E5%8D%95%E8%AF%86%E5%88%ABLinux-vps%E6%9E%B6%E6%9E%84-xen-openvz-kvm/"/>
    <id>https://cyneliu.github.io/2018/11/14/简单识别Linux-vps架构-xen-openvz-kvm/</id>
    <published>2018-11-14T12:10:11.000Z</published>
    <updated>2018-11-14T12:16:49.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装virt-what"><a href="#安装virt-what" class="headerlink" title="安装virt-what"></a>安装virt-what</h1><blockquote></blockquote><pre><code>yum -y install virt-what</code></pre><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><blockquote></blockquote><pre><code>virt-what</code></pre><p>如图，这台vps是基于xen架构。<br><img src="https://i.loli.net/2018/11/14/5bec12288d430.png" alt="01.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装virt-what&quot;&gt;&lt;a href=&quot;#安装virt-what&quot; class=&quot;headerlink&quot; title=&quot;安装virt-what&quot;&gt;&lt;/a&gt;安装virt-what&lt;/h1&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="VPS" scheme="https://cyneliu.github.io/categories/VPS/"/>
    
    
      <category term="VPS" scheme="https://cyneliu.github.io/tags/VPS/"/>
    
      <category term="linux" scheme="https://cyneliu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈几种快充技术</title>
    <link href="https://cyneliu.github.io/2018/11/07/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8D%E5%BF%AB%E5%85%85%E6%8A%80%E6%9C%AF/"/>
    <id>https://cyneliu.github.io/2018/11/07/浅谈几种快充技术/</id>
    <published>2018-11-07T11:00:56.000Z</published>
    <updated>2018-11-07T11:50:05.314Z</updated>
    
    <content type="html"><![CDATA[<p>原来的充电宝丢了，今天又在某宝上溜达买了一个，溜达的时候发现了好多的新名词，就索性查了一下，整理一下写在这里了。</p><h1 id="PD快充协议"><a href="#PD快充协议" class="headerlink" title="PD快充协议"></a>PD快充协议</h1><p>PD充电协议是USB-IF组织公布的功率传输协议，它可以使目前默认最大功率5V/2A的type-c接口提高到100W，同时谷歌宣布Android7.0以上的手机搭载的快充协议必须支持PD协议，意在统一快充市场。  </p><p>USB-PowerDelivery（USBPD）是目前主流的快充协议之一。是由USB-IF组织制定的一种快速充电规范。USBPD透过USB电缆和连接器增加电力输送，扩展USB应用中的电缆总线供电能力。该规范可实现更高的电压和电流，输送的功率最高可达100瓦，并可以自由的改变电力的输送方向。  </p><p>USBPD和Type-C的关系。经常会有人把USBPD和Type-C放在一起谈，甚至就把Type-C充电器叫做PD充电器。USBPD和Type-C其实是两码事，USBPD是一种快速充电协议，而Type-C则是一种新的接口规范。Type-C接口默认最大支持5V/3A，但在实现了USBPD协议以后，能够使输出功率最大支持到前文提到的100W。所以现在许多实用Type-C接口的设备都会支持USBPD协议。</p><p>USBPD的发展前景。USBPD现在已经发展到了USBPD3.0版本。在谷歌的推动下目USBPD已经收编了高通的QC快充协议，并获得了中国工信部的支持。</p><h1 id="QC-1-0-2-0-3-0"><a href="#QC-1-0-2-0-3-0" class="headerlink" title="QC 1.0/2.0/3.0"></a>QC 1.0/2.0/3.0</h1><p>Qualcomm Quick Charge 3.0（下文简称QC 3.0）快充技术不知不觉已经是Qualcomm第三代快充技术，前几年快充技术还没百家齐放的时候，QC门派的关注度还是蛮高的。前几年QC 1.0和QC 2.0仍然比较受手机厂商和消费者欢迎。尤其是QC 2.0技术，如今很多手机厂商的快充技术其实都是基于QC 2.0基础上延伸出来的，例如下文将会提到的Moto涡轮快充和vivo双引擎闪充。  </p><blockquote></blockquote><p><strong>QC 1.0</strong>：最高支持5V/2A充电功率。</p><blockquote><p><strong>QC 2.0</strong>：兼容5V/9V/12V/20V四档充电电压。  </p></blockquote><p><strong>QC 3.0</strong>：以200mV增量为一档，提供从3.6V到20V电压的灵活选择，让手机厂商能够根据自身需求调整最佳电压，达到预期电流，提供充电效率同时降低功耗和发热。目前市面上标配QC 3.0快充头并支持该协议手机有LG G5、小米手机5等。</p><h1 id="MTK：PumpExpress-Plus"><a href="#MTK：PumpExpress-Plus" class="headerlink" title="MTK：PumpExpress Plus"></a>MTK：PumpExpress Plus</h1><p>说完高通的，再来看看联发科的快充技术。  </p><p>联发科MTP Pump Express Plus快充技术，原理与高通QC快充基本相同，都是在恒定电流的同时，通过提升充电电压来获得更大的充电功率。最新的Pump Express 3.0宣称能够在20分钟内为智能手机充满70%电量，同时相比PumpExpress Plus功耗减少50%，间接降低发热。  </p><p>PumpExpress允许充电器根据电流决定充电所需的初始电压，通过内置的PMIC电源管理集成电路发出脉冲电流指令给充电器，调整输出电压，逐渐增加到最大充电电流。相比QC 3.0的200mV为一档增量的做法，PumpExpress 3.0电压微调幅度仅为10mV，理论最高可提供5A充电电流。  </p><h1 id="手机厂商快充协议"><a href="#手机厂商快充协议" class="headerlink" title="手机厂商快充协议"></a>手机厂商快充协议</h1><blockquote></blockquote><p>华为：FCP（Fast Charger Protocol）<br>三星：AFC<br>一加：DASH极速闪充<br>vivo:双引擎闪充<br>OPPO：VOOC闪充技术<br>Moto：涡轮快充技术<br>魅族：mCharge 3.0  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原来的充电宝丢了，今天又在某宝上溜达买了一个，溜达的时候发现了好多的新名词，就索性查了一下，整理一下写在这里了。&lt;/p&gt;
&lt;h1 id=&quot;PD快充协议&quot;&gt;&lt;a href=&quot;#PD快充协议&quot; class=&quot;headerlink&quot; title=&quot;PD快充协议&quot;&gt;&lt;/a&gt;PD快充
      
    
    </summary>
    
      <category term="打鱼晒网" scheme="https://cyneliu.github.io/categories/%E6%89%93%E9%B1%BC%E6%99%92%E7%BD%91/"/>
    
    
      <category term="快充" scheme="https://cyneliu.github.io/tags/%E5%BF%AB%E5%85%85/"/>
    
  </entry>
  
  <entry>
    <title>Apache Web服务器的安装与配置</title>
    <link href="https://cyneliu.github.io/2018/10/30/Apache-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://cyneliu.github.io/2018/10/30/Apache-Web服务器的安装与配置/</id>
    <published>2018-10-30T09:10:05.000Z</published>
    <updated>2018-10-30T09:26:47.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Apache2"><a href="#安装Apache2" class="headerlink" title="安装Apache2"></a>安装Apache2</h1><p>执行：</p><blockquote></blockquote><pre><code>sudo apt-get install apache2</code></pre><p>Apache默认会在“/var”下建立一个名为“www”的目录，即Web目录，所有能通过浏览器访问的Web文件都放到这个目录。</p><h1 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h1><p>安装PHP：</p><blockquote></blockquote><pre><code>sudo apt-get install libapache2-mod-php5 php5</code></pre><p>安装扩展包：</p><blockquote></blockquote><pre><code>sudo apt-get install php5-gd php5-mysql</code></pre><p>重新启动Apache，加载PHP模块:</p><blockquote></blockquote><pre><code>sudo /etc/init.d/apache2 restart</code></pre><h1 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h1><p>执行：</p><blockquote></blockquote><pre><code>sudo apt-get install mysql-server</code></pre><p>根据提示信息设置密码。</p><h1 id="安装配置phpMyAdmin"><a href="#安装配置phpMyAdmin" class="headerlink" title="安装配置phpMyAdmin"></a>安装配置phpMyAdmin</h1><p>安装Mysql数据库管理软件：</p><blockquote></blockquote><pre><code>sudo apt-get install phpmyadmin</code></pre><p>选择Web server：apache2或lighttpd：<br><img src="http://112.80.35.35:40010/site_media/media/course/45822350-0767-4686-b15a-74a093b03768/network/%E5%9B%BE%E7%89%87_nvEIrXy.png" alt="01.png"><br>之后还需要根据提示输入Mysql的root账户连接密码并设置phpMyAdmin的登录密码。  </p><p>将phpMyAdmin与Apache2建立连接。例如：www目录在“/var/www”下，phpMyAdmin在“/usr/share/phpmyadmin”目录下，则用如下命令建立连接：</p><blockquote></blockquote><pre><code>sudo ln -s /usr/share/phpmyadmin /var/www/html</code></pre><p>在浏览器地址栏中输入<a href="http://localhost/phpmyadmin即可访问phpMyAdmin的登录页面。" target="_blank" rel="noopener">http://localhost/phpmyadmin即可访问phpMyAdmin的登录页面。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装Apache2&quot;&gt;&lt;a href=&quot;#安装Apache2&quot; class=&quot;headerlink&quot; title=&quot;安装Apache2&quot;&gt;&lt;/a&gt;安装Apache2&lt;/h1&gt;&lt;p&gt;执行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;c
      
    
    </summary>
    
      <category term="服务器应用" scheme="https://cyneliu.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Web服务器" scheme="https://cyneliu.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Apache" scheme="https://cyneliu.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的简单安装</title>
    <link href="https://cyneliu.github.io/2018/10/30/Nginx%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/"/>
    <id>https://cyneliu.github.io/2018/10/30/Nginx的简单安装/</id>
    <published>2018-10-30T07:49:45.000Z</published>
    <updated>2018-10-30T08:48:16.638Z</updated>
    
    <content type="html"><![CDATA[<p>过几天参加比赛要用到nginx的安装部署，写一个简单的安装方式，方便赛前温习。</p><h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><p>更新apt源：</p><blockquote></blockquote><pre><code>sudo apt-get update</code></pre><p>安装nginx：</p><blockquote></blockquote><pre><code>sudo apt-get install nginx</code></pre><p>使用这种方法，apt-get会自动安装好nginx和依赖组件。  </p><p>执行如下命令查看nginx进程是否启动：</p><blockquote></blockquote><pre><code>ps -ef | grep nginx</code></pre><p>打开浏览器，在地址栏输入localhost，就会出现如下的欢迎页面，表示nginx安装成功。<br><img src="http://112.80.35.35:40010/site_media/media/course/096bc012-db2f-4c2b-a983-bbf7056af08e/network/%E5%9B%BE%E7%89%87_MVR9Prv.png" alt="01.png"></p><h1 id="Nginx安装路径"><a href="#Nginx安装路径" class="headerlink" title="Nginx安装路径"></a>Nginx安装路径</h1><blockquote></blockquote><pre><code>whereis nginx</code></pre><h1 id="搭建简单静态服务器"><a href="#搭建简单静态服务器" class="headerlink" title="搭建简单静态服务器"></a>搭建简单静态服务器</h1><p>在nginx安装目录下找到nginx.conf文件，打开并编辑，在http节点下增加如下内容：<br><img src="http://112.80.35.35:40010/site_media/media/course/096bc012-db2f-4c2b-a983-bbf7056af08e/network/%E5%9B%BE%E7%89%87_DEfprYK.png" alt="02.png"><br>root /home/openlab这里填写你的静态文件存储根目录。  </p><p>找到nginx程序所在的目录，执行nginx -s reload命令，重新加载Nginx配置文件。  </p><p>root /home/openlab这里填写你的静态文件存储根目录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过几天参加比赛要用到nginx的安装部署，写一个简单的安装方式，方便赛前温习。&lt;/p&gt;
&lt;h1 id=&quot;安装Nginx&quot;&gt;&lt;a href=&quot;#安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;安装Nginx&quot;&gt;&lt;/a&gt;安装Nginx&lt;/h1&gt;&lt;p&gt;更新a
      
    
    </summary>
    
      <category term="服务器应用" scheme="https://cyneliu.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Nginx" scheme="https://cyneliu.github.io/tags/Nginx/"/>
    
      <category term="Web服务器" scheme="https://cyneliu.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Windows环境利用FRP实现内网穿透</title>
    <link href="https://cyneliu.github.io/2018/10/20/Windows%E7%8E%AF%E5%A2%83%E5%88%A9%E7%94%A8FRP%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://cyneliu.github.io/2018/10/20/Windows环境利用FRP实现内网穿透/</id>
    <published>2018-10-20T08:56:19.000Z</published>
    <updated>2018-10-20T10:49:34.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>FRP (Fast Reverse Proxy) 是一个可用于内网穿透的高性能的反向代理应用，支持TCP,UDP,HTTP,HTTPS协议。  </p><p>项目地址：<br><a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。  </p><p>比如我们平时用的翻墙工具就属于正向代理的一种应用。<br><img src="https://i.loli.net/2018/10/20/5bcaf373cd030.png" alt="01.png"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。<br><img src="https://i.loli.net/2018/10/20/5bcaf373ef44d.png" alt="02.png"></p><h1 id="安装部署frp"><a href="#安装部署frp" class="headerlink" title="安装部署frp"></a>安装部署frp</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.拥有公网ip的设备</p><blockquote><p>作为反向代理服务器，外网访问内网设备时通过此设备进行访问。</p></blockquote><p>2.域名（非必须）</p><blockquote><p>域名的作用仅仅是为了方便记忆，有了域名在访问时就不需要输入那些难以记忆的数字进行访问了。</p></blockquote><h2 id="下载安装程序"><a href="#下载安装程序" class="headerlink" title="下载安装程序"></a>下载安装程序</h2><p>到<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">GitHub</a>下载frp程序，如果是64位系统下载“amd64”结尾的zip包，如果是32位系统就下载“386”结尾的zip包。  </p><p>下载完成后分别在客户端和服务端选择一个合适的位置直接解压出来就可以了。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="放行端口"><a href="#放行端口" class="headerlink" title="放行端口"></a>放行端口</h3><p>因为博主使用的是阿里云的学生机，默认是没有放行其它端口的，所以在配置frp之前需要配置一下入方向的安全组规则：<br><img src="https://i.loli.net/2018/10/20/5bcaf78e8b887.png" alt="03.png"></p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>在上面过程中解压出来的文件包含有frps.ini和frps_full.ini两个配置文件，frps_full.ini是全配置，里面所有的配置都有，玩法很多，感兴趣的可以研究一下。将下面配置代码复制到frps.ini后保存：</p><blockquote></blockquote><pre><code>[common]bind_port = 7000 ;要绑定的端口dashboard_user = admin ;控制台的用户名dashboard_pwd = password ;控制台的密码dashboard_port = 7500 ;控制台的端口</code></pre><p>在配置文件所在位置按住shift右键打开cmd或power shell，执行命令：<br>cmd:</p><blockquote></blockquote><pre><code>frps -c frps.ini</code></pre><p>power shell:</p><blockquote></blockquote><pre><code>.\frps.exe -c frps.ini</code></pre><h2 id="客户端-内网设备"><a href="#客户端-内网设备" class="headerlink" title="客户端(内网设备)"></a>客户端(内网设备)</h2><h3 id="编辑配置文件-1"><a href="#编辑配置文件-1" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>将如下代码复制到frpc.ini中：</p><blockquote></blockquote><pre><code>[common]server_addr = 1.2.3.4 ;服务器的 IPserver_port = 7000 ;服务器上设置的服务绑定端口[RDP] ;这个是反向代理的名称，可以随意设置type = tcp ;RDP 是 TCP 协议的local_ip = 127.0.0.1 ;本机IP,可以直接使用127.0.0.1local_port = 3389 ;远程桌面的默认端口remote_port = 7001 ;外网访问的端口</code></pre><p>在配置文件所在位置按住shift右键打开cmd或power shell，执行命令：<br>cmd:</p><blockquote></blockquote><pre><code>frpc -c frpc.ini</code></pre><p>power shell:</p><blockquote></blockquote><pre><code>.\frpc.exe -c frpc.ini</code></pre><h3 id="开启远程桌面（非必须）"><a href="#开启远程桌面（非必须）" class="headerlink" title="开启远程桌面（非必须）"></a>开启远程桌面（非必须）</h3><p>如果你配置frp是为了使用远程桌面，而恰巧你的内网设备又是win7或win10等桌面版系统，那么你还需要右击“此电脑”，选择“系统”——“远程设置”——“允许远程连接至此电脑”。而如果是server版本直接忽略此步骤即可。  </p><p>至此，你已经可以使用你的ip加端口号的形式访问你的相应服务了。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>设置自己的域名解析，添加一条A类记录指向你的公网ip。<br><img src="https://i.loli.net/2018/10/20/5bcb0775422ac.png" alt="04.png"></p><h3 id="配置frpc-ini"><a href="#配置frpc-ini" class="headerlink" title="配置frpc.ini"></a>配置frpc.ini</h3><p>在刚才复制的配置之后添加如下内容即可：</p><blockquote></blockquote><pre><code>custom_domains = xxx.yourdomain.xxx</code></pre><p>这样，你就可以使用域名+端口的形式访问你的服务了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;几个概念&quot;&gt;&lt;a href=&quot;#几个概念&quot; class=&quot;headerlink&quot; title=&quot;几个概念&quot;&gt;&lt;/a&gt;几个概念&lt;/h1&gt;&lt;h2 id=&quot;frp&quot;&gt;&lt;a href=&quot;#frp&quot; class=&quot;headerlink&quot; title=&quot;frp&quot;&gt;&lt;/a&gt;fr
      
    
    </summary>
    
      <category term="软件工具" scheme="https://cyneliu.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="反向代理" scheme="https://cyneliu.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="frp" scheme="https://cyneliu.github.io/tags/frp/"/>
    
      <category term="内网穿透" scheme="https://cyneliu.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="Windows" scheme="https://cyneliu.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>SDN实验（二）——Open vSwitch</title>
    <link href="https://cyneliu.github.io/2018/10/16/SDN%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Open-vSwitch/"/>
    <id>https://cyneliu.github.io/2018/10/16/SDN实验（二）——Open-vSwitch/</id>
    <published>2018-10-16T07:20:10.000Z</published>
    <updated>2018-10-16T10:02:06.691Z</updated>
    
    <content type="html"><![CDATA[<p>Open vSwitch是由Nicira Networks主导，运行在虚拟化平台（例如KVM，Xen）上的虚拟交换机。Open vSwitch基于C语言开发，遵循Apache 2.0许可证，能同时支持多种标准的管理接口和协议（比如NetFlow、sFlow、SPAN、RSPAN、CLI、LACP、802.1ag等）。Open vSwitch通过OpenFlow协议由统一的控制器管理，从而实现对接入的虚拟机（或设备）的网络联通。  </p><p>整体组网结构如下图：<br><img src="https://i.loli.net/2018/10/16/5bc592232631f.png" alt="01.png"><br>Open vSwitch内部架构图：<br><img src="https://i.loli.net/2018/10/16/5bc592a15b2de.png" alt="02.png"></p><blockquote><p><strong>ovs-vswtichd：</strong>主要模块，实现vswitch的守候进程daemon，包括一个支持流交换的Linux内核模块。<br><strong>ovsdb-server：</strong>轻量级数据库服务器，保存配置信息，ovs-vswitchd通过这个数据库获取配置信息。<br><strong>ovs-dpctl：</strong>用来配置vswitch内核模块的一个工具。<br><strong>ovs-vsctl：</strong>主要是获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。<br><strong>ovs-appctl：</strong>一个向ovs-vswtichd的守护进程发送命令的的程序。<br><strong>datapath：</strong>内核模块，根据流表匹配结果做相应处理。<br><strong>ovs-ofctl：</strong>查询和控制OpenFlow虚拟交换机的流表。</p></blockquote><h1 id="Open-vSwitch的安装"><a href="#Open-vSwitch的安装" class="headerlink" title="Open vSwitch的安装"></a>Open vSwitch的安装</h1><h1 id="Open-vSwitch网桥管理"><a href="#Open-vSwitch网桥管理" class="headerlink" title="Open vSwitch网桥管理"></a>Open vSwitch网桥管理</h1><p>在网络中，交换机和桥概念类似，Open vSwitch是一个虚拟交换软件，也就是说，Open vSwitch实现了网桥的功能。学习Open vSwitch的第一步要弄清楚网桥的概念。网桥是连接两个局域网的设备，工作在数据链路层，根据MAC地址来转发帧。在Open vSwitch中创建一个网桥后，此时网络功能不受影响，但是会产生一个虚拟网卡，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个网桥以后，还需要为这个网桥增加端口（port），一个端口就是一个物理网卡，当网卡加入到这个网桥之后，其工作方式就和普通交换机的一个端口的工作方式类似了。以下是一个网桥的具体信息：</p><blockquote></blockquote><pre><code>root@localhost:~# ovs-vsctl showbc12c8d2-6900-42dd-9c1c-30e8ecb99a1bBridge &quot;br0&quot;    Port &quot;eth0&quot;        Interface &quot;eth0&quot;    Port &quot;br0&quot;        Interface &quot;br0&quot;            type: internalovs_version: &quot;1.4.0+build0&quot;</code></pre><p>上述信息显示了一个名为br0的桥（交换机），这个交换机有两个接口，一个是eth0，一个是br0。  </p><p>上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口实现了桥的功能。Open vSwitch的内核模块实现了多个“数据路径”，每个都可以有多个vports。每个数据路径也通过关联流表（flow table）来设置操作，而这些流表中的流都是用户空间在报文头和元数据的基础上映射的关键信息，一般的操作都是将数据包转发到另一个vport。当一个数据包到达一个vport，内核模块所做的处理是提取其流的关键信息并在流表中查找这些关键信息，当有一个匹配的流时它执行对应的操作，如果没有匹配，它会将数据包送到用户空间的处理队列中，作为处理的一部分，用户空间可能会设置一个流用于以后碰到相同类型的数据包可以在内核中执行操作。</p><h2 id="ovs-vsctl关于网桥管理的常用命令"><a href="#ovs-vsctl关于网桥管理的常用命令" class="headerlink" title="ovs-vsctl关于网桥管理的常用命令"></a>ovs-vsctl关于网桥管理的常用命令</h2><blockquote></blockquote><p><strong>init</strong>    初始化数据库（前提数据分组为空）<br><strong>show</strong>    打印数据库信息摘要<br><strong>add-br BRIDGE</strong>    添加新的网桥<br><strong>del-br BRIDGE</strong>    删除网桥<br><strong>list-br</strong>    打印网桥摘要信息<br><strong>list-ports BRIDGE</strong>    打印网桥中所有port摘要信息<br><strong>add-port BRIDGE PORT</strong>    向网桥中添加端口<br><strong>del-port [BRIDGE] PORT</strong>    删除网桥上的端口<br><strong>get-controller BRIDGE</strong>    获取网桥的控制器信息<br><strong>del-controller BRIDGE</strong>    删除网桥的控制器信息<br><strong>set-controller BRIDGE TARGET</strong>    向网桥添加控制器</p><h1 id="Open-vSwitch流表管理"><a href="#Open-vSwitch流表管理" class="headerlink" title="Open vSwitch流表管理"></a>Open vSwitch流表管理</h1><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议连接Open vSwitch来创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。ovs-ofctl关于流表管理的常用命令如下表所示。<br><img src="https://i.loli.net/2018/10/16/5bc5b553dc0a6.png" alt="03.png"><br>对于add-flow、add-flows和mod-flows这3个命令，还需要指定要执行的动作actions=[target],[target]…，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br><img src="https://i.loli.net/2018/10/16/5bc5b5bebfed1.png" alt="04.png"><br>在OpenFlow白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或空格分开，一些常用的字段列举如下表所示。<br><img src="https://i.loli.net/2018/10/16/5bc5b664441f1.png" alt="05.png"></p><h1 id="Open-vSwitchQoS设置"><a href="#Open-vSwitchQoS设置" class="headerlink" title="Open vSwitchQoS设置"></a>Open vSwitchQoS设置</h1><h1 id="Open-vSwitch端口映射"><a href="#Open-vSwitch端口映射" class="headerlink" title="Open vSwitch端口映射"></a>Open vSwitch端口映射</h1><h1 id="Open-vSwitch流量监控"><a href="#Open-vSwitch流量监控" class="headerlink" title="Open vSwitch流量监控"></a>Open vSwitch流量监控</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Open vSwitch是由Nicira Networks主导，运行在虚拟化平台（例如KVM，Xen）上的虚拟交换机。Open vSwitch基于C语言开发，遵循Apache 2.0许可证，能同时支持多种标准的管理接口和协议（比如NetFlow、sFlow、SPAN、RSP
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Open vSwitch" scheme="https://cyneliu.github.io/tags/Open-vSwitch/"/>
    
  </entry>
  
  <entry>
    <title>SDN实验（一）——常用开源工具</title>
    <link href="https://cyneliu.github.io/2018/10/15/SDN%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://cyneliu.github.io/2018/10/15/SDN实验（一）——常用开源工具/</id>
    <published>2018-10-15T08:38:43.000Z</published>
    <updated>2018-10-15T11:01:00.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><p>Wireshark这款网络数据包分析工具，在传统网络中就有很广泛的应用，这里就不再多说了，主要记录一下笔者之前没有发现的功能或使用方法。  </p><h2 id="OpenFlow数据包"><a href="#OpenFlow数据包" class="headerlink" title="OpenFlow数据包"></a>OpenFlow数据包</h2><p>OpenFlow数据包主要包含五层，依次是：  </p><blockquote><p><strong>Frame：</strong>物理层数据帧概况。<br><strong>Ethernet II：</strong>数据链路层以太网帧头部信息。<br><strong>Internet Protocol Version 4：</strong>互联网IP包头信息。<br><strong>transmission control protocol：</strong>传输层数据段头部信息，此处是TCP。<br><strong>OpenFlow：</strong>位于TCP协议之上，负责解析应用层。  </p></blockquote><h2 id="保存捕获的数据"><a href="#保存捕获的数据" class="headerlink" title="保存捕获的数据"></a>保存捕获的数据</h2><p>wireshark除了有“save”和“save as”的保存方式外，还提供特殊保存的方法（Export Specified）：</p><blockquote><p><strong>All packets:</strong>保存所有已抓取的数据包。<br><strong>Selected packets only:</strong>保存当前鼠标选中的数据包。<br><strong>Marked packets only:</strong>保存当前标记的数据包。标记数据包的方法是在数据包列表中选中目标数据包，然后右击选择“mark packet toggle”。<br><strong>First to last marked:</strong>则将两个标记数据包之间所有的数据包导出。<br><strong>Range:</strong>并输入数据包的编号范围，则将编号连续的数据包导出。<br><strong>Remove ignored packets:</strong>则放弃部分数据包并导出其他所有数据包。放弃数据包的方法是，在数据包列表中选中数据包，右击，选择“ignore packet toggle”。</p></blockquote><h1 id="性能测试工具iPerf和Netperf"><a href="#性能测试工具iPerf和Netperf" class="headerlink" title="性能测试工具iPerf和Netperf"></a>性能测试工具iPerf和Netperf</h1><h2 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h2><p>1、网络吞吐量：单位时间内通过某个网络（信道或接口）的数据量，吞吐量受网络的带宽或者网络的额定速率限制，单位通常表示为bit/s或bps。  </p><p>2、网络延时：一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。影响网络延时的主要因素是路由的跳数和网络的流量。交换机延时（Latency）是指从交换机接收到数据包到开始向目的端口复制数据包之间的时间间隔。有许多因素会影响交换机延时大小，比如转发技术等等。  </p><p>3、抖动：用于描述包在网络中的传输延时的变化，抖动越小，说明网络质量越稳定越好。抖动是评价一个网络性能的最重要的因素。  </p><p>4、丢包率：理想状态下是发送了多少数据包就能接收到多少数据包，但是由于信号衰减、网络质量等诸多因素的影响并不能达到理想状态，而丢包率就是指测试中所丢失的数据包数量占所发送的数据包的比率。</p><h2 id="iPerf"><a href="#iPerf" class="headerlink" title="iPerf"></a>iPerf</h2><p>iPerf 是一种网络性能测试工具，可以运行于Linux、BSD、Unix及Windows等操作系统。 iPerf具有多种参数和特性，支持协议、定时、缓冲区等参数的配置调整，能够测试TCP/UDP最大带宽、延迟抖动、数据包丢失等统计信息，可以根据需求采用不同的参数从而达到不同的测试目的。iPerf基于Server/Client的工作模式，如下图所示：  </p><p><img src="https://i.loli.net/2018/10/15/5bc45614c9c99.png" alt="01.png"><br>客户端向服务端发送一定数量的数据，服务端统计并记录带宽、延时抖动等信息。客户端将数据全部发送后，服务端会回复一个数据包给客户端，将测试数据反馈给客户端。不过，如果网络较为拥塞或者误码率较高，客户端无法收到服务端回复的数据包，则只能显示本地记录的部分测试结果，所以服务端和客户端的测试结果可能有所不同。</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote></blockquote><pre><code>iperf [-s|-c host] [options]</code></pre><h4 id="客户端-服务端通用参数"><a href="#客户端-服务端通用参数" class="headerlink" title="客户端/服务端通用参数"></a>客户端/服务端通用参数</h4><blockquote></blockquote><pre><code>-f/—format  [kmKM]分别表示以Kbits, Mbits, KBytes, MBytes显示报告，默认以Mbits为单位-i/—interval  以秒为单位显示报告间隔-l/—len  读写的缓冲区大小，默认8KB-m/—print_mss  打印最大的TCP数据段大小 (MTU - TCP/IP header)-o/—output    将报告和错误信息输出到指定文件-p/—port    指定服务器端使用的端口或客户端所连接的端口-u/—udp    使用udp协议-w/—window    指定TCP窗口（socket缓冲区）大小，默认是8KB-B/—bind    绑定一个主机地址或接口-C/—compatibility    兼容旧版本（当server端和client端版本不一样时使用）-M/—mss    设置TCP最大数据段大小（MTU - 40 bytes）-N/—nodelay    设置无延迟TCP，禁用 Nagle’s Algorithm-V/—IPv6Version    设置传输Ipv6数据包</code></pre><h4 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h4><blockquote></blockquote><pre><code>-s/—server    服务器模式下运行-U/— single_udp    单线程UDP模式下运行-D/— daemon    以守护进程模式运行服务器</code></pre><h4 id="客户端参数"><a href="#客户端参数" class="headerlink" title="客户端参数"></a>客户端参数</h4><blockquote></blockquote><pre><code>-b/— bandwidth    对于UDP，使用bits/sec （默认 1 Mbit/sec, 亦即 -u）传送带宽-c/— client    运行为客户端，连接到“主机”-d/— dualtest    同步进行双向测试-n/— num    传输的字节量-r/— tradeoff    分别进行双向测试-t/— time    传输持续时间 （默认10 secs）-F/— fileinput    从文件中读取要传输的数据-I/— stdin    从标准输入（stdin）中读取要传输的数据-L/— listenport    双向测试接受端口-P/— parallel    并行客户线程数量-T/— ttl    多点传送的生存时间（默认1）</code></pre><h2 id="Netperf"><a href="#Netperf" class="headerlink" title="Netperf"></a>Netperf</h2><p>Netperf是一种网络性能测量工具，主要用于测试TCP或UDP和Berkeley套接字接口的批量数据传输（bulk data transfer）和请求/应答（request/reponse）性能。Netperf工具以Client/Server方式工作，如下图所示：  </p><p><img src="https://i.loli.net/2018/10/15/5bc458630db61.png" alt="02.png"><br>服务端是netServer，用来侦听来自客户端的连接，客户端是netperf，用来向服务发起网络测试。在客户端与服务端之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果。在控制连接建立并传递了测试配置信息以后，客户端与服务端之间会再建立一个测试连接，用于来回传递特殊的流量，以测试网络的性能。当netServer在服务端启动后，就可在客户端运行netperf来测试网络的性能。netperf通过命令行参数来控制测试的类型和具体的测试选项，根据作用范围的不同，netperf的命令行参数可以分为两大类：全局命令行参数和测试相关的局部参数，两者之间使用—分隔。</p><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote></blockquote><pre><code>netperf [global options] —[test-specific options]</code></pre><h4 id="global-options"><a href="#global-options" class="headerlink" title="global options"></a>global options</h4><blockquote></blockquote><pre><code>-H host    指定远端运行netserver的server IP地址-l testlen    指定测试的时间长度（秒）-t testname    指定进行的测试类型（TCP_STREAM，UDP_STREAM，TCP_RR，TCP_CRR，UDP_RR）</code></pre><h4 id="test-specific-options"><a href="#test-specific-options" class="headerlink" title="test-specific options"></a>test-specific options</h4><blockquote></blockquote><pre><code>-s size    设置本地系统的socket发送与接收缓冲大小-S size    设置远端系统的socket发送与接收缓冲大小-m size    设置本地系统发送测试分组的大小-M size    设置远端系统接收测试分组的大小-D    对本地与远端系统的socket设置TCP_NODELAY选项-r req,resp    设置request和reponse分组的大小</code></pre><h1 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h1><p>Scapy是一个基于Python编写的交互式数据包处理程序，使用Python解释器作为命令面板。可以用来发送、嗅探、解析和伪造网络数据包，常常被用于网络攻击和测试。Scapy可以实现扫描、路由跟踪、探测、单元测试、攻击和发现网络等传统功能，也可以代替hping、arpspoof、arp-sk、arping、p0f，实现了部分Namp、Tcpdump和tshark的功能。它能够伪造或者解码大量的网络协议数据包，能够发送、捕捉、匹配请求和回复包等等。它可以很容易地处理一些典型操作，比如端口扫描，tracerouting，探测，单元测试，攻击或网络发现（可替代hping，NMAP，arpspoof，ARP-SK，arping，tcpdump，tethereal，P0F等）。最重要的他还有很多更优秀的特性——发送无效数据帧、注入修改的802.11数据帧、在WEP上解码加密通道（VOIP）、ARP缓存攻击（VLAN）等，这也是其他工具无法处理完成的。  </p><p>Scapy有其他网络工具无法匹敌的优势，在大多数工具无法完成的任务中也有出色表现，比如发送无效帧、添加自定义的802.11帧、多技术结合等。其实，Scapy的理念非常简单，主要负责定义、发送和接收报文。用户利用Scapy定义一系列报文，接着发送这些报文，然后会收到回应，Scapy将收到的回应与请求匹配，返回到存放报文对（请求，回应）的列表和没有匹配报文的列表。  </p><p>Scapy不仅可以进行交互式数据包处理，还可以作为Python模块在Python程序中使用。需要注意的是，无论是交互式数据处理还是在Python代码中使用，都需要基于root权限。  </p><p>Scapy既然是第三方库，系统上默认是没有安装的。在Ubuntu下，我们可以直接使用命令：</p><blockquote></blockquote><pre><code>sudo apt-get install scapy</code></pre><p>进行安装，安装完成以后，只需要在终端下执行sudo scapy就可以进入Scapy的命令行模式。  </p><p>Scapy常用功能:</p><blockquote><p>1、conf：查看配置信息<br>2、lsc()：查看支持的指令集<br>3、ls()：查看实现的网络协议。ls()中携带的参数可以是任何的一个具体的包，常用的有ARP、Ether、ICMP、IP、UDP、TCP，也支持SNMP、DHCP、STP等。<br>4、IP模块的使用:</p><blockquote><p>我们可以像在Python中一样实例化一个IP对象:</p><blockquote><p>data = IP()<br>data<br>    <ip><br>也可以传入需要自定义的参数:</ip></p></blockquote><blockquote><p>data = IP(dst=”172.16.2.79”)<br>data<br>    <ip dst="172.16.2.79"><br>查看 IP 模块对象的所有信息:</ip></p></blockquote><blockquote><p>data = IP()<br>data.show() </p></blockquote></blockquote></blockquote><pre><code>###[ IP ]### version= 4 ihl= None tos= 0x0 len= None id= 1 flags= frag= 0 ttl= 64 proto= ip chksum= None src= 127.0.0.1 dst= 127.0.0.1 \options\</code></pre><blockquote><p>5、发送和接收报文：<br>可以将上面的 IP 对象封装成一个数据包发送出去。</p><blockquote><p>send：在第三层发送数据包，但没有接收功能。</p><blockquote><p>send(data, iface=”eth0”)<br>    .<br>    Sent 1 packets.<br>sendp：在第二层发送数据包，同样没有接收功能。<br>sr：在第三层发送数据包，有接收功能。<br>sr1：在第三层发送数据包，有接收功能，但只接收第一个包。<br>srp：在第二层发送数据包，有接收功能。<br>srp1：在第二层发送数据包，有接收功能，但只接收第一个包。</p></blockquote></blockquote></blockquote><h1 id="HTTP请求测试工具Postman"><a href="#HTTP请求测试工具Postman" class="headerlink" title="HTTP请求测试工具Postman"></a>HTTP请求测试工具Postman</h1><p>Postman是Google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件。其主要功能包括：<br>模拟各种HTTP requests：</p><blockquote><p>从常用的GET、POST到RESTful的PUT、DELETE等等。甚至还可以发送文件、送出额外的header。</p></blockquote><p>Collection功能（测试集合）:</p><blockquote><p>Collection是requests的集合，在做完一个测试的时候，你可以把这次的 request 存到特定的 Collection 里面，如此一来，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API。而且 Collection还可以Import或是Share出来，让团队里面的所有人共享你建立起来的Collection。</p></blockquote><p>人性化的Response整理:</p><blockquote><p>一般在用其他工具来测试的时候，response的内容通常都是纯文字的raw，但如果是JSON，就是塞成一整行的JSON。这会造成阅读的障碍，而Postman可以针对response内容的格式自动美化。JSON、XML或是HTML都会整理成我们可以阅读的格式。</p></blockquote><p>内置测试脚本语言:</p><blockquote><p>Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果。</p></blockquote><p>设定变量与环境</p><blockquote><p>Postman可以自由设定变量与环境，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我们可能会有多种环境，development、staging或local，而这几种环境中的request URL也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Wireshark&quot;&gt;&lt;a href=&quot;#Wireshark&quot; class=&quot;headerlink&quot; title=&quot;Wireshark&quot;&gt;&lt;/a&gt;Wireshark&lt;/h1&gt;&lt;p&gt;Wireshark这款网络数据包分析工具，在传统网络中就有很广泛的应用，这里就不再多
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>一键安装 Caddy+PHP7+Sqlite3 环境</title>
    <link href="https://cyneliu.github.io/2018/10/13/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85-Caddy-PHP7-Sqlite3-%E7%8E%AF%E5%A2%83/"/>
    <id>https://cyneliu.github.io/2018/10/13/一键安装-Caddy-PHP7-Sqlite3-环境/</id>
    <published>2018-10-13T10:42:18.000Z</published>
    <updated>2018-10-16T14:22:39.788Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多人都有自己搭建网站的需求，但个人网站一般都是个人博客之类的，并不需要很高的服务器配置，这时候就可以考虑使用一个配置比较低的vps来放置自己的个人网站，那么下面这个脚本包你可能刚好会用得到。  </p><p>这个脚本支持Centos 7+ Debian 8+，最小支持内存为64M，可以一键安装 typecho、wordpress、zblog、kodexplorer、laverna、一键整站备份等操作，不仅如此还可以安装v2ray、rinetdbbr来科学上网和加速。</p><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>配置过程很简单，首先将自己的域名解析到vps的ip地址上。然后执行如下命令：</p><blockquote></blockquote><pre><code>wget -N --no-check-certificate git.io/c.sh &amp;&amp; chmod +x c.sh &amp;&amp; bash c.sh</code></pre><p>安装完成后可以根据需要上传自己的网站或者选择一键安装：<br><strong>一键安装typecho博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -t</code></pre><p><strong>一键安装wordpress博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -w</code></pre><p><strong>一键安装zblog博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -z</code></pre><p><strong>一键安装 kodexplorer 可道云</strong></p><blockquote></blockquote><pre><code>bash c.sh -k</code></pre><p><strong>一键安装 laverna 印象笔记</strong></p><blockquote></blockquote><pre><code>bash c.sh -l</code></pre><p><strong>一键整站备份（一键打包/www目录 含数据库）</strong></p><blockquote></blockquote><pre><code>bash c.sh -a</code></pre><p><strong>一键安装 v2ray 翻墙</strong></p><blockquote></blockquote><pre><code>bash c.sh -v</code></pre><p><strong>一键安装 rinetd bbr 端口加速</strong></p><blockquote></blockquote><pre><code>bash c.sh -b</code></pre><p><strong>一键卸载命令：</strong></p><p><em>卸载 caddy</em></p><blockquote></blockquote><pre><code>bash c.sh -unc</code></pre><p><em>卸载 php+sqlite</em></p><blockquote></blockquote><pre><code>bash c.sh -unp</code></pre><p><em>卸载 v2ray</em></p><blockquote></blockquote><pre><code>bash c.sh -unv</code></pre><p><em>卸载 rinetdbbr</em></p><blockquote></blockquote><pre><code>bash c.sh -unb</code></pre><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3" target="_blank" rel="noopener">https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信很多人都有自己搭建网站的需求，但个人网站一般都是个人博客之类的，并不需要很高的服务器配置，这时候就可以考虑使用一个配置比较低的vps来放置自己的个人网站，那么下面这个脚本包你可能刚好会用得到。  &lt;/p&gt;
&lt;p&gt;这个脚本支持Centos 7+ Debian 8+，最小支
      
    
    </summary>
    
      <category term="脚本" scheme="https://cyneliu.github.io/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="脚本" scheme="https://cyneliu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="vps" scheme="https://cyneliu.github.io/tags/vps/"/>
    
      <category term="网站" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>Cisco设备密码重置</title>
    <link href="https://cyneliu.github.io/2018/10/11/Cisco%E8%AE%BE%E5%A4%87%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/"/>
    <id>https://cyneliu.github.io/2018/10/11/Cisco设备密码重置/</id>
    <published>2018-10-11T13:47:03.000Z</published>
    <updated>2018-10-16T14:14:09.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p>1 重启路由器，按ctrl+break/pause或ctrl+c/b,进入remmon模式  </p><blockquote><p>笔记本电脑可能没有pause键，可以运行：osk使用屏幕键盘进行操作  </p></blockquote><p>2 confreg 0x2142　修改寄存器的值  </p><p>3 reset　重启  </p><p>4 copy start run　把nvram内的文件转到内存中  </p><p>5 config-register 0x2102  </p><p>6 修改密码  </p><p>7 copy run start  </p><p>8 reload  </p><blockquote></blockquote><p><strong>0x2142:</strong>路由器启动不读取NVRAM，出厂配置启动<br><strong>0x2102:</strong>路由器启动读取NVRAM，正常配置启动<br><strong>0x2101:</strong>路由器启动不读取新指定的IOS，以出厂IOS启动，通常为base版本，支持功能有限</p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>1 重启，按面板上的mode键3-5秒  </p><p>2 进入switch：模式  </p><p>3 输入：flash_init 初始化flash文件系统  </p><p>4 dir flash:查看flash内文件，其中包含配置文件为config.text  </p><p>5 rename flash:config.text flash:config.old 把原来的文件重命名，随意起名字  </p><p>6 boot重启  </p><p>7 rename flash:config.old flash:config.text   </p><p>8 copy flash:config.text system:running-config  </p><p>9 修改密码  </p><p>10 copy run start 保存配置  </p><p>11 reload/reset/boot 重启  </p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>密码必须要进行修改，不能不设置，如果不需要密码可在修改密码之后进入配置模式删除密码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路由器&quot;&gt;&lt;a href=&quot;#路由器&quot; class=&quot;headerlink&quot; title=&quot;路由器&quot;&gt;&lt;/a&gt;路由器&lt;/h1&gt;&lt;p&gt;1 重启路由器，按ctrl+break/pause或ctrl+c/b,进入remmon模式  &lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="Cisco" scheme="https://cyneliu.github.io/categories/Cisco/"/>
    
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
      <category term="Cisco" scheme="https://cyneliu.github.io/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>linux系统配置检测工具——Superbench</title>
    <link href="https://cyneliu.github.io/2018/10/10/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Superbench/"/>
    <id>https://cyneliu.github.io/2018/10/10/linux系统配置检测工具——Superbench/</id>
    <published>2018-10-10T09:34:56.000Z</published>
    <updated>2018-10-16T14:14:50.507Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经就暗暗吐槽Linux没有一条可以查看配置信息的命令，只能一项一项的查看，体验不是很好。今天无意中发现了一个叫做<strong>Superbench</strong>的脚本，试着用了一下，非常方便，在这里推荐一下。  </p><p>这个脚本主要有以下几个特点：</p><blockquote><p>采用颜色显示，便于区分查找  </p><p>磁盘I/O测试分别使用小文件、中等文件、大文件进行测试，最终计算平均值。  </p><p>网速测试通过多个节点进行测试，其中CM,CU,CT分别代表移动、联通和电信。</p><blockquote><p>ps:<br>中国移动：CMCC ，全称ChinaMobile Communication Company<br>中国联通：CUCC，全称China unicom Communications Corporation<br>中国电信：CTC，全称China Telecommunications Corporation  </p></blockquote></blockquote><h1 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h1><p>执行如下命令:</p><blockquote></blockquote><pre><code>wget -qO- git.io/superbench.sh | bash</code></pre><p>稍等一会就会打印出详细的配置信息：  </p><p><img src="https://i.loli.net/2018/10/10/5bbdccb7a8783.png" alt="01.png"><br><img src="https://i.loli.net/2018/10/10/5bbdccb7aa383.png" alt="02.png"><br>同时我们看到最后还附带了一个分享链接用于分享我们的配置信息，在浏览器打开是这个样子的：  </p><p><img src="https://i.loli.net/2018/10/10/5bbdccb7b6cd2.png" alt="03.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我曾经就暗暗吐槽Linux没有一条可以查看配置信息的命令，只能一项一项的查看，体验不是很好。今天无意中发现了一个叫做&lt;strong&gt;Superbench&lt;/strong&gt;的脚本，试着用了一下，非常方便，在这里推荐一下。  &lt;/p&gt;
&lt;p&gt;这个脚本主要有以下几个特点：&lt;/p&gt;
      
    
    </summary>
    
      <category term="脚本" scheme="https://cyneliu.github.io/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
      <category term="脚本" scheme="https://cyneliu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="配置检测" scheme="https://cyneliu.github.io/tags/%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
</feed>
