<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyne&#39;s Blog</title>
  
  <subtitle>越努力，越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cyneliu.github.io/"/>
  <updated>2018-10-15T11:01:00.828Z</updated>
  <id>https://cyneliu.github.io/</id>
  
  <author>
    <name>Cyne Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SDN实验（一）——常用开源工具</title>
    <link href="https://cyneliu.github.io/2018/10/15/SDN%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://cyneliu.github.io/2018/10/15/SDN实验（一）——常用开源工具/</id>
    <published>2018-10-15T08:38:43.000Z</published>
    <updated>2018-10-15T11:01:00.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><p>Wireshark这款网络数据包分析工具，在传统网络中就有很广泛的应用，这里就不再多说了，主要记录一下笔者之前没有发现的功能或使用方法。  </p><h2 id="OpenFlow数据包"><a href="#OpenFlow数据包" class="headerlink" title="OpenFlow数据包"></a>OpenFlow数据包</h2><p>OpenFlow数据包主要包含五层，依次是：  </p><blockquote><p><strong>Frame：</strong>物理层数据帧概况。<br><strong>Ethernet II：</strong>数据链路层以太网帧头部信息。<br><strong>Internet Protocol Version 4：</strong>互联网IP包头信息。<br><strong>transmission control protocol：</strong>传输层数据段头部信息，此处是TCP。<br><strong>OpenFlow：</strong>位于TCP协议之上，负责解析应用层。  </p></blockquote><h2 id="保存捕获的数据"><a href="#保存捕获的数据" class="headerlink" title="保存捕获的数据"></a>保存捕获的数据</h2><p>wireshark除了有“save”和“save as”的保存方式外，还提供特殊保存的方法（Export Specified）：</p><blockquote><p><strong>All packets:</strong>保存所有已抓取的数据包。<br><strong>Selected packets only:</strong>保存当前鼠标选中的数据包。<br><strong>Marked packets only:</strong>保存当前标记的数据包。标记数据包的方法是在数据包列表中选中目标数据包，然后右击选择“mark packet toggle”。<br><strong>First to last marked:</strong>则将两个标记数据包之间所有的数据包导出。<br><strong>Range:</strong>并输入数据包的编号范围，则将编号连续的数据包导出。<br><strong>Remove ignored packets:</strong>则放弃部分数据包并导出其他所有数据包。放弃数据包的方法是，在数据包列表中选中数据包，右击，选择“ignore packet toggle”。</p></blockquote><h1 id="性能测试工具iPerf和Netperf"><a href="#性能测试工具iPerf和Netperf" class="headerlink" title="性能测试工具iPerf和Netperf"></a>性能测试工具iPerf和Netperf</h1><h2 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h2><p>1、网络吞吐量：单位时间内通过某个网络（信道或接口）的数据量，吞吐量受网络的带宽或者网络的额定速率限制，单位通常表示为bit/s或bps。  </p><p>2、网络延时：一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。影响网络延时的主要因素是路由的跳数和网络的流量。交换机延时（Latency）是指从交换机接收到数据包到开始向目的端口复制数据包之间的时间间隔。有许多因素会影响交换机延时大小，比如转发技术等等。  </p><p>3、抖动：用于描述包在网络中的传输延时的变化，抖动越小，说明网络质量越稳定越好。抖动是评价一个网络性能的最重要的因素。  </p><p>4、丢包率：理想状态下是发送了多少数据包就能接收到多少数据包，但是由于信号衰减、网络质量等诸多因素的影响并不能达到理想状态，而丢包率就是指测试中所丢失的数据包数量占所发送的数据包的比率。</p><h2 id="iPerf"><a href="#iPerf" class="headerlink" title="iPerf"></a>iPerf</h2><p>iPerf 是一种网络性能测试工具，可以运行于Linux、BSD、Unix及Windows等操作系统。 iPerf具有多种参数和特性，支持协议、定时、缓冲区等参数的配置调整，能够测试TCP/UDP最大带宽、延迟抖动、数据包丢失等统计信息，可以根据需求采用不同的参数从而达到不同的测试目的。iPerf基于Server/Client的工作模式，如下图所示：  </p><p><img src="https://i.loli.net/2018/10/15/5bc45614c9c99.png" alt="01.png"><br>客户端向服务端发送一定数量的数据，服务端统计并记录带宽、延时抖动等信息。客户端将数据全部发送后，服务端会回复一个数据包给客户端，将测试数据反馈给客户端。不过，如果网络较为拥塞或者误码率较高，客户端无法收到服务端回复的数据包，则只能显示本地记录的部分测试结果，所以服务端和客户端的测试结果可能有所不同。</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote></blockquote><pre><code>iperf [-s|-c host] [options]</code></pre><h4 id="客户端-服务端通用参数"><a href="#客户端-服务端通用参数" class="headerlink" title="客户端/服务端通用参数"></a>客户端/服务端通用参数</h4><blockquote></blockquote><pre><code>-f/—format  [kmKM]分别表示以Kbits, Mbits, KBytes, MBytes显示报告，默认以Mbits为单位-i/—interval  以秒为单位显示报告间隔-l/—len  读写的缓冲区大小，默认8KB-m/—print_mss  打印最大的TCP数据段大小 (MTU - TCP/IP header)-o/—output    将报告和错误信息输出到指定文件-p/—port    指定服务器端使用的端口或客户端所连接的端口-u/—udp    使用udp协议-w/—window    指定TCP窗口（socket缓冲区）大小，默认是8KB-B/—bind    绑定一个主机地址或接口-C/—compatibility    兼容旧版本（当server端和client端版本不一样时使用）-M/—mss    设置TCP最大数据段大小（MTU - 40 bytes）-N/—nodelay    设置无延迟TCP，禁用 Nagle’s Algorithm-V/—IPv6Version    设置传输Ipv6数据包</code></pre><h4 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h4><blockquote></blockquote><pre><code>-s/—server    服务器模式下运行-U/— single_udp    单线程UDP模式下运行-D/— daemon    以守护进程模式运行服务器</code></pre><h4 id="客户端参数"><a href="#客户端参数" class="headerlink" title="客户端参数"></a>客户端参数</h4><blockquote></blockquote><pre><code>-b/— bandwidth    对于UDP，使用bits/sec （默认 1 Mbit/sec, 亦即 -u）传送带宽-c/— client    运行为客户端，连接到“主机”-d/— dualtest    同步进行双向测试-n/— num    传输的字节量-r/— tradeoff    分别进行双向测试-t/— time    传输持续时间 （默认10 secs）-F/— fileinput    从文件中读取要传输的数据-I/— stdin    从标准输入（stdin）中读取要传输的数据-L/— listenport    双向测试接受端口-P/— parallel    并行客户线程数量-T/— ttl    多点传送的生存时间（默认1）</code></pre><h2 id="Netperf"><a href="#Netperf" class="headerlink" title="Netperf"></a>Netperf</h2><p>Netperf是一种网络性能测量工具，主要用于测试TCP或UDP和Berkeley套接字接口的批量数据传输（bulk data transfer）和请求/应答（request/reponse）性能。Netperf工具以Client/Server方式工作，如下图所示：  </p><p><img src="https://i.loli.net/2018/10/15/5bc458630db61.png" alt="02.png"><br>服务端是netServer，用来侦听来自客户端的连接，客户端是netperf，用来向服务发起网络测试。在客户端与服务端之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果。在控制连接建立并传递了测试配置信息以后，客户端与服务端之间会再建立一个测试连接，用于来回传递特殊的流量，以测试网络的性能。当netServer在服务端启动后，就可在客户端运行netperf来测试网络的性能。netperf通过命令行参数来控制测试的类型和具体的测试选项，根据作用范围的不同，netperf的命令行参数可以分为两大类：全局命令行参数和测试相关的局部参数，两者之间使用—分隔。</p><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote></blockquote><pre><code>netperf [global options] —[test-specific options]</code></pre><h4 id="global-options"><a href="#global-options" class="headerlink" title="global options"></a>global options</h4><blockquote></blockquote><pre><code>-H host    指定远端运行netserver的server IP地址-l testlen    指定测试的时间长度（秒）-t testname    指定进行的测试类型（TCP_STREAM，UDP_STREAM，TCP_RR，TCP_CRR，UDP_RR）</code></pre><h4 id="test-specific-options"><a href="#test-specific-options" class="headerlink" title="test-specific options"></a>test-specific options</h4><blockquote></blockquote><pre><code>-s size    设置本地系统的socket发送与接收缓冲大小-S size    设置远端系统的socket发送与接收缓冲大小-m size    设置本地系统发送测试分组的大小-M size    设置远端系统接收测试分组的大小-D    对本地与远端系统的socket设置TCP_NODELAY选项-r req,resp    设置request和reponse分组的大小</code></pre><h1 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h1><p>Scapy是一个基于Python编写的交互式数据包处理程序，使用Python解释器作为命令面板。可以用来发送、嗅探、解析和伪造网络数据包，常常被用于网络攻击和测试。Scapy可以实现扫描、路由跟踪、探测、单元测试、攻击和发现网络等传统功能，也可以代替hping、arpspoof、arp-sk、arping、p0f，实现了部分Namp、Tcpdump和tshark的功能。它能够伪造或者解码大量的网络协议数据包，能够发送、捕捉、匹配请求和回复包等等。它可以很容易地处理一些典型操作，比如端口扫描，tracerouting，探测，单元测试，攻击或网络发现（可替代hping，NMAP，arpspoof，ARP-SK，arping，tcpdump，tethereal，P0F等）。最重要的他还有很多更优秀的特性——发送无效数据帧、注入修改的802.11数据帧、在WEP上解码加密通道（VOIP）、ARP缓存攻击（VLAN）等，这也是其他工具无法处理完成的。  </p><p>Scapy有其他网络工具无法匹敌的优势，在大多数工具无法完成的任务中也有出色表现，比如发送无效帧、添加自定义的802.11帧、多技术结合等。其实，Scapy的理念非常简单，主要负责定义、发送和接收报文。用户利用Scapy定义一系列报文，接着发送这些报文，然后会收到回应，Scapy将收到的回应与请求匹配，返回到存放报文对（请求，回应）的列表和没有匹配报文的列表。  </p><p>Scapy不仅可以进行交互式数据包处理，还可以作为Python模块在Python程序中使用。需要注意的是，无论是交互式数据处理还是在Python代码中使用，都需要基于root权限。  </p><p>Scapy既然是第三方库，系统上默认是没有安装的。在Ubuntu下，我们可以直接使用命令：</p><blockquote></blockquote><pre><code>sudo apt-get install scapy</code></pre><p>进行安装，安装完成以后，只需要在终端下执行sudo scapy就可以进入Scapy的命令行模式。  </p><p>Scapy常用功能:</p><blockquote><p>1、conf：查看配置信息<br>2、lsc()：查看支持的指令集<br>3、ls()：查看实现的网络协议。ls()中携带的参数可以是任何的一个具体的包，常用的有ARP、Ether、ICMP、IP、UDP、TCP，也支持SNMP、DHCP、STP等。<br>4、IP模块的使用:</p><blockquote><p>我们可以像在Python中一样实例化一个IP对象:</p><blockquote><p>data = IP()<br>data<br>    <ip><br>也可以传入需要自定义的参数:</ip></p></blockquote><blockquote><p>data = IP(dst=”172.16.2.79”)<br>data<br>    <ip dst="172.16.2.79"><br>查看 IP 模块对象的所有信息:</ip></p></blockquote><blockquote><p>data = IP()<br>data.show() </p></blockquote></blockquote></blockquote><pre><code>###[ IP ]### version= 4 ihl= None tos= 0x0 len= None id= 1 flags= frag= 0 ttl= 64 proto= ip chksum= None src= 127.0.0.1 dst= 127.0.0.1 \options\</code></pre><blockquote><p>5、发送和接收报文：<br>可以将上面的 IP 对象封装成一个数据包发送出去。</p><blockquote><p>send：在第三层发送数据包，但没有接收功能。</p><blockquote><p>send(data, iface=”eth0”)<br>    .<br>    Sent 1 packets.<br>sendp：在第二层发送数据包，同样没有接收功能。<br>sr：在第三层发送数据包，有接收功能。<br>sr1：在第三层发送数据包，有接收功能，但只接收第一个包。<br>srp：在第二层发送数据包，有接收功能。<br>srp1：在第二层发送数据包，有接收功能，但只接收第一个包。</p></blockquote></blockquote></blockquote><h1 id="HTTP请求测试工具Postman"><a href="#HTTP请求测试工具Postman" class="headerlink" title="HTTP请求测试工具Postman"></a>HTTP请求测试工具Postman</h1><p>Postman是Google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件。其主要功能包括：<br>模拟各种HTTP requests：</p><blockquote><p>从常用的GET、POST到RESTful的PUT、DELETE等等。甚至还可以发送文件、送出额外的header。</p></blockquote><p>Collection功能（测试集合）:</p><blockquote><p>Collection是requests的集合，在做完一个测试的时候，你可以把这次的 request 存到特定的 Collection 里面，如此一来，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API。而且 Collection还可以Import或是Share出来，让团队里面的所有人共享你建立起来的Collection。</p></blockquote><p>人性化的Response整理:</p><blockquote><p>一般在用其他工具来测试的时候，response的内容通常都是纯文字的raw，但如果是JSON，就是塞成一整行的JSON。这会造成阅读的障碍，而Postman可以针对response内容的格式自动美化。JSON、XML或是HTML都会整理成我们可以阅读的格式。</p></blockquote><p>内置测试脚本语言:</p><blockquote><p>Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果。</p></blockquote><p>设定变量与环境</p><blockquote><p>Postman可以自由设定变量与环境，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我们可能会有多种环境，development、staging或local，而这几种环境中的request URL也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Wireshark&quot;&gt;&lt;a href=&quot;#Wireshark&quot; class=&quot;headerlink&quot; title=&quot;Wireshark&quot;&gt;&lt;/a&gt;Wireshark&lt;/h1&gt;&lt;p&gt;Wireshark这款网络数据包分析工具，在传统网络中就有很广泛的应用，这里就不再多
      
    
    </summary>
    
      <category term="SDN" scheme="https://cyneliu.github.io/categories/SDN/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="实验" scheme="https://cyneliu.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>一键安装 Caddy+PHP7+Sqlite3 环境</title>
    <link href="https://cyneliu.github.io/2018/10/13/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85-Caddy-PHP7-Sqlite3-%E7%8E%AF%E5%A2%83/"/>
    <id>https://cyneliu.github.io/2018/10/13/一键安装-Caddy-PHP7-Sqlite3-环境/</id>
    <published>2018-10-13T10:42:18.000Z</published>
    <updated>2018-10-13T11:08:39.011Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多人都有自己搭建网站的需求，但个人网站一般都是个人博客之类的，并不需要很高的服务器配置，这时候就可以考虑使用一个配置比较低的vps来放置自己的个人网站，那么下面这个脚本包你可能刚好会用得到。  </p><p>这个脚本支持Centos 7+ Debian 8+，最小支持内存为64M，可以一键安装 typecho、wordpress、zblog、kodexplorer、laverna、一键整站备份等操作，不仅如此还可以安装v2ray、rinetdbbr来科学上网和加速。</p><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>配置过程很简单，首先将自己的域名解析到vps的ip地址上。然后执行如下命令：</p><blockquote></blockquote><pre><code>wget -N --no-check-certificate git.io/c.sh &amp;&amp; chmod +x c.sh &amp;&amp; bash c.sh</code></pre><p>安装完成后可以根据需要上传自己的网站或者选择一键安装：<br><strong>一键安装typecho博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -t</code></pre><p><strong>一键安装wordpress博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -w</code></pre><p><strong>一键安装zblog博客</strong></p><blockquote></blockquote><pre><code>bash c.sh -z</code></pre><p><strong>一键安装 kodexplorer 可道云</strong></p><blockquote></blockquote><pre><code>bash c.sh -k</code></pre><p><strong>一键安装 laverna 印象笔记</strong></p><blockquote></blockquote><pre><code>bash c.sh -l</code></pre><p><strong>一键整站备份（一键打包/www目录 含数据库）</strong></p><blockquote></blockquote><pre><code>bash c.sh -a</code></pre><p><strong>一键安装 v2ray 翻墙</strong></p><blockquote></blockquote><pre><code>bash c.sh -v</code></pre><p><strong>一键安装 rinetd bbr 端口加速</strong></p><blockquote></blockquote><pre><code>bash c.sh -b</code></pre><p><strong>一键卸载命令：</strong></p><p><em>卸载 caddy</em></p><blockquote></blockquote><pre><code>bash c.sh -unc</code></pre><p><em>卸载 php+sqlite</em></p><blockquote></blockquote><pre><code>bash c.sh -unp</code></pre><p><em>卸载 v2ray</em></p><blockquote></blockquote><pre><code>bash c.sh -unv</code></pre><p><em>卸载 rinetdbbr</em></p><blockquote></blockquote><pre><code>bash c.sh -unb</code></pre><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3" target="_blank" rel="noopener">https://github.com/dylanbai8/Onekey_Caddy_PHP7_Sqlite3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信很多人都有自己搭建网站的需求，但个人网站一般都是个人博客之类的，并不需要很高的服务器配置，这时候就可以考虑使用一个配置比较低的vps来放置自己的个人网站，那么下面这个脚本包你可能刚好会用得到。  &lt;/p&gt;
&lt;p&gt;这个脚本支持Centos 7+ Debian 8+，最小支
      
    
    </summary>
    
      <category term="vps,脚本" scheme="https://cyneliu.github.io/categories/vps-%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
      <category term="脚本" scheme="https://cyneliu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="vps" scheme="https://cyneliu.github.io/tags/vps/"/>
    
      <category term="网站" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="科学上网" scheme="https://cyneliu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Cisco设备密码重置</title>
    <link href="https://cyneliu.github.io/2018/10/11/Cisco%E8%AE%BE%E5%A4%87%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/"/>
    <id>https://cyneliu.github.io/2018/10/11/Cisco设备密码重置/</id>
    <published>2018-10-11T13:47:03.000Z</published>
    <updated>2018-10-11T13:57:58.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p>1 重启路由器，按ctrl+break/pause或ctrl+c/b,进入remmon模式  </p><blockquote><p>笔记本电脑可能没有pause键，可以运行：osk使用屏幕键盘进行操作  </p></blockquote><p>2 confreg 0x2142　修改寄存器的值  </p><p>3 reset　重启  </p><p>4 copy start run　把nvram内的文件转到内存中  </p><p>5 config-register 0x2102  </p><p>6 修改密码  </p><p>7 copy run start  </p><p>8 reload  </p><blockquote></blockquote><p><strong>0x2142:</strong>路由器启动不读取NVRAM，出厂配置启动<br><strong>0x2102:</strong>路由器启动读取NVRAM，正常配置启动<br><strong>0x2101:</strong>路由器启动不读取新指定的IOS，以出厂IOS启动，通常为base版本，支持功能有限</p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>1 重启，按面板上的mode键3-5秒  </p><p>2 进入switch：模式  </p><p>3 输入：flash_init 初始化flash文件系统  </p><p>4 dir flash:查看flash内文件，其中包含配置文件为config.text  </p><p>5 rename flash:config.text flash:config.old 把原来的文件重命名，随意起名字  </p><p>6 boot重启  </p><p>7 rename flash:config.old flash:config.text   </p><p>8 copy flash:config.text system:running-config  </p><p>9 修改密码  </p><p>10 copy run start 保存配置  </p><p>11 reload/reset/boot 重启  </p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>密码必须要进行修改，不能不设置，如果不需要密码可在修改密码之后进入配置模式删除密码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路由器&quot;&gt;&lt;a href=&quot;#路由器&quot; class=&quot;headerlink&quot; title=&quot;路由器&quot;&gt;&lt;/a&gt;路由器&lt;/h1&gt;&lt;p&gt;1 重启路由器，按ctrl+break/pause或ctrl+c/b,进入remmon模式  &lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="Cisco,网工" scheme="https://cyneliu.github.io/categories/Cisco-%E7%BD%91%E5%B7%A5/"/>
    
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
      <category term="Cisco" scheme="https://cyneliu.github.io/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>linux系统配置检测工具——Superbench</title>
    <link href="https://cyneliu.github.io/2018/10/10/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Superbench/"/>
    <id>https://cyneliu.github.io/2018/10/10/linux系统配置检测工具——Superbench/</id>
    <published>2018-10-10T09:34:56.000Z</published>
    <updated>2018-10-10T09:59:44.268Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经就暗暗吐槽Linux没有一条可以查看配置信息的命令，只能一项一项的查看，体验不是很好。今天无意中发现了一个叫做<strong>Superbench</strong>的脚本，试着用了一下，非常方便，在这里推荐一下。  </p><p>这个脚本主要有以下几个特点：</p><blockquote><p>采用颜色显示，便于区分查找  </p><p>磁盘I/O测试分别使用小文件、中等文件、大文件进行测试，最终计算平均值。  </p><p>网速测试通过多个节点进行测试，其中CM,CU,CT分别代表移动、联通和电信。</p><blockquote><p>ps:<br>中国移动：CMCC ，全称ChinaMobile Communication Company<br>中国联通：CUCC，全称China unicom Communications Corporation<br>中国电信：CTC，全称China Telecommunications Corporation  </p></blockquote></blockquote><h1 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h1><p>执行如下命令:</p><blockquote></blockquote><pre><code>wget -qO- git.io/superbench.sh | bash</code></pre><p>稍等一会就会打印出详细的配置信息：  </p><p><img src="https://i.loli.net/2018/10/10/5bbdccb7a8783.png" alt="01.png"><br><img src="https://i.loli.net/2018/10/10/5bbdccb7aa383.png" alt="02.png"><br>同时我们看到最后还附带了一个分享链接用于分享我们的配置信息，在浏览器打开是这个样子的：  </p><p><img src="https://i.loli.net/2018/10/10/5bbdccb7b6cd2.png" alt="03.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我曾经就暗暗吐槽Linux没有一条可以查看配置信息的命令，只能一项一项的查看，体验不是很好。今天无意中发现了一个叫做&lt;strong&gt;Superbench&lt;/strong&gt;的脚本，试着用了一下，非常方便，在这里推荐一下。  &lt;/p&gt;
&lt;p&gt;这个脚本主要有以下几个特点：&lt;/p&gt;
      
    
    </summary>
    
      <category term="实用工具" scheme="https://cyneliu.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
      <category term="脚本" scheme="https://cyneliu.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="配置检测" scheme="https://cyneliu.github.io/tags/%E9%85%8D%E7%BD%AE%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的命令行网盘</title>
    <link href="https://cyneliu.github.io/2018/10/09/Linux%E4%B8%8B%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BD%91%E7%9B%98/"/>
    <id>https://cyneliu.github.io/2018/10/09/Linux下的命令行网盘/</id>
    <published>2018-10-09T10:17:56.000Z</published>
    <updated>2018-10-09T10:50:24.922Z</updated>
    
    <content type="html"><![CDATA[<p>之前浏览别人博客的时候发现了一个非常好用的文件上传分享工具，而且是在Linux下的，今天试着用了一下，用起来方便快捷，感觉很不错。  </p><p>这款工具的名字叫做<strong>transfer.sh</strong>，transfer.sh的使用也非常简单，可以使用curl的upload-file来上传文件。我这里测试用的是我的一台用作ssr的centos：  </p><p><img src="https://i.loli.net/2018/10/09/5bbc835018e45.png" alt="01.png"></p><p>上图中我是要把当前目录下的“bbr.sh”文件上传分享出去，并且重命名为“bbr2.sh”。那么我们只需要执行如下命令即可：</p><blockquote></blockquote><pre><code>curl --upload-file ./bbr.sh https://transfer.sh/bbr2.sh</code></pre><p>上传完毕后就会返回一个分享链接，也就是“<a href="https://transfer.sh/9edgU/bbr2.sh”，把这个链接发给别人就可以下载了。" target="_blank" rel="noopener">https://transfer.sh/9edgU/bbr2.sh”，把这个链接发给别人就可以下载了。</a>  </p><p><img src="https://i.loli.net/2018/10/09/5bbc8491c4b3b.png" alt="02.png"></p><p>除此之外，transfer.sh还提供其它多种方式，比如一次性上传多个文件等，感兴趣的可以访问官网。  </p><p><strong><em>官网：</em></strong><br><a href="https://transfer.sh/" target="_blank" rel="noopener">https://transfer.sh/</a><br><strong><em>Github:</em></strong><br><a href="https://github.com/dutchcoders/transfer.sh/" target="_blank" rel="noopener">https://github.com/dutchcoders/transfer.sh/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前浏览别人博客的时候发现了一个非常好用的文件上传分享工具，而且是在Linux下的，今天试着用了一下，用起来方便快捷，感觉很不错。  &lt;/p&gt;
&lt;p&gt;这款工具的名字叫做&lt;strong&gt;transfer.sh&lt;/strong&gt;，transfer.sh的使用也非常简单，可以使用
      
    
    </summary>
    
      <category term="实用工具" scheme="https://cyneliu.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="https://cyneliu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>6.使用OpenDaylight界面下发流表</title>
    <link href="https://cyneliu.github.io/2018/09/16/6-%E4%BD%BF%E7%94%A8OpenDaylight%E7%95%8C%E9%9D%A2%E4%B8%8B%E5%8F%91%E6%B5%81%E8%A1%A8/"/>
    <id>https://cyneliu.github.io/2018/09/16/6-使用OpenDaylight界面下发流表/</id>
    <published>2018-09-16T12:11:24.000Z</published>
    <updated>2018-09-16T13:32:12.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>YANG UI是OpenDaylight中一款基于DLUX的应用，旨在简化、激励应用的开发与测试。YANG UI通过动态封装、调用YANG模型和相关REST APIs，生成并展示一个简单的UI界面。开发人员可以通过API请求获取交换机信息，并且以JSON格式展示。YANG UI主要面向上层应用开发，为应用开发人员提供了很多相关工具，有效的节约了开发人员的时间。  </p><p>OpenFlow1.0协议处理数据包的流程相对简单，因为1.0版本只支持单流表。交换机接收到数据包后解析数据包，数据包解析后就开始匹配，从table 0 开始匹配，如果匹配成功则对该数据包执行相应的动作，更新相应的计数器。如果没有找到匹配项则将数据包交给控制器。  </p><p>OpenFlow1.3协议支持多流表匹配，即一个交换机只会有多个流表，因此数据包处理过程相对复杂。首先解析进入设备的报文，然后从table 0开始匹配，按照优先级高低依次匹配该流表中的流表项，一个报文在一个流表中只会匹配上一条流表项。通常根据报文的类型，报文头的字段例如源MAC地址、目的MAC地址、源IP地址、目的IP地址等进行匹配，大部分匹配还支持掩码进行更精确、灵活的匹配。也可以通过报文的入端口或元数据信息来进行报文的匹配，一个流表项中可以同时存在多个匹配项，一个报文需要同时匹配流表项中所有匹配项才能匹配该流表项。报文匹配按照现有的报文字段进行，比如前一个流表通过apply actions改变了该报文的某个字段，则下一个表项按修改后的字段进行匹配。如果匹配成功，则按照指令集里的动作更新动作集，或更新报文/匹配集字段，或更新元数据和计数器。根据指令是否继续前往下一个流表，不继续则终止匹配流程执行动作集，如果指令要求继续前往下一个流表则继续匹配，下一个流表的ID需要比当前流表ID大。当报文匹配失败了，如果存在无匹配流表项（table miss）就按照该表项执行指令，一般是将报文转发给控制器、丢弃或转发给其他流表。如果没有table miss表项则默认丢弃该报文。  </p><p>在Open vSwitch中，流表项作为ovs-ofctl的参数，采用“字段=值”的格式。如果有多个字段，可以用逗号分开，一些常见字段如下：<br><img src="https://i.loli.net/2018/09/16/5b9e4929f0d63.png" alt="1.png"></p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/16/5b9e494803043.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>登录交换机，检查网络连通性。当显示“is_connected：ture”时，表示交换机与控制器连接成功，可以正常进行实验。若不显示“is_connected：ture”时，表示交换机与控制器连接不成功，执行:</p><blockquote></blockquote><pre><code>ovs-vsctl del-controller br-swovs-vsctl set-controller br-sw tcp:30.0.1.3:6633 </code></pre><p>命令手动重连，稍等一会后，重新查看连接状态。</p><h1 id="基于OpenFlow1-0协议下发流表"><a href="#基于OpenFlow1-0协议下发流表" class="headerlink" title="基于OpenFlow1.0协议下发流表"></a>基于OpenFlow1.0协议下发流表</h1><p>步骤1 切换到交换机，执行以下命令设置OpenFlow协议版本为1.0。  </p><blockquote></blockquote><pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow10</code></pre><p>步骤2 选择控制器，单击浏览器图标，打开浏览器。  </p><p>步骤3 访问OpenDaylight Web页面，url是<a href="http://127.0.0.1:8080/index.html" target="_blank" rel="noopener">http://127.0.0.1:8080/index.html</a> ，用户名和密码是admin/admin，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a2625fb7.png" alt="2.png"><br>步骤4 单击左侧的“Nodes”查看节点信息。其中尤其需要关注Node Id，下发流表的时候会用到Node Id，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4a653f1bb.png" alt="3.png"><br>步骤5 单击上图中的“Node Connectors”列的数据即“9”，可以查看具体节点连接信息，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4ac29c305.png" alt="4.png"><br>步骤6 选择左侧的“Yang UI”，单击“Expand all”展开所有目录，查看各种模块，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4af0e3b80.png" alt="5.png"><br>步骤7 展开“opendaylight-inventory rev.2013-08-19”，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b115e5c9.png" alt="6.png"><br>步骤8 补全node id、table id和flow id的值。  </p><p>其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.0协议只支持单流表，所以这里的table id设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b3798ac7.png" alt="7.png"><br>步骤9 单击flow list后面的“+”，展开流表相关的参数。填写第一个框id，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b59027ad.png" alt="8.png"><br>步骤10 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为“0x0800”(说明：由于使用IP地址进行匹配，所以需要设置以太网协议类型。),如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4b789668c.png" alt="9.png"><br>步骤11 填写匹配参数，在“layer-3-match”后面的下拉框中选择“ipv4-match”，使用IP匹配。  </p><p>步骤12 展开“layer-3-match”，填写源IP地址和目的IP地址，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bc1b5579.png" alt="10.png"><br>其中源地址填写主机1的IP地址，目的地址填写主机2的IP地址。  </p><p>步骤13 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4bec99e16.png" alt="11.png"><br>步骤14 展开“apply-actions”，单击“action list”后面的“+”，在action后面的下拉框中选择“drop-action-case”，action order和instruction order都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c0f7a101.png" alt="12.png"><br>步骤15 设置“priority”为27，“idle-timeout”为0，“hard-timeout”为0，“cookie”为100000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c2f54bc4.png" alt="13.png"><br>说明：priority设置的比已有流表项的高，而idle-timeout和hardtimeout都设置为0则代表该流表项永远不会过期，除非被删除。  </p><p>步骤16 向右滚动Actions栏，在路径后面有动作类型GET、PUT、POST、DELETE，下发流表则选择PUT动作，然后单击“Send”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e4c5b47302.png" alt="14.png"><br>步骤17 如果下发成功会出现下面的提示，如果下发不成功则会弹出相应的错误信息。<br><img src="https://i.loli.net/2018/09/16/5b9e4c9033d8d.png" alt="15.png"><br>步骤18 切换到交换机，执行如下命令查看流表，确保刚刚下发的流表已经下发到交换机。如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cc42a811.png" alt="16.png"><br>步骤19 登录主机1，执行如下命令向主机2、主机3发送数据包，测试主机间的连通性。</p><blockquote></blockquote><pre><code># scapy&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4cfe4003b.png" alt="17.png"><br>由上图可知，主机1与主机2之间不通，主机1与主机3通，新下发的流表项生效。  </p><p>说明：如果主机之间通则能够收到answer，如果主机之间不通那么就无法收到answer，当主机之间不通时scapy就会一直发送数据包，如果需要停止可以使用Ctrl+c。  </p><p>步骤20 切换到交换机，执行以下命令删除刚刚下发的流表项，并查看流表确保成功删除。  </p><blockquote></blockquote><pre><code>ovs-ofctl del-flows br-sw dl_type=0x0800,nw_src=10.0.0.3,nw_dst=10.0.0.4ovs-ofctl dump-flows br-sw</code></pre><p>步骤21 切换到主机1执行如下命令，测试主机1和主机2是否连通。</p><blockquote></blockquote><pre><code>result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e4d486b69c.png" alt="18.png"><br>由上图可知，主机1与主机2之间就通了。</p><h1 id="基于OpenFlow1-3协议下发流表"><a href="#基于OpenFlow1-3协议下发流表" class="headerlink" title="基于OpenFlow1.3协议下发流表"></a>基于OpenFlow1.3协议下发流表</h1><p>步骤1 登录交换机，设置OpenFlow协议版本为1.3。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl set bridge br-sw protocols=OpenFlow13</code></pre><p>步骤2 与OpenFlow1.0下发流表的过程解基本一致。展开opendaylight-inventory rev.2013-08-19，选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{id}”。  </p><p>步骤3 补全Actions栏中的路径，其中node id参见之前查询到的Node Id。table id和flow id可以自定义。由于OpenFlow1.3协议支持多级流表，所以这里的table id设置为2。  </p><p>步骤4 单击flow list后面的“+”，流表相关的参数就会展开。设置id为1，路径中的flow id也会随之同步，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e592464e82.png" alt="19.png"><br>步骤5 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e594c3f115.png" alt="20.png"><br>步骤6 在“layer-3-match”后面的下拉框中选择“ipv4-match”。  </p><p>步骤7 展开“layer-3-match”，填写源IP地址和目的IP地址。以主机1的IP为源IP，以主机3的IP为目的IP，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5979b8763.png" alt="21.png"><br>步骤8 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“apply-actions-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e599fdaa67.png" alt="22.png"><br>步骤9 展开“apply-actions”，单击“action list”后面的“+”，在“action”后面的下拉框中选择“drop-action-case”，“action order”和“instruction order”都设置为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59c4a3dca.png" alt="23.png"><br>步骤10 设置“priority”为25，“idle-timeout”为0，“hard-timeout”为0，“cookie”为10000000，“table_id”为2，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e59eb63de3.png" alt="24.png"><br>步骤11 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。PUT成功就会弹出“Request sent successfully”，否则弹出错误信息。  </p><p>步骤12 切换到主机1，执行如下命令，向主机3发送数据包，测试主机1和主机3的连通性。</p><blockquote></blockquote><pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5a28ba934.png" alt="25.png"><br>由上图可知，主机1与主机3之间是连通的，新下发的流表没有发挥作用。原因是数据包在table 0中能够匹配到相应流表就不会被转发到table2，想要table2的流表项发挥作用就需要向table0增加一条流表，将源IP为10.0.0.3，目的IP为10.0.0.2的数据包转发到table2中处理。  </p><p>步骤13 选择“config ——&gt; nodes ——&gt; node{id} ——&gt; table{id} ——&gt; flow{i}”。node id参见之前查询到的Node Id、table id设为0、flow id设为1。  </p><p>步骤14 展开“match ——&gt; ethernet-match ——&gt; ethernet -type”，填写“type”为0x0800。  </p><p>步骤15 匹配参数保持不变，以主机1的IP为源IP，以主机3的IP为目的IP。  </p><p>步骤16 展开“instructions”，并单击“instruction list”后面的“+”，在“instruction”后面下拉框中选择“go-to-table-case”，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5a73537cd.png" alt="26.png"><br>步骤17 展开“go-to-table”，table_id填写为2，即将符合匹配条件的数据包根据table2中的流表项处理。instruction order依旧设为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5aa888c72.png" alt="27.png"><br>步骤18 设“priority”置为23，“idle-timeout”为0，“hard-timeout”为0，“cookie”为1000000000，“table_id”为0，如下图所示。<br><img src="https://i.loli.net/2018/09/16/5b9e5ad13fe66.png" alt="28.png"><br>步骤19 向右滚动Actions栏，选择“PUT”动作，然后单击“Send”下发流表。  </p><p>步骤20 切换到交换机，执行以下命令查看新下发的流表项。</p><blockquote></blockquote><pre><code>ovs-ofctl -O OpenFlow13 dump-flows b</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b076d691.png" alt="29.png"><br>步骤21 切换到主机1，执行如下命令发送数据包，测试主机之间的连通性。</p><blockquote></blockquote><pre><code>&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.10”,ttl=(3,10))/ICMP())&gt;&gt;&gt; result,unanswered=sr(IP(dst=”10.0.0.14”,ttl=(3,10))/ICMP())</code></pre><p><img src="https://i.loli.net/2018/09/16/5b9e5b4ae09ab.png" alt="30.png"><br>由上图可知，主机1与主机3之间不通，而主机1与主机2之间通，流表发挥作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;YANG UI是OpenDaylight中一款基于DLUX的应用，旨在简化、激励应用的开发与测试。YANG UI通过动态封装
      
    
    </summary>
    
      <category term="SDN,实验" scheme="https://cyneliu.github.io/categories/SDN-%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>5.OpenFlow实现示例之中继器HUB</title>
    <link href="https://cyneliu.github.io/2018/09/15/5-OpenFlow%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%AD%E7%BB%A7%E5%99%A8HUB/"/>
    <id>https://cyneliu.github.io/2018/09/15/5-OpenFlow实现示例之中继器HUB/</id>
    <published>2018-09-15T13:09:29.000Z</published>
    <updated>2018-09-15T14:42:29.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow的流表项主要由3部分组成，分别是用于数据分组匹配的分组头域（Head Field），用于保存与条目相关统计信息的计数器（Counter），还有匹配表项后需要对数据分组执行的动作表（Action）。分组头域是数据分组匹配流表项时参照的依据，作用上类似于传统交换机进行二层交换时匹配数据分组的MAC地址，路由器进行三层路由时匹配的IP地址。流表项中的计数器用来统计相关“流”的一些信息，例如查找次数、收发分组数、生存时间等。另外，OpenFlow针对每张表、每个流表项、每个端口、每个队列也都会维护它们相应的计数器。动作表指定了OpenFlow交换机处理相应“流”的行为。相比于传统网络设备对数据分组只能进行较为单一的转发操作，流表项根据指定动作字段来指导OF交换机如何处理“流”。动作表可以包含0个或多个动作，交换机会按照这些动作的先后顺序依次执行，如果其中不包含转发（Forward）动作的话，数据分组就会被丢弃掉，如果包含转发动作，数据分组会得到相应的转发处理，但是OpenFlow v1.0无法保证不同的数据分组的转发顺序。动作可以分为两种类型：必选动作（Required Action）和可选动作（Optional Action）。必选动作是默认支持的，而交换机需要通知控制器它支持的可选动作。另外，当流表项中存在OpenFlow交换机不支持的动作时将向控制器返回错误消息。在SDN网络中，控制器下发流表主要有两种模式，分别是reactive模式和proactive模式。  </p><p>传统交换机参照MAC地址转发，路由器参照IP地址转发，通过定制ASIC芯片可以实现高速工作。而OpenFlow将网络协议栈扁平化，协议栈各层次对于转发设备而言不再具有明确的界限，各个网络字段都可作为流表中的匹配域，通过通配符掩码实现任意字段的组合。相比于传统网络，这种做法无疑大大提高了网络灵活性，但付出的代价是硬件设备为了适应这种通配的匹配方式，一般来说需要采用TCAM（Ternary Content Addressable Memory）来设计流表，但是TCAM的成本要高出很多，这就极大地限制了流表的规模，也就限制了SDN的规模。如果按照很多客户的要求，动辄要几十KB甚至上百KB的流表要求，至少需要20Mbit的TCAM，远远超过目前市场上容量最大的交换芯片的TCAM大小。为了克服TCAM表较小的问题，SDN先驱们提出采用reactive的方式来编写TCAM。<br><img src="https://i.loli.net/2018/09/15/5b9d05573ed46.png" alt="1.png"><br>在reactive模式下，OpenFlow交换机接收到未知数据包时，会向控制器发送一条packet_in消息询问控制器如何处理该数据包。控制器接收到packet_in消息后，计算路径并发送一条flow_mod消息指示交换机如何处理该数据包。并且，当老化定时器超时后就可以删除与该数据包相关的流表项。如此一来，OpenFlow交换机无需维护全部流表，只有当未知数据包到达交换机时才会触发reactive模式，可以有效的节省TCAM的空间。但是reactive模式缺点就是交换机无法即时地处理未知数据包，需要依赖控制器的决策，虽然在一定程度上解决了TCAM较小带来的问题，但是也让SDN控制器成为系统扩展的瓶颈，随着网络规模的不断扩大，SDN控制器无法处理大规模的网络流量，SDN控制器的性能就会限制网络规模的扩展。  </p><p>OpenFlow交换机和OpenFlow控制器之间的通道建立后，由OpenFlow控制器向OpenFlow交换机预先发送流表项方式称之为proactive模式。proactive模式的设置不是必须在控制器与交换机建立连接后立刻下发流表，可以在连接建立后的任意时间下发流表。proactive模式的主要特点是“主动”，控制器主动下发流表给交换机，随后交换机可以直接根据流表进行转发。proactive模式下控制器的压力会大大减轻，不过TCAM造成的局限性也尤为明显。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9d0af0ac5d1.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，检查网络连通性。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p><p>步骤2 登录主机，查看主机IP。  </p><p>登录交换机，查看交换机mac地址。  </p><blockquote></blockquote><pre><code>ifconfig |more</code></pre><p>根据实验拓扑图、交换机和主机的mac地址，可以判断出交换机eth1连接host1，eth2连接host2，eth3连接host3。</p><h1 id="proactive模式"><a href="#proactive模式" class="headerlink" title="proactive模式"></a>proactive模式</h1><p>步骤1 Open Daylight控制器与交换机建立连接后，会自动下发初始流表。登录交换机使用下列命令查看初始流表。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p>如果没有的话重启一下交换机。<br><img src="https://i.loli.net/2018/09/15/5b9d129607bf4.png" alt="2.png"><br>步骤2 登录控制器，在下方的“Application Finder”中搜索“postman”，并打开自带的Postman工具，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d151e53f54.png" alt="3.png"><br>步骤3 获取交换机的id信息。打开Basic Auth页签，Username字段填写admin，Password字段填写admin完成认证。  </p><p>提交方式为GET，URL地址栏中输入<a href="http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/operational/opendaylight-inventory:nodes。</a>  </p><p>步骤4 单击Send按钮，获取交换机id信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d156896885.png" alt="4.png"><br>步骤5 下发一条流表。</p><blockquote><p>选择提交方式“PUT”。  </p></blockquote><blockquote><p>URL地址栏输入如下形式的地址：http://{controller-ip}:8080/restconf/config/opendaylight-inventory:nodes/node/{node-id}/table/{table-id}/flow/{flow-id}。  </p></blockquote><blockquote><p>其中，{controller-ip}为控制器的ip地址，node-id为上面获取到的交换机id信息，table-id这里为0，flow-id根据下发不同流表变化，可自定义。本实验URL地址栏输入如下地址：<a href="http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。" target="_blank" rel="noopener">http://127.0.0.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:143226243417414/table/0/flow/14。</a>  </p></blockquote><blockquote><p>填写Headers信息，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d16d59439b.png" alt="5.png"><br>单击Body，Bady格式选择raw—&gt;XML(application/xml)。Body内容如下所示：  </p></blockquote><blockquote><p>匹配条件为ANY，actions为ALL，即将交换机收到的所有数据包转发到除入端口外的所有端口，从而实现中继器HUB的功能。</p></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;priority&gt;35&lt;/priority&gt;    &lt;flow-name&gt;SDN&lt;/flow-name&gt;    &lt;idle-timeout&gt;0&lt;/idle-timeout&gt;    &lt;hard-timeout&gt;0&lt;/hard-timeout&gt;    &lt;match&gt;ANY&lt;/match&gt;    &lt;id&gt;14&lt;/id&gt;    &lt;table_id&gt;0&lt;/table_id&gt;    &lt;instructions&gt;        &lt;instruction&gt;            &lt;order&gt;0&lt;/order&gt;            &lt;apply-actions&gt;                &lt;action&gt;                       &lt;output-action&gt;                          &lt;output-node-connector&gt;ALL&lt;/output-node-connector&gt;                       &lt;/output-action&gt;                       &lt;order&gt;0&lt;/order&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;        &lt;/instruction&gt;    &lt;/instructions&gt;&lt;/flow&gt;</code></pre><p>步骤6 单击Send按钮发送请求，STATUS显示请求发送成功，流表下发成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9d18177ec0e.png" alt="6.png"><br>步骤7 登录交换机查看下发的流表，执行以下命令：</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br-sw</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d184ac4929.png" alt="7.png"><br>步骤8 登录主机host1，对主机host2进行ping操作，host2的IP为10.0.0.10，执行以下命令：</p><blockquote></blockquote><pre><code>ping 10.0.0.10</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18930750e.png" alt="8.png"><br>步骤9 登录交换机用tcpdump捕获广播到host2和host3数据包。host2对应的端口是eth2，host3对应的端口是eth3，分别捕获这两个端口上的数据包。  </p><p>（备注：选择不在host3、host2上抓包的原因是：由于当h1 ping h2时，数据包从交换机所有端口output出去后，openstack中的Linux-bridge会根据转发表过滤掉所有目的地址与端口不一致的数据包，因此host3上无法捕获host1与host2之间的数据包。）</p><blockquote></blockquote><pre><code>tcpdump -i eth2</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d18d0ab61c.png" alt="9.png"></p><blockquote></blockquote><pre><code>tcpdump -i eth3</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9d19734c90f.png" alt="10.png"></p><h1 id="reactive模式"><a href="#reactive模式" class="headerlink" title="reactive模式"></a>reactive模式</h1><p>reactive模式需要依赖SDN控制器的反应，实现较为复杂，在此仅进行方案介绍，不做实验操作，有兴趣的同学可自行拓展学习。  </p><p>步骤1 reactive模式的触发机制就是交换机将接收到数据包转发给控制器，交换机转发数据包给控制器的情况有两种：一个是交换机接收到未知数据包；另一个就是流表action要求交换机将数据包转发给控制器。因此设置reactive模式的第一步是下发一条流表，priority设置为最高65535，匹配条件为ANY，actions是将数据包output到controller。<br><img src="https://i.loli.net/2018/09/15/5b9d1a21ac061.png" alt="11.png"><br>流表项设置好后，当host1发送数据包时，交换机接收到数据包后会发送packet_in消息给控制器。  </p><p>步骤2 控制器接收到packet_in消息后对消息中的内容进行判断，计算分析后发送packet_out消息给交换机，告知交换机如何处理该数据包。本实验中控制器会要求交换机将数据包转发到除入端口外的所有端口，从而实验中继器的功能。<br><img src="https://i.loli.net/2018/09/15/5b9d1a4af035d.png" alt="12.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;OpenFlow的流表项主要由3部分组成，分别是用于数据分组匹配的分组头域（Head Field），用于保存与条目相关统计信
      
    
    </summary>
    
      <category term="SDN,实验" scheme="https://cyneliu.github.io/categories/SDN-%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>4.基于RESTCONF的流表管理</title>
    <link href="https://cyneliu.github.io/2018/09/14/4-%E5%9F%BA%E4%BA%8ERESTCONF%E7%9A%84%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/14/4-基于RESTCONF的流表管理/</id>
    <published>2018-09-14T14:36:06.000Z</published>
    <updated>2018-09-15T13:10:25.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>所谓流表，其实可被视作是SDN对网络设备的数据转发功能的一种抽象。在传统网络设备中，交换机和路由器的数据转发需要依赖设备中保存的二层MAC地址转发表或者三层的IP地址路由表，SDN交换机中使用的流表也是如此，不过在它的表项中整合了网络中各个层次的网络配置信息，从而在进行数据转发时可以使用更丰富的规则。  </p><p>在使用RESTCONF下发流表时，需要学习的是请求消息的BODY的结构。实例如下：</p><blockquote></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;     &lt;table_id&gt;0&lt;/table_id&gt;    &lt;id&gt;100&lt;/id&gt;     &lt;strict&gt;false&lt;/strict&gt;   &lt;priority&gt;1&lt;/priority&gt;     &lt;instructions&gt;         &lt;instruction&gt;             &lt;order&gt;0&lt;/order&gt;             &lt;apply-actions&gt;                 &lt;action&gt;                     &lt;order&gt;0&lt;/order&gt;                     &lt;output-action&gt;&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;                    &lt;/output-action&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;        &lt;/instruction&gt;    &lt;/instructions&gt;    &lt;match&gt;    &lt;/match&gt;&lt;/flow&gt;</code></pre><p>BODY中定义了流表名称（flowname）、flow所在的table（table_id）、flow的id（id）、是否严格匹配（strict）、优先级和匹配字段（match fields）、优先级（priority）、指令（instructions）、超时（timeouts）、cookie等值。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc7011f.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机查看网络连通性。由于OpenDaylight组件过于庞大，所以启动比较慢，容易导致控制器与交换机连接不成功的现象，间接导致主机无法获取IP。所以使用OpenDaylight控制器时，需要先检查网络连通性，查看交换机与控制器连接情况。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p>出现“is_connected: true”，表明控制器与交换机连接成功。  </p><p>步骤6 登录交换机，执行如下命令连接控制器。</p><blockquote></blockquote><pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640</code></pre><p>原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。</p><h1 id="删除ODL自动下发的流表"><a href="#删除ODL自动下发的流表" class="headerlink" title="删除ODL自动下发的流表"></a>删除ODL自动下发的流表</h1><p>在实验过程中需要验证两个不能通信的主机，通过REST北向接口下发流表，使得两个主机能够通信，所以需要删除原先的默认通信流表。  </p><p>步骤1 登录交换机，执行如下命令删除流表，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl del-flows -O OpenFlow13 br-sw</code></pre><p><img src="https://i.loli.net/2018/09/15/5b9cf7bc315a1.png" alt="1.png"><br>步骤2 执行ovs-ofctl dump-flows -O OpenFlow13 br-sw查看是否删除成功，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf7eee833f.png" alt="2.png"><br>步骤3 登录其中的一个主机，查看主机间网络网络连通情况，此时主机间无法进行通信，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf80fce130.png" alt="3.png"></p><h1 id="下发通信流表"><a href="#下发通信流表" class="headerlink" title="下发通信流表"></a>下发通信流表</h1><p>步骤1 登录控制器，打开浏览器，输入URL：<strong>http://[controller_ip]:8181/index.html</strong>，输入有户名：admin，密码：admin，单击登录。登录后，单击Nodes菜单，获取交换机node id，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cf86025757.png" alt="4.png"><br>步骤2 单击Applications Menu/Development/Postman打开postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa287541e.png" alt="5.png"><br>步骤3 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/100。  </p><p>[controller-ip]为当前控制器的数据层的ip，[node-id]即步骤1中获得的node id请求类型选择PUT。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。选择BODY的类型raw -&gt;XML（application/xml），如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfa5754286.png" alt="6.png"><br>步骤4 输入Body内容如下：</p><blockquote></blockquote><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;flow xmlns=&quot;urn:opendaylight:flow:inventory&quot;&gt;    &lt;flow-name&gt;add-flow&lt;/flow-name&gt;    &lt;table_id&gt;0&lt;/table_id&gt;    &lt;id&gt;100&lt;/id&gt;    &lt;installHw&gt;false&lt;/installHw&gt;    &lt;strict&gt;false&lt;/strict&gt;  &lt;priority&gt;1&lt;/priority&gt;    &lt;instructions&gt;       &lt;instruction&gt;           &lt;order&gt;0&lt;/order&gt;           &lt;apply-actions&gt;               &lt;action&gt;                   &lt;order&gt;0&lt;/order&gt;                   &lt;output-action&gt;&lt;output-node-connector&gt;FLOOD&lt;/output-node-connector&gt;                   &lt;/output-action&gt;                &lt;/action&gt;            &lt;/apply-actions&gt;            &lt;/instruction&gt;    &lt;/instructions&gt;    &lt;match&gt;    &lt;/match&gt;&lt;/flow&gt;注意：严格区分大小写</code></pre><p>步骤5 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb40e9192.png" alt="7.png"><br>步骤6 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/。[controller-ip] 为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id请求类型选择GET。问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb65ceea0.png" alt="8.png"><br>步骤7 点击Send按钮，输出结果如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfb85a72bb.png" alt="9.png"><br>可以看到，此流表为之前通过REST北向接口下发的流表。  </p><p>步骤8 登录其中的一个主机，查看主机间网络网络情况，此时主机间能够进行通信。</p><h1 id="使用Postman删除流表"><a href="#使用Postman删除流表" class="headerlink" title="使用Postman删除流表"></a>使用Postman删除流表</h1><p>步骤1 输入URL http://[controller-ip]:8181/restconf/config/opendaylight-inventory:nodes/node/[node-id]/table/0/flow/[flow-id]。  </p><p>[controller-ip]为当前控制器的数据层的ip，[node-id]即【四、下发通信流表】步骤1获得的node id，[flow-id]为之前下发流表的id，可以到【四、下发通信流表】的BODY中查看。请求类型选择DELETE.访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择basic auth。输入用户名和密码，用户名和密码都是admin。点击Send，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf41812.png" alt="10.png"><br>步骤2登录交换机，切换至root用户。执行命令ovs-ofctl dump-flows -O OpenFlow13 br-sw，可验证流表已删除，如下图所示。<br><img src="https://i.loli.net/2018/09/15/5b9cfbcf2cb35.png" alt="11.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;所谓流表，其实可被视作是SDN对网络设备的数据转发功能的一种抽象。在传统网络设备中，交换机和路由器的数据转发需要依赖设备中保
      
    
    </summary>
    
      <category term="SDN,实验" scheme="https://cyneliu.github.io/categories/SDN-%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>3.Open vSwitch流表管理</title>
    <link href="https://cyneliu.github.io/2018/09/14/3-Open-vSwitch%E6%B5%81%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/14/3-Open-vSwitch流表管理/</id>
    <published>2018-09-14T13:10:47.000Z</published>
    <updated>2018-09-14T14:14:29.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议去连接Open vSwitch，创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。  </p><p>在OpenFlow的白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或者多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。  </p><p>当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。<br>在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或者空格分开。一些常用的字段列举如下：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd40468.png" alt="1.png"><br>ovs-ofctl关于流表管理的常用命令：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd3a959.png" alt="2.png"><br>对于add−flow，add−flows和mod−flows这三个命令，还需要指定要执行的动作：actions=[target][,target…]，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br>常见的操作有：<br><img src="https://i.loli.net/2018/09/14/5b9bb4dd4cb85.png" alt="3.png"></p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9bb4dd4d9be.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录交换机，执行以下命令，查看镜像中原有的网桥，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbf7b25c05.png" alt="4.png"><br>步骤5 执行以下命令，删除当前网桥，并进行确认，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl del-br br-swovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbfb869e58.png" alt="5.png"></p><h1 id="流表管理"><a href="#流表管理" class="headerlink" title="流表管理"></a>流表管理</h1><p>步骤1 执行以下命令，添加网桥，并查看虚拟交换机的基本信息，如下图所示。</p><blockquote></blockquote><pre><code>ovs-vsctl add-br br0ovs-ofctl show br0</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bbffd27c45.png" alt="6.png"><br>由上图可知，可以查看到交换机dpid、流表数量、性能参数、动作参数、MAC地址等信息。  </p><p>步骤2 执行以下命令，查看虚拟交换机上各端口的状态，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl dump-flows br0</code></pre><p>由上图可知，输出的结果中包含了各端口上收到的数据包数，字节数，丢包数，错误数据包数等。  </p><p>步骤3 执行以下命令，添加一条流表项，设置流表项生命周期为1000s，优先级为17，入端口为3，动作是output:2。</p><blockquote></blockquote><pre><code>ovs-ofctl add-flow br0 idle_timeout=1000,priority=17,in_port=3,actions=output:2说明：这条流表项的作用是将端口3接收到的数据包从端口2输出。</code></pre><p>步骤4 执行以下命令，查看交换机上所有流表信息，如下图所示。</p><blockquote><pre><code>ovs-ofctl dump-flows br0</code></pre></blockquote><p>步骤5 执行以下命令，删除入端口为3的的流表项，删除后，再次查看流表信息，如下图所示。</p><blockquote></blockquote><pre><code>ovs-ofctl del-flows br0 in_port=3ovs-ofctl dump-flows br0</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9bc08844d29.png" alt="7.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置Open
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>秒懂MBR和GPT分区表</title>
    <link href="https://cyneliu.github.io/2018/09/13/%E7%A7%92%E6%87%82MBR%E5%92%8CGPT%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>https://cyneliu.github.io/2018/09/13/秒懂MBR和GPT分区表/</id>
    <published>2018-09-13T11:58:17.000Z</published>
    <updated>2018-09-13T12:39:54.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的Apple分区图。<br>MBR的全称是Master Boot Record（主引导记录），MBR早在1983年IBM PC DOS 2.0中就已经提出。之所以叫“主引导记录”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。主引导扇区是硬盘的第一扇区。它由三个部分组成，主引导记录MBR、硬盘分区表DPT和硬盘有效标志。在总共512字节的主引导扇区里MBR占446个字节，偏移地址（0000H–0088H），它负责从活动分区中装载，并运行系统引导程序；第二部分是Partition table区（DPT分区表），占64个字节；第三部分是Magic number，占2个字节。 </p><h1 id="MBR分区表系统"><a href="#MBR分区表系统" class="headerlink" title="MBR分区表系统"></a>MBR分区表系统</h1><p>所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果你安装了Windows，Windows启动加载器的初始信息就放在这个区域里——如果MBR的信息被覆盖导致Windows不能启动，你就需要使用Windows的MBR修复功能来使其恢复正常。如果你安装了Linux，则位于MBR里的通常会是GRUB加载器。  </p><p>分区表偏移地址为01BEH–01FDH，每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4，分别对应MBR的四个主分区。Magic number也就是结束标志字，偏移地址01FE–01FF的2个字节，固定为55AA，如果该标志错误系统就不能启动。   </p><p>MBR最大支持2.2TB磁盘，它无法处理大于2.2TB容量的磁盘。MBR还只支持最多4个主分区——如果你想要更多分区，你需要创建所谓“扩展分区”，并在其中创建逻辑分区。 </p><h1 id="GPT分区表系统"><a href="#GPT分区表系统" class="headerlink" title="GPT分区表系统"></a>GPT分区表系统</h1><p>GPT的全称是Globally Unique Identifier Partition Table，意即GUID分区表，它的推出是和UEFI BIOS相辅相成的，鉴于MBR的磁盘容量和分区数量已经不能满足硬件发展的需求，GPT首要的任务就是突破了2.2T分区的限制，最大支持18EB的分区。 </p><p>而在分区数量上，GPT会为每一个分区分配一个全局唯一的标识符，理论上GPT支持无限个磁盘分区，不过在Windows系统上由于系统的限制，最多只能支持128个磁盘分区，基本可以满足所有用户的存储需求。在每一个分区上，这个标识符是一个随机生成的字符串，可以保证为地球上的每一个GPT分区都分配完全唯一的标识符。   </p><p>而在安全性方面，GPT分区表也进行了全方位改进。在早期的MBR磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT还为这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏，GPT会发觉这些破坏，并从磁盘上的其他地方进行恢复。  </p><p>小结：所以对于新平台用户（Intel 6系以后/AMD 900系列以后和A系列）来说，都强烈推荐使用GPT分区表格式，目前包括Windows Vista、7、8、8.1、10已经都支持读取和使用GPT分区表。而对于使用Windows 8、8.1、10的用户，换用GPT后开机启动速度也可以进一步得到显著提升。 </p><h1 id="BIOS-MBR"><a href="#BIOS-MBR" class="headerlink" title="BIOS+MBR"></a>BIOS+MBR</h1><p>这种方式是目前最常见的装机方式，所有的系统都会支持，兼容较老硬件，目前新电脑大多出厂时就使用UEFI方式启动。</p><h1 id="UEFI-GPT"><a href="#UEFI-GPT" class="headerlink" title="UEFI+GPT"></a>UEFI+GPT</h1><p>GPT与UEFI是相辅相成的，如果分区表系统是GPT，那么必须使用UEFI，传统的BIOS方式无法启动，这也就是为什么现在很多人在给新机器重装系统时无法启动的原因。  </p><p>UEFI+GPT还有一个优点就是开机速度更快，原因是开机时跳过外设检测，并且可以实现启动时原生分辨率，搭载固态硬盘开机时间很短，十秒左右。  </p><p>UEFI可用鼠标操作图形界面，不再是枯燥的蓝底白字的英文。由Intel提出，用于取代BIOS。UEFI的优越特性：可操作性、安全性、兼容性、可扩展性。  </p><p>主板为了兼容MBR分区表，一般会提供Legacy BIOS和UEFI BIOS启动模式选项，可以把UEFI设置成Legacy模式（传统模式）、打开CSM兼容模块，让其支持传统MBR启动，此时效果同BIOS+MBR。如果要使用UEFI模式安装Windows，就必须开启UEFI启动模式。</p><h1 id="系统支持性"><a href="#系统支持性" class="headerlink" title="系统支持性"></a>系统支持性</h1><p>目前64bit Windows Vista、7、8、8.1、10都已经支持GPT分区表，而Windows 8、8.1、10都已经原生支持UEFI，安装这些系统的时候：只要硬盘设置为GPT分区表，主板设置为UEFI启动后，就可以直接开始安装操作系统了。 而对于Windows Vista、7系统，就需要手动添加UEFI支持：我们可以找一份Windows 8或者10安装镜像，从安装文件中提取Bootmgfw.efi文件，重命名为BOOTX64.EFI，拷贝到win7安装文件的\EFI\Boot\下，如果没有BOOT文件夹新建一个即可。 </p><h1 id="修改为传统方式启动"><a href="#修改为传统方式启动" class="headerlink" title="修改为传统方式启动"></a>修改为传统方式启动</h1><p>如果实在是搞不明白或者像之前的我一样不太懂的话，可以使用分区助手将GPT改为MBR，如图：<br><img src="https://i.loli.net/2018/09/13/5b9a589d17e85.jpg" alt="1.jpg"><br>选中磁盘，在左侧菜单中选择“转换到MBR磁盘”：<br><img src="https://i.loli.net/2018/09/13/5b9a589cddfb3.jpg" alt="2.jpg"><br>转换成功：<br><img src="https://i.loli.net/2018/09/13/5b9a589d066d8.jpg" alt="3.jpg"><br>转换完成进行分区后，不要忘了把装系统的分区转换成活动分区：<br><img src="https://i.loli.net/2018/09/13/5b9a589d099b4.jpg" alt="4.jpg"><br>最后还是建议大家花几分钟时间了解一下UEFI的方式，这必定是未来的一个趋势，并不推荐采用上图将GPT修改为MBR的方式重装系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分区表&quot;&gt;&lt;a href=&quot;#分区表&quot; class=&quot;headerlink&quot; title=&quot;分区表&quot;&gt;&lt;/a&gt;分区表&lt;/h1&gt;&lt;p&gt;全新硬盘未初始化之前，必须对其进行分区，硬盘分区初始化的格式包括MBR和GPT两种，另外对于基于PowerPC的Mac电脑还有专门的
      
    
    </summary>
    
      <category term="装机" scheme="https://cyneliu.github.io/categories/%E8%A3%85%E6%9C%BA/"/>
    
    
      <category term="装机" scheme="https://cyneliu.github.io/tags/%E8%A3%85%E6%9C%BA/"/>
    
      <category term="硬件" scheme="https://cyneliu.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2.OVSDB的网桥和端口管理</title>
    <link href="https://cyneliu.github.io/2018/09/13/2-OVSDB%E7%9A%84%E7%BD%91%E6%A1%A5%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <id>https://cyneliu.github.io/2018/09/13/2-OVSDB的网桥和端口管理/</id>
    <published>2018-09-13T07:21:32.000Z</published>
    <updated>2018-09-15T11:44:15.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><p>在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFlow和OVSDB两种南向协议方式与Open vSwitch交换机进行交互，其中通过OpenFlow来引导数据包流的转发，通过OVSDB可以进行端口和隧道的增加、更新以及删除，这些隧道和端口提供流转发的管道。因此，OVSDB在Open vSwitch作为一个重要的事实标准，OpenDaylight系统如何高效地支持OVSDB也变得非常重要。OpenDaylight的OVSDB子项目实现了OVSDB管理协议，该协议允许控制器进行虚拟交换机的南向配置。OVSDB协议包含一个OVSDB库和各种插件用法，该协议使用JSON/RPC调用的方式来操作内置OVSDB的物理或虚拟交换机。<br>OVSDB子项目主要包含Northbound模块、plugin模块和OVSDB Library模块，其中北向Northbound模块可供外部APP调用，南向OVSDB Library通过OVSDB协议与外部通信，进行OVSDB的管理，具体系统架构如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a10f6d7c34.png" alt="1.png"><br>Library模块主要包含message、notation、impl、jsonrpc和schema等程序包,其中jsonrpc主要提供兼容rpc1.0的解码器，能够从TCP流解码JSON消息；notation主要包含OVSDB MAP、ResultSet等定义以及Json串行化；schema提供OVSDB数据库模式的表示。</p><p>Plugin模块主要包含api、impl、internal和error等程序包，其中api程序包主要提供OVSDB的连接、增删改查等服务，impl包中的类是其接口的实现。  </p><p>Northbound模块主要包含五大类,分别是DatabaseResource、NodeResource、OvsdbNorthboundV2、OvsdbNorthboundV3、RowResource、TableResource。以类OvsdbNorthboundV2为例进行说明，该类提供OVSDB北向 REST API接口，用于创建、读取、更新和删除任一OVSDB表中的记录。创建OVSDB Row时，body请求体中的JSON格式与OVSDB JSON-PRC消息相同。northbound及其功能描述如下表所示。<br><img src="https://i.loli.net/2018/09/13/5b9a123b86027.png" alt="2.png"><br>用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。而Postman不仅可以调试简单的css、html、脚本等简单的网页基本信息，还可以发送GET、POST、PUT、DENLETE等几乎所有类型的HTTP请求。Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/14/5b9b47e2af14d.png" alt="拓扑.png"></p><h1 id="创建实验"><a href="#创建实验" class="headerlink" title="创建实验"></a>创建实验</h1><p>步骤1 登录OpenDaylight控制器，确保服务已经启动成功，由于OpenDaylight组件过于庞大，所以启动比较慢，需等待一段时间，使用命令：</p><blockquote></blockquote><pre><code>netstat -an|grep 6633 #netstat -an:查看端口对应的应用</code></pre><p>查看端口是否处于监听状态：<br><img src="https://i.loli.net/2018/09/14/5b9b46db45a61.png" alt="3.png"><br>步骤2 在保证控制6633端口处于监听状态后，登录交换机，查看交换机与控制器连接情况。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9b4746ca6a9.png" alt="4.png"><br>上图中controller下方显示“is_connected:true”则表明连接成功。<br>步骤3 登录控制器，查看控制器IP，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4798e189e.png" alt="5.png"><br>步骤4 登录交换机，连接控制器。原本控制器与交换机之间的连接是通过OpenFlow协议的，在此基于OVSDB协议创建一个新的连接，其中20.0.1.3是控制器IP地址，6640是OVSDB协议对应的侦听端口。执行如下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl set-manager tcp:20.0.1.3:6640</code></pre><p>连接成功后在manager下面会有“is_conneted:true”：<br><img src="https://i.loli.net/2018/09/14/5b9b47e2a28df.png" alt="6.png"></p><h1 id="创建网桥"><a href="#创建网桥" class="headerlink" title="创建网桥"></a>创建网桥</h1><p>步骤1 登录控制器，单击Applications Menu—&gt;Development—&gt;Postman打开Postman应用，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4e42b73f7.png" alt="7.png"><br>步骤2 在创建网桥前，需要先获取交换机节点信息，输入URL <strong>http://[controller ip]:8282/ovsdb/nb/v3/node</strong>。  </p><p>请求类型选择GET，单击Send按钮发送GET请求。访问一个页面需要输入用户名和密码，同样，用Postman发送请求也需要一定的权限。单击Authorization，type选择Basic Auth。输入用户名和密码，用户名和密码都是admin。Body中返回的就是交换机节点信息，此处获取到的节点信息在后面会用到，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9b4ebbb7028.png" alt="8.png"><br>步骤3 发送POST请求创建网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows，其中“20.0.1.4:59141”</a>  </p><p>就是前面获取到的交换机节点信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba28a8e540.png" alt="9.png"><br>单击Headers，输入用户名和密码生成HTTP认证头部，POST请求还需要添加头部指明Body格式，如图所示，手动输入Content-Type且值为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba3126bc5f.png" alt="10.png"><br>步骤4 单击Body，Body格式选择raw—&gt;JSON(application/json)。Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。  </p><p>Body内容如下所示，创建一个名为br0的网桥，并且与控制器通过OpenFlow13进行连接。单击Send按钮发送请求。</p><blockquote></blockquote><pre><code>{   &quot;row&quot;: {    &quot;Bridge&quot;: {      &quot;name&quot;: &quot;br0&quot;,        &quot;datapath_type&quot;: &quot;OpenFlow13&quot;        }    }}</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba36f496f1.png" alt="11.png"><br>步骤5 登录交换机，确认网桥创建成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba3d7290b1.png" alt="12.png"></p><h1 id="获取网桥uuid"><a href="#获取网桥uuid" class="headerlink" title="获取网桥uuid"></a>获取网桥uuid</h1><p>步骤1 URL保持不变，依旧是<a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows</a> ，将请求类型改为GET。输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba676a461c.png" alt="13.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并返回网桥信息，下图中两个uuid分别是br0和br-sw的。单击uuid所在行左侧的数字可以展开/收起网桥的详细信息，方便查看，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6a5aefc1.png" alt="14.png"></p><h1 id="创建端口"><a href="#创建端口" class="headerlink" title="创建端口"></a>创建端口</h1><p>步骤1 发送POST请求创建端口，输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows。</a><br>单击Basic Auth，输入用户名和密码生成HTTP认证头部，并且添加Content-Type为application/json，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba6e473f28.png" alt="15.png"><br>步骤2 将请求类型改为POST，输入Body内容如下所示，其中parent_uuid是网桥的uuid，这里所用的是br0的uuid，那么端口就会添加到br0网桥上。</p><blockquote></blockquote><pre><code>{   &quot;parent_uuid&quot;: &quot;2dd82e5e-922d-43c8-80d9-7917161acfd2&quot;,    &quot;row&quot;: {      &quot;Port&quot;: {        &quot;name&quot;: &quot;port0&quot;          }    }}</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba72ac6722.png" alt="16.png"><br>单击Send按钮发送请求，STATUS显示请求发送成功，端口已经创建，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba762e1b34.png" alt="17.png"><br>步骤3 登录交换机，确认交换机端口是否创建成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba79b19c6c.png" alt="18.png"></p><h1 id="获取端口uuid"><a href="#获取端口uuid" class="headerlink" title="获取端口uuid"></a>获取端口uuid</h1><p>步骤1 发送GET请求获取端口的uuid。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows</a> 。在Basic Auth页面输入用户名和密码生成HTTP认证头部，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7d5c4665.png" alt="19.png"><br>步骤2 单击Send按钮发送GET请求，STATUS显示请求发送成功，并且展示出获取到的端口信息。因为获取的是所有网桥的端口所以比较多，如下图所示，标注出来的是port0的uuid。获取到的信息完全展开比较多，可以直接在页面中搜索端口名称“port0”，然后往上翻找该端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba7feaebe3.png" alt="20.png"></p><h1 id="删除端口"><a href="#删除端口" class="headerlink" title="删除端口"></a>删除端口</h1><p>步骤1 发送DELETE请求删除端口。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/port/rows/2d47e410-fe0d-4f63-a1c4-8121152235f8。其中“2d47e410-fe0d-4f63-a1c4-8121152235f8</a> ”就是port0端口的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8431f4b2.png" alt="21.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8655ebe0.png" alt="22.png"><br>步骤3 登录交换机，确认port0端口删除成功。</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba89fe7601.png" alt="23.png"></p><h1 id="删除网桥"><a href="#删除网桥" class="headerlink" title="删除网桥"></a>删除网桥</h1><p>步骤1 发送DELETE请求删除网桥。输入URL <a href="http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”" target="_blank" rel="noopener">http://20.0.1.3:8282/ovsdb/nb/v2/node/OVS/20.0.1.4:59141/tables/bridge/rows/2dd82e5e-922d-43c8-80d9-7917161acfd2。其中“2dd82e5e-922d-43c8-80d9-7917161acfd2”</a> 就是br0网桥的uuid，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba8ddef7ab.png" alt="24.png"><br>步骤2 单击Send按钮发送DELETE请求，STATUS显示请求发送成功但是没有返回信息，如下图所示。<br><img src="https://i.loli.net/2018/09/14/5b9ba9024cca5.png" alt="25.png"><br>步骤3 登录交换机，确认网桥br0删除成功。执行以下命令：</p><blockquote></blockquote><pre><code>ovs-vsctl show</code></pre><p><img src="https://i.loli.net/2018/09/14/5b9ba934ab15e.png" alt="26.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h1&gt;&lt;p&gt;在虚拟交换机领域，Open vSwitch作为非官方的标准已获得产业界的高度关注。一般来讲，控制器及应用可以通过OpenFl
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>1.OpenFlow建立连接交互流程</title>
    <link href="https://cyneliu.github.io/2018/09/13/1-OpenFlow%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B/"/>
    <id>https://cyneliu.github.io/2018/09/13/1-OpenFlow建立连接交互流程/</id>
    <published>2018-09-13T05:30:58.000Z</published>
    <updated>2018-09-13T07:12:11.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenFlow协议简介"><a href="#OpenFlow协议简介" class="headerlink" title="OpenFlow协议简介"></a>OpenFlow协议简介</h1><p>2006年，斯坦福大学Clean Slate计划资助的Ethane项目开始部署，致力于企业网架构的创新，OpenFlow协议的雏形就诞生于这个项目。2008年，Nick McKeown教授的一篇重要论文“OpenFlow：Enabling Innovation in Campus Networks”使得OpenFlow正式进入人们的视野，继而成为了标准化组织ONF（Open Network Foundation，开放网络基金会）主推的南向接口协议。经过多年的发展，OpenFlow现已成为SDN的主流南向接口协议之一。目前，OpenFlow协议还在不断地演进中，本实验采用OpenFlow v1.3协议，并对控制器与OpenFlow交换机之间的交互过程进行深入分析。<br>OpenFlow主要有3种类型的消息，分别是Controller-to-Switch、Asynchronous和Symmetric，其中每个类型又包含多个子类型。Controller-to-Switch消息由控制器发起，用于管理、查看交换机的状态。Asynchronous消息由交换机发起，向控制器汇报交换机的事件和改变。Symmetric消息由控制器或交换机任一方发起，无需请求直接发起消息。详细信息如下表所示：<br><img src="https://i.loli.net/2018/09/13/5b99fc6a1c7b0.png" alt="1.png"></p><h1 id="OpenFlow连接建立交互流程"><a href="#OpenFlow连接建立交互流程" class="headerlink" title="OpenFlow连接建立交互流程"></a>OpenFlow连接建立交互流程</h1><p><img src="https://i.loli.net/2018/09/13/5b99fd98251f8.png" alt="2.png"><br>在OpenFlow1.3协议的情况下，控制器与OpenFlow交换机的消息完整交互流程如下：<br>1、 控制器与OpenFlow交换机通过TCP“三次握手”，建立有效的连接。其中，控制器一端的端口号为6633。<br>2、 控制器与OpenFlow交换机之间相互发送Hello消息，用于协商双方的OpenFlow版本号。在双方支持的最高版本号不一致的情况下，协商的结果将以较低的OpenFlow版本为准。如果双方协商不一致，还会产生Error消息。<br>3、 控制器向OpenFlow交换机发送Features Request消息，请求OpenFlow交换机上传自己的详细参数。OpenFlow交换机收到请求后，向控制器发送Features Reply消息，详细汇报自身参数，包括支持的buffer数目、流表数以及Actions等。<br>4、 控制器通过Set Config消息下发配置参数，然后通过Get config Request消息请求OpenFlow交换机上传修改后的配置信息。OpenFlow交换机通过Get config Reply消息向控制器发送当前的配置信息。<br>5、 控制器与OpenFlow交换机之间发送Packet_out、Packet_in消息，通过Packet_out中内置的LLDP包，进行网络拓扑的探测。<br>6、 控制器与OpenFlow交换机之间通过发送Multipart Request、Mutipart Reply消息，控制器能获取OpenFlow交换机的状态信息，包括流的信息、端口信息等。<br>7、 控制器与OpenFlow交换机之间通过发送Echo Request、Echo Reply消息，保证二者之间存在有效连接，避免失联。  </p><h1 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h1><p><img src="https://i.loli.net/2018/09/13/5b9a0b09e2b9b.png" alt="3.png"></p><h1 id="捕获数据包"><a href="#捕获数据包" class="headerlink" title="捕获数据包"></a>捕获数据包</h1><p>步骤1 登录Floodlight控制器，启动抓包工具Wireshark，捕获控制器与交换机建立连接过程中的数据包，通过分析这些数据包了解控制器与交换机基于OpenFlow协议进行交互的流程。执行以下命令：</p><blockquote></blockquote><pre><code>sudo wireshark</code></pre><p>步骤2 双击eth0网卡，查看eth0网卡上数据包收发情况，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ba6a9fb7.png" alt="4.png"><br>步骤3 登录Mininet虚拟机，启动Mininet。通过“—controller”参数设置Mininet连接远程控制器，并指定控制器的IP和端口号。</p><blockquote></blockquote><pre><code>sudo mn --controller=remote,ip=30.0.1.3,port=6633 --switch=ovsk,protocols=OpenFlow13</code></pre><p><img src="https://i.loli.net/2018/09/13/5b9a0bf62d0be.png" alt="5.png"><br>步骤4 登录Floodlight控制器，停止Wireshark，观察数据包列表，可以看出控制器与交换机的基本交互流程。<br><img src="https://i.loli.net/2018/09/13/5b9a0c1ddbc4e.png" alt="6.png"></p><h1 id="OpenFlow1-3交互流程分析"><a href="#OpenFlow1-3交互流程分析" class="headerlink" title="OpenFlow1.3交互流程分析"></a>OpenFlow1.3交互流程分析</h1><p>步骤1 交换机连接控制器的6633端口，经过3次握手后双方建立TCP连接。查看捕获到的数据包，分析交换机与控制器建立TCP连接的流程。分析TCP连接建立过程，需要先了解TCP的状态位，主要包括SYN、FIN、ACK、PSH、RST和URG。SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。可以看出交换机与控制器经历一次连接重置后，成功完成三次握手，建立TCP连接，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c63cdbf7.png" alt="7.png"><br>步骤2 当控制器与交换机建立TCP连接后，由其中某一方发起Hello消息，双方协调协OpenFlow议版本号。控制器和交换机都会向对方发送一条Hello消息，消息中附上自己支持的OpenFlow的最高版本。接收到对方Hello消息后，判断自己能否支持对方发送的版本，能支持则版本协商成功，不能支持则回复一条OFPT_ERROR消息。查看Hello消息详情，本实验中由于交换机和控制器都能支持OpenFlow1.3版本，所以版本协商为1.3，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0c8900db0.png" alt="8.png"><br>步骤3 OpenFlow版本协商完成后，控制器发送一条features_request消息获取交换机的特性信息，包括交换机的ID（DPID）、缓冲区数量、端口及端口属性等等。相应的，交换机回复features_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0cb6bf243.png" alt="9.png"><br>查看数据包详情，ofpt_feature_request消息只有包头，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0ce6d0540.png" alt="10.png"><br>ofpt_feature_reply数据包详情如下，交换机的DPID是数据通道独一无二的标识符，低48位是一个MAC地址，高16位是自定义的。本实验中交换机缓冲区数量（n_buffers）为256，交换机支持的流表数量（n_tables）为254，交换机所支持的功能，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d1008f0a.png" alt="11.png"><br>步骤4 OpenFlow1.0协议中feature_reply消息还包含交换机端口信息，OpenFlow 1.3协议将‘stats’框架更名为‘multipart’框架，并且将端口描述移植到multipart消息中。其中OPPT_PORT_DESC类型的multipart消息就是用于获取交换机端口信息的。<br><img src="https://i.loli.net/2018/09/13/5b9a0d34705f8.png" alt="12.png"><br>查看OPPT_PORT_DESC类型multipart_reply消息，消息中列出了交换机的端口以及每个端口的详细信息，包括端口名称和mac地址等，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d5f30b72.png" alt="13.png"><br>步骤5 OFPMP_DESC类型的multipart_reply消息包含了交换机的其他信息，包括交换机厂商名称、交换机名称以及交换机版本等。本实验中使用的是Mininet仿真软件中自带的开源交换机Open vSwitch(2.0.2)，而Open vSwitch是由Nicira Networks主导开发的，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0d8d31133.png" alt="14.png"><br>步骤6 在连接过程中，控制器不断的发送echo_request消息给交换机，确认交换机与控制器之间的连接状态。相应的，交换机会回复echo_reply消息，如下图所示。<br><img src="https://i.loli.net/2018/09/13/5b9a0db731025.png" alt="15.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenFlow协议简介&quot;&gt;&lt;a href=&quot;#OpenFlow协议简介&quot; class=&quot;headerlink&quot; title=&quot;OpenFlow协议简介&quot;&gt;&lt;/a&gt;OpenFlow协议简介&lt;/h1&gt;&lt;p&gt;2006年，斯坦福大学Clean Slate计划资助的Eth
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>SDN中的南向接口和北向接口</title>
    <link href="https://cyneliu.github.io/2018/09/11/SDN%E4%B8%AD%E7%9A%84%E5%8D%97%E5%90%91%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%8C%97%E5%90%91%E6%8E%A5%E5%8F%A3/"/>
    <id>https://cyneliu.github.io/2018/09/11/SDN中的南向接口和北向接口/</id>
    <published>2018-09-11T08:46:53.000Z</published>
    <updated>2018-09-11T08:58:49.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SDN的意义"><a href="#SDN的意义" class="headerlink" title="SDN的意义"></a>SDN的意义</h1><p>SDN网络的最终目标是服务于多样化的业务应用创新。因此随着SDN技术的部署和推广，将会有越来越多的业务应用被研发，这类应用将能够便捷地通过SDN北向接口调用底层网络能力，按需使用网络资源。  </p><p>SDN推动业务创新已经是业界不争的事实，它可以被广泛地应用在云数据中心、宽带传输网络、移动网络等种种场景中，其中为云计算业务提供网络资源服 务就是一个非常典型的案例。众所周知，在当前的云计算业务中，服务器虚拟化、存储虚拟化都已经被广泛应用，它们将底层的物理资源进行池化共享，进而按需分配给用户使用。相比之下，传统的网络资源远远没有达到类似的灵活性，而SDN的引入则能够很好地解决这一问题。</p><h1 id="南向接口"><a href="#南向接口" class="headerlink" title="南向接口"></a>南向接口</h1><p>SDN通过标准的南向接口屏蔽了底层物理转发设备的差异，实现了资源的虚拟化，同时开放了灵活的北向接口供上层业务按需进行网络配置并调用网络资源。  </p><p>云计算领域中知名的OpenStack就是可以工作在SDN应用层的云管理平台，通过在其网络资源管理组件中增加SDN管理插件，管理者和使用者可利 用SDN北向接口便捷地调用SDN控制器对外开放的网络能力。当有云主机组网需求(例如建立用户专有的VLAN)被发出时，相关的网络策略和配置可以在 OpenStack管理平台的界面上集中制定并进而驱动SDN控制器统一地自动下发到相关的网络设备上。  </p><p>当前，最知名的南向接口莫过于ONF倡导的OpenFlow协议。作为一个开放的协议，OpenFlow突破了传统网络设备厂商对设备能力接口的壁垒，经过多年的发展，在业界的共同努力下，当前已经日臻完善，能够全面解决SDN网络中面临的各种问题。  </p><p>因此，网络资源可以和其他类型的虚拟化资源一样，以抽象的资源能力的面貌统一呈现给业务应用开发者，开发者无需针对底层网络设备的差异耗费大量开销从事额外的适配工作，这有助于业务应用的快速创新。</p><h1 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h1><p>控制层是SDN的大脑，负责对底层转发设备的集中统一控制，同时向上层业务提供网络能力调用的接口，在SDN架构中具有举足轻重的作用，SDN控制 器也是SDN关注的焦点。从技术实现上看，控制器除了南向的网络控制和北向的业务支撑外，还需要关注东西的扩展，以避免SDN集中控制导致的性能和安全瓶颈问题，SDN控制器也在南向、北向、东西向上引入了相应的核心技术，有效解决与各层通信以及控制集群横向扩展的难题。  </p><p>当前，业界有很多基于OpenFlow控制协议的开源的控制器实现，例如NOX、Onix、Floodlight等，它们都有各自的特色设计，能够实现链路发现、拓扑管理、策略制定、表项下发等支持SDN网络运行的基本操作。虽然不同的控制器在功能和性能上仍旧存在差异，但是从中已经可以总结出SDN控制器应当具备的技术特征，从这些开源系统的研发与实践中得到的经验和教训将有助于推动SDN控制器的规范化发展。  </p><p>另外，用于网络集中化控制的控制器作为SDN网络的核心，其性能和安全性非常重要，其可能存在的负载过大、单点失效等问题一直是SDN领域中亟待解决的问题。当前，业界对此也有了很多探讨，从部署架构、技术措施等多个方面提出了很多有创见的方法。  </p><p>SDN控制器对网络的控制主要是通过南向接口协议实现,包括链路发现、拓扑管理、策略制定、表项下发等，其中链路发现和拓扑管理主要是控制其利用南 向接口的上行通道对底层交换设备上报信息进行统一监控和统计;而策略制定和表项下发则是控制器利用南向接口的下行通道对网络设备进行统一控制。</p><h1 id="北向接口"><a href="#北向接口" class="headerlink" title="北向接口"></a>北向接口</h1><p>SDN北向接口是通过控制器向上层业务应用开放的接口，其目标是使得业务应用能够便利地调用底层的网络资源和能力。通过北向接口，网络业务的开发者 能以软件编程的形式调用各种网络资源;同时上层的网络资源管理系统可以通过控制器的北向接口全局把控整个网网络的资源状态，并对资源进行统一调度。因为北 向接口是直接为业务应用服务的，因此其设计需要密切联系业务应用需求，具有多样化的特征。同时，北向接口的设计是否合理、便捷，以便能被业务应用广泛调用，会直接影响到SDN控制器厂商的市场前景。  </p><p>与南向接口方面已有OpenFlow等国际标准不同，北向接口方面还缺少业界公认的标准，因此，北向接口的协议制定成为当前SDN领域竞争的焦点， 不同的参与者或者从用户角度出发，或者从运营角度出发，或者从产品能力角度出发提出了很多方案。据悉,目前至少有20种控制器,每种控制器会对外提供北向 接口用于上层应用开发和资源编排。虽然北向接口标准当前还很难达成共识，但是充分的开放性、便捷性、灵活性将是衡量接口优劣的重要标准，例如REST API就是上层业务应用的开发者比较喜欢的接口形式。部分传统的网络设备厂商在其现有设备上提供了编程接口供业务应用直接调用，也可被视作是北向接口之一，其目的是在不改变其现有设备架构的条件下提升配置管理灵活性，应对开放协议的竞争。</p><h1 id="SDN交换机"><a href="#SDN交换机" class="headerlink" title="SDN交换机"></a>SDN交换机</h1><p>SDN的核心理念之一就是将控制功能从网络设备中剥离出来，通过中央控制器实现网络可编程，从而实现资源的优化利用，提升网络管控效率。  </p><p>工作在基础设施层的SDN交换机虽然不在需要对逻辑控制进行过多考虑，但作为SDN网络中负责具体数据转发处理的设备，为了完成高速数据转发，还是 要遵循交换机工作原理。本质上看，传统设备中无论是交换机还是路由器，其工作原理都是在收到数据包时，将数据包中的某些特征域与设备自身存储的一些表项进 行比对，当发现匹配时则按照表项的要求进行相应处理。SDN交换机也是类似的原理，但是与传统设备存在差异的是，设备中的各个表项并非是由设备自身根据周 边的网络环境在本地自行生成的，而是由远程控制器统一下发的，因此各种复杂的控制逻辑(例如链路发现、地址学习、路由计算等等)都无需在SDN交换机中实现。  </p><p>SDN交换机可以忽略控制逻辑的实现，全力关注基于表项的数据处理，而数据处理的性能也就成为评价SDN交换机优劣的最关键指标，因此，很多高性能 转发技术被提出，例如基于多张表以流水线方式进行高速处理的技术。另外，考虑到SDN和传统网络的混合工作问题，支持混合模式的SDN交换机也是当前设备 层技术研发的焦点。同时，随着虚拟化技术的出现和完善，虚拟化环境将是SDN交换机的一个重要应用场景，因此SDN交换机可能会有硬件、软件等多种形态。 例如，OVS(Open vSwitch，开放虚拟交换标准)交换机就是一款基于开源软件技术实现的能够集成在服务器虚拟化Hypervisor中的交换机，具备完善的交换机功能，在虚拟化组网中起到了非常重要的作用。  </p><p>SDN交换机的出现，对传统的网络设备厂商造成了最直接的威胁，如何将新兴的网络技术与传统设备产品的优势相融合，是这些厂商正在苦苦思索的问题。 虽然SDN交换机已经对传统的网络产业链造成了巨大的冲击，但是仅凭单独的数据转发设备还不足以支撑起整个SDN的天空，未来更激烈地竞争必将会在SDN的控制层和应用层发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SDN的意义&quot;&gt;&lt;a href=&quot;#SDN的意义&quot; class=&quot;headerlink&quot; title=&quot;SDN的意义&quot;&gt;&lt;/a&gt;SDN的意义&lt;/h1&gt;&lt;p&gt;SDN网络的最终目标是服务于多样化的业务应用创新。因此随着SDN技术的部署和推广，将会有越来越多的业务应用被
      
    
    </summary>
    
      <category term="SDN,网络" scheme="https://cyneliu.github.io/categories/SDN-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网络" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda开始菜单失踪</title>
    <link href="https://cyneliu.github.io/2018/09/10/Anaconda%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E5%A4%B1%E8%B8%AA/"/>
    <id>https://cyneliu.github.io/2018/09/10/Anaconda开始菜单失踪/</id>
    <published>2018-09-10T13:23:33.000Z</published>
    <updated>2018-09-10T13:30:02.556Z</updated>
    
    <content type="html"><![CDATA[<p>今天想打开Anaconda写python程序的时候，突然发现Anaconda在开始菜单中神秘失踪了。<br>这时候只需要打开cmd，切换到Anaconda的安装目录的Lib文件夹下，执行如下命令：</p><blockquote></blockquote><pre><code>python _nsis.py mkmenus</code></pre><p>重新生成一下开始菜单即可。<br><img src="https://i.loli.net/2018/09/10/5b9670b820c45.png" alt="snipaste_20180909_124542.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天想打开Anaconda写python程序的时候，突然发现Anaconda在开始菜单中神秘失踪了。&lt;br&gt;这时候只需要打开cmd，切换到Anaconda的安装目录的Lib文件夹下，执行如下命令：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;c
      
    
    </summary>
    
      <category term="疑难杂症" scheme="https://cyneliu.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="Anaconda" scheme="https://cyneliu.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化运维笔记——服务器</title>
    <link href="https://cyneliu.github.io/2018/07/11/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://cyneliu.github.io/2018/07/11/虚拟化运维笔记——服务器/</id>
    <published>2018-07-11T12:28:09.000Z</published>
    <updated>2018-07-11T13:09:51.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器通电自启"><a href="#服务器通电自启" class="headerlink" title="服务器通电自启"></a>服务器通电自启</h1><p>实验室有三台浪潮的服务器，默认关闭了通电自启的功能，因为不使用，也一直没去在意它，今天没事给它把通电自启动打开了，省的以后麻烦，在此记录一下，下图内容拍自浪潮服务器：<br>1、开机时按Delete键进入BIOS<br><img src="https://i.loli.net/2018/07/11/5b45ff414107c.jpg" alt="001.jpg"><br>2、选择Chipset-PCH<br><img src="https://i.loli.net/2018/07/11/5b45ff4151548.jpg" alt="002.jpg"><br>3、将Restore AC Power Loss修改为Power Off<br><img src="https://i.loli.net/2018/07/11/5b45ff414cd73.jpg" alt="003.jpg"><br>这里解释一下各个选项的意思：</p><blockquote><p><em>Restore AC Power Loss</em>:如果发生断电，恢复供电后系统如何反应<br><em>Power Off</em>:接通电源后保持关机状态<br><em>Power On</em>:接通电源后开机<br><em>Last State</em>:恢复到断电前的状态</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务器通电自启&quot;&gt;&lt;a href=&quot;#服务器通电自启&quot; class=&quot;headerlink&quot; title=&quot;服务器通电自启&quot;&gt;&lt;/a&gt;服务器通电自启&lt;/h1&gt;&lt;p&gt;实验室有三台浪潮的服务器，默认关闭了通电自启的功能，因为不使用，也一直没去在意它，今天没事给它把通电
      
    
    </summary>
    
      <category term="运维，笔记" scheme="https://cyneliu.github.io/categories/%E8%BF%90%E7%BB%B4%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="运维" scheme="https://cyneliu.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化运维笔记——vsphere</title>
    <link href="https://cyneliu.github.io/2018/07/11/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94vsphere/"/>
    <id>https://cyneliu.github.io/2018/07/11/虚拟化运维笔记——vsphere/</id>
    <published>2018-07-11T10:58:49.000Z</published>
    <updated>2018-07-11T11:25:03.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置虚拟机随主机自动启动"><a href="#设置虚拟机随主机自动启动" class="headerlink" title="设置虚拟机随主机自动启动"></a>设置虚拟机随主机自动启动</h1><h2 id="0、选择虚拟机所在主机"><a href="#0、选择虚拟机所在主机" class="headerlink" title="0、选择虚拟机所在主机"></a>0、选择虚拟机所在主机</h2><p>单击选择虚拟机所在的主机，在后侧选项卡中选择“配置”<br><img src="https://i.loli.net/2018/07/11/5b45e78a91f56.png" alt="snipaste_20180711_190241.png"></p><h2 id="1、设置属性"><a href="#1、设置属性" class="headerlink" title="1、设置属性"></a>1、设置属性</h2><p>单击右上角的属性<br><img src="https://i.loli.net/2018/07/11/5b45e78a8af69.png" alt="snipaste_20180711_184912.png"></p><h2 id="2、设置虚拟机自动启动"><a href="#2、设置虚拟机自动启动" class="headerlink" title="2、设置虚拟机自动启动"></a>2、设置虚拟机自动启动</h2><p>勾选“允许虚拟机与系统一起自动启动和停止”，然后在“启动顺序”中将需要设置自动启动的虚拟机上移到自动启动一栏下，如果有需要，可根据情况设置启动延迟，最后点击确定即可。<br><img src="https://i.loli.net/2018/07/11/5b45e78a90520.png" alt="snipaste_20180711_185154.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设置虚拟机随主机自动启动&quot;&gt;&lt;a href=&quot;#设置虚拟机随主机自动启动&quot; class=&quot;headerlink&quot; title=&quot;设置虚拟机随主机自动启动&quot;&gt;&lt;/a&gt;设置虚拟机随主机自动启动&lt;/h1&gt;&lt;h2 id=&quot;0、选择虚拟机所在主机&quot;&gt;&lt;a href=&quot;#0、
      
    
    </summary>
    
      <category term="运维，笔记" scheme="https://cyneliu.github.io/categories/%E8%BF%90%E7%BB%B4%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="运维" scheme="https://cyneliu.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>WinSCP——基于SSH的安全文件传输软件</title>
    <link href="https://cyneliu.github.io/2018/07/03/WinSCP%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ESSH%E7%9A%84%E5%AE%89%E5%85%A8%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E8%BD%AF%E4%BB%B6/"/>
    <id>https://cyneliu.github.io/2018/07/03/WinSCP——基于SSH的安全文件传输软件/</id>
    <published>2018-07-03T02:10:14.000Z</published>
    <updated>2018-07-03T02:34:47.347Z</updated>
    
    <content type="html"><![CDATA[<p>我的一个影视网站因为之前买的虚拟主机到期了，就想着把它放到我那台ssr主机上，结果配置vstp的时候不知道什么原因，配置完用客户端登录的时候总是提示说密码验证失败。然后看到一个博主推荐，就是WinSCP了，它的好处在于他是基于SSH协议的sftp文件传输，也就是说，只要你的linux主机可以使用ssh，就可以用它进行文件传输。  </p><h1 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h1><p>sftp(Secure File Transfer Protocol)，安全文件传送协议，可以为传输文件提供一种安全的网络的加密方法。sftp与ftp有着几乎一样的语法和功能。SFTP是SSH的一部分，其实在SSH软件包中，已经包含了一个叫作SFTP的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。<br>SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，所以在对网络安全性要求更高时，可以使用SFTP代替FTP。</p><h1 id="sftp于ftp的区别"><a href="#sftp于ftp的区别" class="headerlink" title="sftp于ftp的区别"></a>sftp于ftp的区别</h1><p>FTP是一种文件传输协议，一般是为了方便数据共享的，包括一个FTP服务器和多个FTP客户端，FTP客户端通过FTP协议在服务器上下载资源。而SFTP协议是基于SSH，并在FTP的基础上对数据进行加密，使得传输的数据相对来说更安全。但是这种安全是以牺牲效率为代价的，也就是说SFTP的传输效率比FTP要略低。<br>而且在我的使用过程中，并没有感觉sftp的效率较于ftp有太大的差异，而且使用sftp最大的一个好处就是不需要安装而且安全性更高。<br>更详细的区别可以移步这里：<a href="https://www.cnblogs.com/mfryf/archive/2013/05/29/3107286.html" target="_blank" rel="noopener">Sftp和ftp 区别、工作原理等（汇总ing）</a></p><h1 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h1><p>官网地址：<a href="https://winscp.net/eng/docs/lang:chs" target="_blank" rel="noopener">https://winscp.net/eng/docs/lang:chs</a><br>除了WinSCP，Windows环境下还可以使用Core FTP，FileZilla, WinSCP，Xftp来连接SFTP进行上传，下载文件，建立，删除目录等操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的一个影视网站因为之前买的虚拟主机到期了，就想着把它放到我那台ssr主机上，结果配置vstp的时候不知道什么原因，配置完用客户端登录的时候总是提示说密码验证失败。然后看到一个博主推荐，就是WinSCP了，它的好处在于他是基于SSH协议的sftp文件传输，也就是说，只要你的
      
    
    </summary>
    
      <category term="Server" scheme="https://cyneliu.github.io/categories/Server/"/>
    
    
      <category term="文件传输" scheme="https://cyneliu.github.io/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    
      <category term="Server" scheme="https://cyneliu.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化运维笔记 —— Linux</title>
    <link href="https://cyneliu.github.io/2018/06/25/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux/"/>
    <id>https://cyneliu.github.io/2018/06/25/虚拟化运维笔记——Linux/</id>
    <published>2018-06-25T13:50:33.000Z</published>
    <updated>2018-08-09T05:39:30.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux下使用Rinetd来实现端口转发"><a href="#Linux下使用Rinetd来实现端口转发" class="headerlink" title="Linux下使用Rinetd来实现端口转发"></a>Linux下使用Rinetd来实现端口转发</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>centos</strong><br>0、对于centos，由于官方的源中并没有Rinetd，所以首先需要第三方源<br>32位系统：</p><blockquote></blockquote><pre><code>$ vim /etc/yum.repos.d/nux-misc.repo[nux-misc]name=Nux Miscbaseurl=http://li.nux.ro/download/nux/misc/el6/i386/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</code></pre><p>64位系统：</p><blockquote></blockquote><pre><code>$ vim  /etc/yum.repos.d/nux-misc.repo:[nux-misc]name=Nux Miscbaseurl=http://li.nux.ro/download/nux/misc/el6/x86_64/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</code></pre><p>1、安装Rinetd</p><blockquote></blockquote><pre><code>$ yum --enablerepo=nux-misc install rinetd</code></pre><p><strong>Ubuntu</strong></p><blockquote></blockquote><pre><code>apt-get install rinetd</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>端口转发的配置文件在<em>/etc/rinetd.conf</em><br>配置文件的格式：</p><blockquote></blockquote><pre><code>[bindaddress] [bindport] [connectaddress] [connectport]绑定的地址    绑定的端口  连接的地址      连接的端口[Source Address] [Source Port] [Destination Address] [Destination Port]源地址            源端口         目的地址               目的端口</code></pre><p>例如：</p><blockquote></blockquote><pre><code>0.0.0.0 8080 172.19.94.3 80800.0.0.0 2222 192.168.0.103 33891.2.3.4 80 192.168.0.10 80allow *.*.*.*logfile /var/log/rinetd.log</code></pre><p>说明  </p><blockquote><p>0.0.0.0表示本机绑定所有可用地址<br>将所有发往本机8080端口的请求转发到172.19.94.3的8080端口<br>将所有发往本机2222端口的请求转发到192.168.0.103的3389端口<br>将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口<br>allow设置允许访问的ip地址信息,<em>.</em>.<em>.</em>表示所有IP地址<br>logfil设置打印的log的位置  </p></blockquote><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><blockquote></blockquote><pre><code>pkill rinetd  ##关闭进程rinetd -c /etc/rinetd.conf  ##启动转发</code></pre><p>把命令加到/etc/rc.local里面就可以开机自动运行</p><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="默认编辑器nano"><a href="#默认编辑器nano" class="headerlink" title="默认编辑器nano"></a>默认编辑器nano</h2><p>用习惯了vim编辑器，有时候想修改配置文件，可设备又没网，Ubuntu默认使用的是nano编辑器，真心不如vim好用。</p><blockquote></blockquote><pre><code>ctrl+X  #退出ctrl+O  #保存</code></pre><h2 id="Ubuntu设置静态ip"><a href="#Ubuntu设置静态ip" class="headerlink" title="Ubuntu设置静态ip"></a>Ubuntu设置静态ip</h2><p>通过修改“/etc/network/interfaces”进行修改，<br><img src="https://i.loli.net/2018/06/25/5b30f4ef9991f.png" alt="QQ图片20180625214835.png"><br>注：在设置多个DNS服务器的时候要加“s”,如：</p><blockquote></blockquote><pre><code>dns-nameservers 114.114.114.114 8.8.8.8</code></pre><p>修改之后需要执行：  </p><blockquote></blockquote><pre><code>sudo /etc/init.d/networking restart</code></pre><p>使用这个方式修改ip地址，修改完interfaces文档中的内容后，需要修改/etc/NetworkManager/NetworkManager.conf文档中的managed参数，使之为true，并重启。否则，会提示说“有线网络设备未托管”。<br>重启网络或系统之后就修改完成了。  </p><h2 id="安装TeamViewer"><a href="#安装TeamViewer" class="headerlink" title="安装TeamViewer"></a>安装TeamViewer</h2><p>teamviewer远程登录的方式不建议使用！<br>1、到TeamViewer官网下载对应版本的安装包。<br>2、下载完成之后切换到下载目录，执行：</p><blockquote></blockquote><pre><code>sudo dpkg -i teamviewer_13.0.9865_amd64.deb</code></pre><p>版本号要根据下载的包进行更改。<br>这时候可能会报出如下错误：</p><blockquote></blockquote><pre><code>正在选中未选择的软件包 teamviewer。 (正在读取数据库 … 系统当前共安装有 253291 个文件和目录。) 正准备解包 teamviewer_13.0.6634_amd64.deb … 正在解包 teamviewer (13.0.6634) … dpkg：警告：无法删除原有的目录 /var/log/teamviewer12 ：目录非空 dpkg: 依赖关系问题使得 teamviewer 的配置工作不能继续： teamviewer 依赖于 qtdeclarative5-dialogs-plugin (&gt;= 5.2) | qml-module-qtquick-dialogs (&gt;= 5.2)；然而： 未安装软件包 qtdeclarative5-dialogs-plugin。 未安装软件包 qml-module-qtquick-dialogs。 dpkg: 处理软件包 teamviewer (–install)时出错： 依赖关系问题 - 仍未被配置 正在处理用于 desktop-file-utils (0.22-1ubuntu5.1) 的触发器 … 正在处理用于 gnome-menus (3.13.3-6ubuntu3.1) 的触发器 … 正在处理用于 bamfdaemon (0.5.3~bzr0+16.04.20160824-0ubuntu1) 的触发器 … Rebuilding /usr/share/applications/bamf-2.index… 正在处理用于 mime-support (3.59ubuntu1) 的触发器 … 正在处理用于 hicolor-icon-theme (0.15-0ubuntu1) 的触发器 … 在处理时有错误发生： teamviewer</code></pre><p>目前我遇到的有两种解决方式：<br>一、修复依赖关系</p><blockquote><p>一种解决方法是执行如下命令修复依赖关系：   </p></blockquote><pre><code>sudo apt install f</code></pre><p>执行完后再安装看看能否成功，如果还是不成功就要采用第二种方式了。<br>二、更新源地址</p><blockquote><p>①删除安装到一半的teamviewer：</p></blockquote><pre><code>sudo apt-get remove teamviewer</code></pre><p>②在Ubuntu的<a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">源列表</a>中找到对应系统的源，复制到/etc/apt/sources.list 里面，并把原来的链接注释掉。<br>③更新系统软件：</p><blockquote></blockquote><pre><code>sudo apt-get update #更新软件列表sudo apt-get upgrade #更新软件</code></pre><p>④运行安装命令：</p><blockquote></blockquote><pre><code>sudo dpkg -i teamviewer_13.0.9865_amd64.deb</code></pre><p>3、在TeamViewer的使用中发现经常在系统重启后连接就出现“未知原因”的问题，原因还在摸索中，目前能解决的方法就是卸载重新安装：</p><blockquote></blockquote><pre><code>apt purge teamviewersudo dpkg -i teamviewer_13.0.9865_amd64.deb</code></pre><h2 id="16-04出现“The-system-is-running-in-low-graphics-mode”"><a href="#16-04出现“The-system-is-running-in-low-graphics-mode”" class="headerlink" title="16.04出现“The system is running in low-graphics mode”"></a>16.04出现“The system is running in low-graphics mode”</h2><p>在虚拟机中安装的Ubuntu16.04无法显示完全，尝试修改分辨率后会卡死，然后重启就会出现如题所示的错误。<br>解决方法为：<br>1、重启虚拟机，按ctrl + alt + F1 进入纯字符界面，输入账号和密码<br>2、执行如下命令：</p><blockquote></blockquote><pre><code>cd /etc/X11sudo cp xorg.conf.failsafe xorg.conf #刷新配置文件sudo reboot</code></pre><p>重启之后就可以正常显示了。</p><h2 id="启用root用户"><a href="#启用root用户" class="headerlink" title="启用root用户"></a>启用root用户</h2><p>执行：</p><blockquote></blockquote><pre><code>sudo passwd root</code></pre><p>设置密码后即可使用su直接切换为root用户。<br><img src="https://img-blog.csdn.net/20160722112307840" alt=""></p><h2 id="安装GNOME-Shell桌面"><a href="#安装GNOME-Shell桌面" class="headerlink" title="安装GNOME Shell桌面"></a>安装GNOME Shell桌面</h2><p>1、安装GNOME Shell</p><blockquote></blockquote><pre><code>sudo apt-get install gnome-shell</code></pre><p>安装过程中出现如下界面，选择lightdm：<br><img src="https://4bds6hergc-flywheel.netdna-ssl.com/wp-content/uploads/2014/06/Switch_between_gdm_and_lightgdm_Ubuntu.jpeg" alt=""><br>2、退出当前账户，选择GNOME桌面系统<br>3、重新登陆，安装gnome-tweak</p><blockquote></blockquote><pre><code>sudo apt-get install gnome-tweak-tool</code></pre><p>tweak是主题管理工具，具体使用方法参见：<br><a href="https://itsfoss.com/install-switch-themes-gnome-shell/" target="_blank" rel="noopener">https://itsfoss.com/install-switch-themes-gnome-shell/ </a><br>4、使用tweak更换主题<br>方法参考：<br><a href="https://itsfoss.com/gnome-shell-themes-ubuntu-1404/" target="_blank" rel="noopener">https://itsfoss.com/gnome-shell-themes-ubuntu-1404/</a>  </p><h2 id="执行sudo-apt-get-update出错"><a href="#执行sudo-apt-get-update出错" class="headerlink" title="执行sudo apt-get update出错"></a>执行sudo apt-get update出错</h2><p>在运行sudo apt-get update时出现如下信息：</p><blockquote></blockquote><pre><code>Reading package lists... DoneE: Problem executing scripts APT::Update::Post-Invoke-Success&apos;if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli;then appstreamcli refresh &gt; /dev/null;fi&apos;E: Sub-process returned an error code</code></pre><p>解决方法如下：</p><blockquote></blockquote><pre><code>sudo pkill -KILL appstreamcliwget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.debsudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb</code></pre><p>或者：</p><blockquote></blockquote><pre><code>apt show appstreamsudo apt remove appstream</code></pre><h2 id="Ubuntu在虚拟机中显示不全的问题"><a href="#Ubuntu在虚拟机中显示不全的问题" class="headerlink" title="Ubuntu在虚拟机中显示不全的问题"></a>Ubuntu在虚拟机中显示不全的问题</h2><p>关于这个问题之前也是尝试了无数的方法，今天无意间明白了原因并解决了问题。<br>1、首先要明白的是不是随便一个分辨率都可以更改，首先执行以下命令查询当前的显示状态：</p><blockquote></blockquote><pre><code>xrandr</code></pre><p><img src="https://img-blog.csdn.net/20150602205903147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhczEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其中第一个带*的就是当前的分辨率，其下的数值是我们可以更改的分辨率，每个虚拟机可能略有不同。<br>2、执行：</p><blockquote></blockquote><pre><code>xrandr -s 1440x900_59.9</code></pre><p>即可将分辨率设置为1440x900。<br>3、上述命令只能临时修改，永久修改需要执行：</p><blockquote></blockquote><pre><code>xrandr --output Virtual1 --mode 1440x900</code></pre><p>其中“Virtual1”是显示器的名称，要根据执行xrandr返回的信息进行相应的替换。<br>4、错误<br>这些也是我自己遇到的一点问题。</p><blockquote><p>①有时候执行步骤3中所说的命令并不能永久更改，重启后会失效。目前一个方法就是在系统设置→显示中应用一下更改过来的分辨率，这样在重启之后就不会出现问题了。<br>②“xrandr: Configure crtc 0 failed”  </p><blockquote><p>这是一个系统bug，在设置,关于这台计算机,检查更新。更新完重启后就没问题了。</p></blockquote></blockquote><h2 id="Ubuntu16-04安装VNC"><a href="#Ubuntu16-04安装VNC" class="headerlink" title="Ubuntu16.04安装VNC"></a>Ubuntu16.04安装VNC</h2><p>“VNC有很多选择，VNC4server，tigervncserver等等，都不推荐，难装又难用。经过多次实验和测试，最后只采用x11vnc作为VNC服务器端。” <a href="https://blog.csdn.net/longhr/article/details/51657610" target="_blank" rel="noopener">查看原文</a><br>1、安装X11VNC</p><blockquote></blockquote><pre><code>sudo apt install x11vnc -y</code></pre><p>2、配置访问密码</p><blockquote></blockquote><pre><code>sudo x11vnc -storepasswd /etc/x11vnc.pass </code></pre><p>3、创建服务</p><blockquote></blockquote><pre><code>vi  /lib/systemd/system/x11vnc.service</code></pre><blockquote><p>粘贴如下代码：</p></blockquote><pre><code>[Unit]Description=Start x11vnc at startup.After=multi-user.target[Service]Type=simpleExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared[Install]WantedBy=multi-user.target</code></pre><p>4、配置防火墙，配置并启动服务</p><blockquote></blockquote><pre><code>sudo ufw allow 5900sudo systemctl enable x11vnc.servicesudo systemctl daemon-reload</code></pre><p>如果出现如下图所示的错误，就说明第三步中你的配置信息粘贴错误了，修改正确即可解决。<img src="https://i.loli.net/2018/06/30/5b37243cc1a2e.jpg" alt="QQ图片20180630142539.jpg"><br>5、重启系统</p><blockquote></blockquote><pre><code>reboot</code></pre><h2 id="nat123配置"><a href="#nat123配置" class="headerlink" title="nat123配置"></a>nat123配置</h2><p>nat123端口映射是专业的内网端口映射软件，在内网启动映射后，可在外网轻松访问连接内网网站等应用，不需要设置路由器，不需要公网ip,不需要固定ip,不需要动态域名。  </p><p>Ubuntu配置过程：（其它linux直接参考<a href="http://www.nat123.com/pages_17_600.jsp" target="_blank" rel="noopener">官网说明</a>）<br>0、注册账号<br>没有注册过账号的先到官网注册：<a href="http://www.nat123.com/" target="_blank" rel="noopener">http://www.nat123.com/</a><br>1、安装mono运行环境</p><blockquote></blockquote><pre><code>apt-get  install  mono-complete</code></pre><p>安装完成后执行“mono -V”可查看安装的版本信息。<br>2、客户端安装</p><blockquote></blockquote><pre><code>cd  /optmkdir  nat123cd  /nat123wget  http://www.nat123.com/down/nat123linux.tar.gztar  -zxvf  nat123linux.tar.gz</code></pre><p>3、启动客户端</p><blockquote></blockquote><pre><code>cd  /opt/nat123mono  nat123linux.sh</code></pre><p>输入用户名和密码登录成功后，直接结束当前进程，然后执行如下命令改为后台运行：</p><blockquote></blockquote><pre><code>cd  /opt/nat123mono  nat123linux.sh service &amp;ps  -ef|grep  nat123 #查看nat123状态</code></pre><p>4、登录网页添加端口映射或动态域名解析</p><h1 id="RHEL"><a href="#RHEL" class="headerlink" title="RHEL"></a>RHEL</h1><h2 id="系统意外重启后VNC连接失败"><a href="#系统意外重启后VNC连接失败" class="headerlink" title="系统意外重启后VNC连接失败"></a>系统意外重启后VNC连接失败</h2><p>在服务器中运行着几个RHEL实例，VNC是之前老师配置的，这几个实例在服务器断电重启之后会出现VNC连接出错的问题。解决方法如下：</p><blockquote></blockquote><pre><code>cd /tmprm -rvf .X11-unix #手动删除因为VNC非正常退出未删除的文件vncserver :3 #重启服务</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h1&gt;&lt;h2 id=&quot;Linux下使用Rinetd来实现端口转发&quot;&gt;&lt;a href=&quot;#Linux下使用Rinetd来实现端口转
      
    
    </summary>
    
      <category term="运维，笔记" scheme="https://cyneliu.github.io/categories/%E8%BF%90%E7%BB%B4%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="运维" scheme="https://cyneliu.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>SDN入门（一）—— 环境搭建</title>
    <link href="https://cyneliu.github.io/2018/06/24/SDN%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://cyneliu.github.io/2018/06/24/SDN入门（一）——-环境搭建/</id>
    <published>2018-06-24T01:20:49.000Z</published>
    <updated>2018-06-30T06:25:22.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h1><h2 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a>系统选择</h2><p>镜像建议使用16.04的版本，mininet官网有说明，是因为16.04支持新版本的openflow等协议，我这里使用的是“ubuntu-16.04-server-amd64.iso”，server版本更加稳定。</p><h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><h3 id="设置网卡"><a href="#设置网卡" class="headerlink" title="设置网卡"></a>设置网卡</h3><p>因为要使用ssh远程登录，这里我们添加一个网卡：<br><img src="https://i.loli.net/2018/06/24/5b2ef5cbec5f1.png" alt="01.png"><br>勾选“启用网络连接”，并选择仅主机模式。</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>挂载镜像之后启动虚拟机进行安装，基本的安装过程不一一详细介绍，不会的地方可以百度。<br><img src="https://i.loli.net/2018/06/24/5b2ef77a37059.png" alt="02.png"><br>可以看到安装程序已经识别出了两块网卡，我们选择默认的nat网卡作为主网络接口。<br><img src="https://i.loli.net/2018/06/24/5b2ef9a7a101d.png" alt="03.png"><br>软件安装，我们只需要安装ssh server就可以了，记得空格选择，回车确认。  </p><p>安装完成后，我们看一下系统的网卡信息，发现并没有我们添加的网卡。<br><img src="https://i.loli.net/2018/06/24/5b2efcabda76f.png" alt="04.png"><br>执行“sudo dhclient enp0s8”启用enp0s8网卡。<br>再次查看网卡信息：<br><img src="https://i.loli.net/2018/06/24/5b2efed26c4cc.png" alt="05.png"><br>可以看到已经添加进来了。我们还需要将第二块网卡的配置加入到网络配置文件中，不然重启之后第二块网卡还是看不到的：  </p><blockquote></blockquote><pre><code>sudo vi /etc/network/interfaces</code></pre><p>在interfaces配置文件中加入enp0s8，同样使用dhcp方式获取ip<br><img src="https://i.loli.net/2018/06/24/5b2efffbe249f.png" alt="06.png"><br>至此，我们的系统就配置完成了，用ssh工具进行连接：<br><img src="https://i.loli.net/2018/06/24/5b2f00ad250a3.png" alt="07.png"><br>已经可以成功连接。</p><h1 id="安装Ryu"><a href="#安装Ryu" class="headerlink" title="安装Ryu"></a>安装Ryu</h1><p>详细内容可参考<a href="http://linton.tw/2014/02/15/note-install-ryu-36-sdn-framework/" target="_blank" rel="noopener">linton的博客</a>。</p><p>1.下载python的套件库，并更新pip（因为下载的pip并不是最新版本）</p><blockquote></blockquote><pre><code>sudo apt-get install python-pip python-dev build-essentialsudo pip install --upgrade pip</code></pre><p>2.安装Ryu相依性套件</p><blockquote></blockquote><pre><code>sudo apt-get install python-eventletsudo apt-get install python-routessudo apt-get install python-webobsudo apt-get install python-paramiko</code></pre><p>3.使用pip下载并安装Ryu</p><blockquote></blockquote><pre><code>sudo pip install ryu</code></pre><p>此步骤如果出现如下错误信息说明你被挡在城内了，富强上网即可解决。<br><img src="https://i.loli.net/2018/06/24/5b2f22b8832fc.png" alt="需要富强上网.png"><br>4.如果需要使用Ryu with GUI则进行此步骤：下载Ryu source code（需要使用git套件）</p><blockquote></blockquote><pre><code>sudo apt-get install gitgit clone https://github.com/osrg/ryu.git</code></pre><p>5.完成安装，执行ryu-manager验证有没有出现错误，没问题的话会出现如下信息：<br><img src="https://i.loli.net/2018/06/24/5b2f1ff8a73bd.png" alt="chenggong.png"></p><h1 id="安装mininet"><a href="#安装mininet" class="headerlink" title="安装mininet"></a>安装mininet</h1><h2 id="使用源码安装mininet"><a href="#使用源码安装mininet" class="headerlink" title="使用源码安装mininet"></a>使用源码安装mininet</h2><p>为了减少之后不必要的麻烦，建议在安装开始前执行：sudo su切换到root用户下并在富强网络下进行安装。<br>1.升级系统</p><blockquote></blockquote><pre><code>apt-get updateapt-get upgrade</code></pre><p>2.安装git（如果你像我一样在之前安装Ryu时我们已经安装过git了，那么请直接跳过此步骤）</p><blockquote></blockquote><pre><code>apt install git</code></pre><p>3.从github上获取源码</p><blockquote></blockquote><pre><code>git clone git://github.com/mininet/mininet</code></pre><p>获取之后可以使用如下命令查看mininet的版本</p><blockquote></blockquote><pre><code>cd mininetcat INSTALL</code></pre><p><img src="https://i.loli.net/2018/06/24/5b2f4c772e56f.png" alt="cat.png"><br>4.确认无误后，安装mininet</p><blockquote></blockquote><pre><code>util/install.sh -a</code></pre><p>当你看到Enjoy Mininet！时，恭喜你已经安装成功了。<br><img src="https://i.loli.net/2018/06/24/5b2f4cb8a6bfc.png" alt="enjoy.png"><br>执行以下命令查看安装版本：</p><blockquote></blockquote><pre><code>mn --version</code></pre><h2 id="mininet可视化操作"><a href="#mininet可视化操作" class="headerlink" title="mininet可视化操作"></a>mininet可视化操作</h2><p>1.要进行mininet可视化操作，需要安装Xmanager套件，然后在通过Xshell远程连接主机时，在属性中做如下设置：<br><img src="https://i.loli.net/2018/06/24/5b2f4a82c2097.png" alt="suidao.png"><br>2.然后进入examples目录，执行miniedit.py即可启动可视化界面</p><blockquote></blockquote><pre><code>cd mininet/mininet/examples./miniedit.py</code></pre><p><img src="https://i.loli.net/2018/06/24/5b2f4cf66b46e.png" alt="可视化.png"><br>至此，整个环境就搭建完成了。<br>如果是桌面版系统并且用apt-get install mininet安装的mininet,目录在/usr / share /doc/mininet/examples,但是其可视化脚本是py.gz格式的，貌似无法使用。</p><p>如果对环境的安装有疑问，欢迎与我联系，一起沟通交流。  </p><blockquote><p>email: <a href="mailto:666@cyne.cf" target="_blank" rel="noopener">666@cyne.cf</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu安装&quot;&gt;&lt;a href=&quot;#Ubuntu安装&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装&quot;&gt;&lt;/a&gt;Ubuntu安装&lt;/h1&gt;&lt;h2 id=&quot;系统选择&quot;&gt;&lt;a href=&quot;#系统选择&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://cyneliu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SDN" scheme="https://cyneliu.github.io/tags/SDN/"/>
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack入门（三）—— OpenStack架构</title>
    <link href="https://cyneliu.github.io/2018/06/19/OpenStack%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-OpenStack%E6%9E%B6%E6%9E%84/"/>
    <id>https://cyneliu.github.io/2018/06/19/OpenStack入门（三）——-OpenStack架构/</id>
    <published>2018-06-19T11:51:37.000Z</published>
    <updated>2018-06-21T12:43:45.534Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396287488044421.jpg" alt=""></p><h1 id="OpenStack架构"><a href="#OpenStack架构" class="headerlink" title="OpenStack架构"></a>OpenStack架构</h1><p>OpenStack的Conceptual Architecture(概念体系结构)：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396288164018195.jpg" alt=""></p><blockquote><p>中间菱形是虚拟机，围绕 VM 的那些长方形代表 OpenStack 不同的模块（OpenStack 叫服务，后面都用服务这个术语），下面来分别介绍。</p></blockquote><blockquote><p>Nova：管理 VM 的生命周期，是 OpenStack 中最核心的服务。</p></blockquote><blockquote><p>Neutron：为 OpenStack 提供网络连接服务，负责创建和管理L2、L3 网络，为 VM 提供虚拟网络和物理网络连接。</p></blockquote><blockquote><p>Glance：管理 VM 的启动镜像，Nova 创建 VM 时将使用 Glance 提供的镜像。</p></blockquote><blockquote><p>Cinder：为 VM 提供块存储服务。Cinder 提供的每一个 Volume 在 VM 看来就是一块虚拟硬盘，一般用作数据盘。</p></blockquote><blockquote><p>Swift：提供对象存储服务。VM 可以通过 RESTful API 存放对象数据。作为可选的方案，Glance 可以将镜像存放在 Swift 中；Cinder 也可以将 Volume 备份到 Swift 中。</p></blockquote><blockquote><p>Keystone：为 OpenStack 的各种服务提供认证和权限管理服务。简单的说，OpenStack 上的每一个操作都必须通过 Keystone 的审核。</p></blockquote><blockquote><p>Ceilometer：提供 OpenStac k监控和计量服务，为报警、统计或计费提供数据。</p></blockquote><blockquote><p>Horizon：为 OpenStack 用户提供一个 Web 的自服务 Portal。  </p></blockquote><p>OpenStack的Logical Architecture（逻辑体系结构）：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396289980075632.jpg" alt=""></p><h1 id="搭建实验环境"><a href="#搭建实验环境" class="headerlink" title="搭建实验环境"></a>搭建实验环境</h1><p>我们分两个节点进行环境部署：<br>1.devstack-controller：控制节点 + 网络节点 + 块存储节点 + 计算节点<br>2.devstack-compute：计算节点<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160403-1459686062619002987.jpg" alt=""><br>配置要求：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160403-1459686062793065054.jpg" alt=""><br>网络规划：<br><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160404-1459724662268078986.png" alt="network"><br>我们规划了三个网络： </p><p>1.<em>Management Network：</em></p><blockquote><p>用于 OpenStack 内部管理用，比如各服务之间通信。<br>这里使用 eth0        </p></blockquote><p>2.<em>VM（Tenant）Network：</em></p><blockquote><p>OpenStack 部署的虚拟机所使用的网络。<br>OpenStack 支持多租户（Tenant），虚机是放在 Tenant 下的，所以叫 Tenant Network。<br>这里使用 eth1        </p></blockquote><p>3.<em>External Network：</em></p><blockquote><p>一般来说，Tenant Network 是内部私有网络，只用于 VM 之间通信，与其他非 VM 网络是隔离的。<br>这里我们规划了一个外部网络（External Network），通过 devstak-controller 的 eth2 连接。<br>Neutron 通过 L3 服务让 VM 能够访问到 External Network。<br>对于公有云，External Network 一般指的是 Internet。<br>对于企业私有云，External Network 则可以是 Intranet 中的某个网络。 </p></blockquote><h1 id="部署DevStack"><a href="#部署DevStack" class="headerlink" title="部署DevStack"></a>部署DevStack</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20160331-1459396287488044421.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;OpenStack架构&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://cyneliu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网工" scheme="https://cyneliu.github.io/tags/%E7%BD%91%E5%B7%A5/"/>
    
      <category term="OpenStack" scheme="https://cyneliu.github.io/tags/OpenStack/"/>
    
  </entry>
  
</feed>
